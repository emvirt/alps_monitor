		TOPPERS/FMPカーネル
		SH2A-DUAL(GCC)アーキテクチャ依存部 設計メモ

		対応バージョン: Release 1.1.1
		最終更新: 2010年5月10日

このドキュメントは，TOPPERS/FMPカーネルのSH12A(GCC)アーキテクチャ依存
部の設計メモである．
ターゲット依存の事項は、ターゲット依存部のtarget_user.txtに記載してい
るので、こちらも参照のこと。

----------------------------------------------------------------------
 TOPPERS/FMP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 Copyright (C) 2007-2010 by Industrial Technology Institute,
                                    Miyagi Prefectural Government, JAPAN

 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．

 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．

----------------------------------------------------------------------


○概要

SH12A依存部は，SH1/SH2/SH2E/SH2Aをターゲットとしている．SH1/SH2/SH2E/
SH2Aにはいくつかのバリエーションが存在し，バリエーションによっては，割
込み関連のレジスタや扱える例外や割込みの数が異なる．そのため，バリエー
ション毎に異なる部分はバリエーション毎のファイルに分けることにより対応
する．
具体的には、以下の3階層に分割している。

１．アーキテクチャ依存部（プロセッサ依存部）
　　　SH1/SH2/SH2E/SH2Aが共通して、使用する部分。
２．コア依存部
　　　SH1/SH2/SH2E/SH2A/SH2A-DUALの各コア毎の違いを定義する部分。
３．チップ依存部
　　　SHxxxxの型番毎の違いを定義する部分。

現在は、コアがSH2A-DUALの場合のみ、実装している。

要検討
　SH2AとSH2A-DUALの割込みコントローラの違いが完全に分離できていない。
（マクロや関数の前方参照があり、完全に分離しようとすると、大幅な書き換
えが必要）
そのため、アーキテクチャ依存部に割込みコントローラ依存（＝SH2A-DUAL依
存）の記述が入ってしまっている。
割込みコントローラ以外にもシングルプロセッサ／マルチプロセッサによる違
いもあり、アーキテクチャ依存部をSH2AとSH2A-DUALとで共通にできるように
修正することは意義が低いと考えている。


○CPU例外の取り扱い

サポートするCPU例外ハンドラ数はターゲットプロセッサ毎に異なるので，
ターゲットプロセッサ毎の定義ファイルに定義する．

●CPU例外ハンドラ番号

CPU例外ハンドラ番号としては，ベクタ番号を用いる．割込みのうち，NMI，
ユーザーブレーク，H-UDIはCPU例外として扱う．

●制限事項

・exc_sense_unlock()
SH12Aでは，CPU例外が発生した時のIPM（ハードウェアの割込み優先度マス
ク）がTIPM_LOCK(=TMIN_INTPRI)より低いことをチェックすることで，
　・カーネル実行中でないこと
　・全割込みロック状態でないこと
　・CPUロック状態でないこと
の3つの条件をチェックしている（CPU例外が発生した時のlock_flagは参照し
ていない）．これにより，（モデル上の）割込み優先度マスクをTIPM_LOCK以
上に設定してタスクを実行している時にもfalseが返ってしまうが，判断を正
確にするためのオーバヘッドが大きいことから，許容することにする．


○割込みの取り扱い

●割込みハンドラ番号と割込み番号

割込みハンドラ番号(inhno)と割込み番号(intno)は，ベクタ番号を用いる．

・ベクタ番号の内部表現

割込みのベクタ番号はTMIN_INTNO(=64)から始まるため，そのままの値を優先
度管理のテーブル等のインデックスに用いると，無駄な領域が発生する．
そのため，カーネル内部では，TMIN_INTNOを差し引いた値（内部表現）を用い
る．

●コンテキスト

割込み/CPU例外のネスト回数で、コンテキストを判別している。
ネスト回数は変数excnest_countを用いてカウントしている。
従って、コンテキスト切り替え時における
　・excnest_countの操作
　・スタック切り替え
は不可分に行う必要がある。
カーネル管理外の割込みに対応する場合は、この点に注意が必要である。

　(1)コンテキスト判別 sense_context()
　　　・excnest_count==0であれば、タスクコンテキスト
　　　・そうでなければ、非タスクコンテキスト
　(2)CPU例外発生時のコンテキスト判別 exc_sense_context()
　　　・excnest_count==1であれば、タスクコンテキスト
　　　　（CPU例外の分、＋１されている。）
　　　・そうでなければ、非タスクコンテキスト
　　　

●割込み優先度

SH12Aでは，ステータスレジスタ（SR）の4〜7ビット目の4ビットに割込み優先
度マスク（ハードウェアの割込み優先度マスク，IPM）が置かれている．IPMを
保存しておくために，割込み優先度の外部表現（-1から連続した負の値）を使
うことも可能であるが，余計な左右ビットシフトと符号反転が必要になる．こ
れを避けるために，IPMを保存する場合には，SRの4〜7ビット目を取り出した
値を使うことにする．この値を割込み優先度マスクの内部表現と呼び，IIPMと
書くことにする．


●CPUロックフラグ

SH12Aはステータスレジスタ(SR)内に割込み優先度マスク(IPM)を持っている．
一方、CPUロックフラグ相当の機能を持たない．そのため，擬似的にCPUロック
フラグを実現する．

まず，CPUロック状態を管理すための変数(lock_flag)を用意する．

CPUロックフラグがクリアされている間は，IPMをモデル上の割込み優先度マス
クの値に設定する．この間は，モデル上の割込み優先度マスクは，IPMを用い
る．

それに対してCPUロックフラグがセットされいる間は，
 　・IPMを，カーネル管理外のものを除くすべての割込み要求をマスクする値
 　　(TIPM_LOCK)
 　・モデル上の割込み優先度マスク
の２つの内、高い方に設定する．この間のモデル上の割込み優先度マスクは，
そのための変数(saved_iipm, 内部表現で保持)を用意して保持する．
タスクコンテキストでは，CPUロック状態以外では，saved_iipmは常にIPMと同
じ値になるようにする．

●割込み要求ライン

SH12Aの割込みは，内蔵周辺モジュール割込みとIRQ割込みに分類でき，それぞ
れ扱いが異なる．IRQ割込みは，割込み属性の設定をサポートする．

各割込みの割込み優先度は割込み優先レベル設定レジスタ(IPRXX)によって設
定する．そのため，各割込み要求ライン毎にどの割込み優先レベル設定レジス
タのどのフィールドに対応しているかの情報（IPR_INFO型）のテーブル
ipr_info_tbl[]を用意する．
割込み番号は連続していないため，サポートしていない番号には，addressエ
ントリに0を設定し、これにより割込み番号の妥当性を判別できる。
（サポートする割込み番号はアプリケーションによらず、プロセッサのハード
ウェア仕様によって決まるので、定数データとして保持する。）
このテーブルのインデックスには、割込み番号の内部表現を用いる。

メンバoffsetは8ビットあれば十分だが、下記の理由で32ビットにしている。
　・この構造体を配列にすると隙間ができるだけで、メモリの節約に
　　ならない。
　・SHでは32ビットデータでないと無駄な命令が生成される。

typdef struct {
	/* 割込み優先レベル設定レジスタのアドレス */
	uint32_t address;
	/* オフセット */
	uint32_t offset;
}IPR_INFO;

IPR_INFO ipr_info_tbl[] = {
	....
}

このテーブルの具体的な内容は、IPR_INFO_TBL_DATAマクロとして、チップ依
存部で定義する。

内蔵周辺モジュールの場合，周辺モジュール毎に割込み優先度を設定可能であ
る．例えばSCIFは，ERI2, RXI2, BRI2, TXI2という4つの割込み要求ラインを
サポートするが，全ての割込み要求ラインに対して同一の優先度しか設定でき
ない．
このエラーチェックはテンプレートファイルprc.tfで行っている。

[SH2A-DUAL固有]
　テーブルipr_info_tbl[]のメンバaddressには、CPU0のC0IPRxのアドレスだ
けを格納する。CPU1のC1IPRxのアドレスは、CPU0のC0IPRxのアドレスに0x100
を加えることで求められる。
（サポートする割込み番号はアプリケーションによらず、プロセッサのハード
ウェア仕様によって決まるので、両コアで共通の定数データとして保持する。）
　


●割込み要求禁止フラグ

シングルプロセッサのSH12Aでは、すべての割込み要因毎において、割込み要
求禁止フラグの機能を割込み優先レベル設定レジスタ(IPRXX)で代替していた
が、SH2A-DUALでは、割込み要因毎に表現方法を変えている。

・IRQ割込み
　　割込み優先レベル設定レジスタ(IPRXX)で代替
　　　・CxIRQERレジスタでは、両コア同時に割込み禁止にできない。
　　　・IPRXXレジスタでも、IRQ番号毎（＝割込み番号毎）に個別に設定でき
　　　　るため、異なる割込み番号の設定内容に影響を受ける問題はない。
　　　
・PINT割込み
　　CxPINTレジスタのPINTnEビット

・内蔵周辺モジュール割込み
　　IDCNT6〜140レジスタのINTENビット

・プロセッサ間割込み
　　CxIPERレジスタのCIPEnビット

下記のテーブルint_iipm_tbl[]は、初期設定時に用いる。
（IRQ割込みの許可／禁止でも用いる。）

SH12AのIRCは割込み要求禁止フラグを持たない．割込みを個別に禁止する場合
は，割込み優先レベル設定レジスタ(IPRXX)を0に設定する必要がある．割込み
優先レベル設定レジスタを0にすることで割込み要求禁止フラグを実現すると、
その間、モデル上の割込み優先度を記憶しておく領域が必要となる．コンフィ
ギュレータでこのためのuint8_t型のテーブルint_iipm_tbl[]を用意する．
ビット割り当てが割込み優先度の外部表現とも内部表現とも異なるので、注意
すること。（符号を反転しているが、ビットシフトしていない。）
割込み優先度が設定されているかどうかはビット7で保持する。
（アプリケーションに依存した情報）

テーブルint_iipm_tbl[]に格納する値のビット割り当て：
　　　ビット0〜3：IPRXXに設定するビットパターン
　　　　　　　　　（割込み優先レベル）
　　　ビット7：NOT_CFG_INT_BIT
　　　　　　　　0:CFG_INTで割込み優先度が設定されている。
　　　　　　　　1:CFG_INTで割込み優先度が設定されていない。

●割込み／CPU例外からの戻り先が割込み／CPU例外の入口処理か否かの判別
　（prc_support.Sの_ret_int_2および_ret_exc_2付近を参照）

SH12AではCPU例外/割込み受付直後に割込み禁止になっていないため、割込みA
の入口処理中に別の割込みBが入る可能性がある。
（これはハードウェアのアーキテクチャ上避けようがない。）
割込みハンドラB内でタスク切り替えを起こすようなサービスコールを呼ぶと
割込みBの出口処理で別のタスクにディスパッチしてしまい、タスク2から元の
タスクに戻ってくるまで、割込みAの処理が遅れてしまう。
これを防ぐため、割込み/例外の入口処理をまとめてvector_entryセクション
に置き，戻り先のアドレスがこの範囲内ならディスパッチせずにリターンする．


●割込み待ちのsleep命令について
　（prc_support.Sの_dispatcher_2付近を参照）

ディスパッチャの出口で実行すべきタスクがない(schedtsk==NULL）場合は、
sleep命令によってプロセッサを省電力モードに切り替えて割込み待ちをして
いる。

割込み許可後にsleep命令を実行しているため、割込み許可命令の実行前に割
込み要求が入っている場合（あるいは割込み許可直後、sleep命令実行前に割
込み要求が入った場合）、割込み許可命令の実行と共に割込みが受け付けられ、
その復帰後にsleepしたままになり、reqflgのチェックに進まない。
（1msec以内にタイマ割込みが入るため、実際にはsleepしたままということは
ない。）
この問題は、割込みの許可とsleep状態への移行がアトミックに実行できない
ことに起因する。
この問題を解決するため，rte命令の「PC,SR更新と遅延スロットの命令を、割
込みとは不可分に実行する」という仕様を利用し，割込みの許可と省電力モー
ドへの移行を不可分に行う．

●IRQ割込み要求のクリア（SH2Aコア固有）

IRQRRレジスタを一度、ダミーリードして、 該当ビットに0を書き込む。
現状では、以下のような実装としている。

Inline void
i_begin_int(INTNO intno)
{
    SIL_PRE_LOC;
    uint32_t irqpr, bitptn;
    if (INTNO_IS_IRQ(intno)) {
        /*
         * 一度、ダミーリードして、 該当ビットに0を書き込む。
         *  　変数bitptnを用いているのは、全割込みロックの区間を
         *  　短くするため
         */
        bitptn = ~(0x01U << INTNO_TO_IRQNO(intno));
        SIL_LOC_INT();
        irqpr = sil_reh_mem((void *)IRQRR);
        irqpr &= bitptn;
        sil_wrh_mem((void *)IRQRR, irqpr);
        SIL_UNL_INT();
    }
}

IRQRRレジスタを操作する間、全割込みロック状態にしているのは、以下のよ
うなケースを防ぐためである。

3種類の割込みを考える。
割込み優先度は、l > m > nの順とする。
（割込みlの優先度が高い。）

1.  mの割込みが発生(mビットがセット)
2.  mの割込みハンドラが実行(nは割込み禁止)
3.  IRQRRリード(l = 0, m = 1, n = 0)
4.  lの割込みが発生(lビットがセット)
5.  lの割込みハンドラが実行(nは割込み禁止)
6.  nの割込みが発生（保留）(nビットがセット)
7.  IRQRRリード(l = 1, m = 1, n = 1)
8.  IRQRRライト(l = 0, m = 1, n = 1)
9.  lの割込みハンドラ終了
10. mの割込みハンドラ再開
11. IRQQライト(l = 0, m = 0, n = 0)

11の段階で n がクリアされる可能性がある．


○制限事項
　　・FPUの扱い
　　　　本カーネルではSH2AのFPUはサポートしていない．

　　・コントロールレジスタの扱い
　　　　本カーネルではグローバルベースレジスタGBR、ジャンプテーブル
　　　　ベースレジスタTBRはサポートしていない．

　　・IRQ割込み端子の初期化
　　　　本来はCFG_INTで指定されたIRQ入力端子の初期化をカーネル側ですべ
　　　　きだが、SH2-Aでは、IRQ番号から接続先の端子が一意に決まらない
　　　　（複数の端子から選択できる）ため、IRQ入力端子の初期化はサポート
　　　　していない。（端子番号に依存しない割込みコントローラの初期化は
　　　　行っている。）

=====================================================================
               ターゲット依存部開発者向けの情報
=====================================================================

SH12A依存部は、以下のように3階層に分割されている。

１．アーキテクチャ依存部（プロセッサ依存部）
　　　SH1/SH2/SH2E/SH2Aが共通して、使用する部分。
　　　ファイル名には接頭辞prc_を付ける。
　　　（Makefileの場合は、末尾に付ける。）
２．コア依存部
　　　SH1/SH2/SH2E/SH2Aの各コア毎の違いを定義する部分。
　　　ファイル名には接頭辞shx_を付ける。（xは1,2,2e,2aのいずれか。）
　　　（Makefileの場合は、末尾に付ける。）
３．チップ依存部
　　　SHxxxxの型番毎の違いを定義する部分。
　　　ファイル名には接頭辞shxxxx_を付ける。
　　　（xxxxは型番を表す。）


○サポートプロセッサの追加

サポートするチップを追加する場合には，以下のファイルを作成する必要があ
る．その他のファイルが必要な場合は，チップの型番を先頭に付けファイルを
作成し，ターゲット依存部からインクルードすればよい．

１．コア依存部
　コアの名称をshxとする。
　　・Makefile.shx		Makefileのコア依存部
　　・shx.tf			kernel.tfのコア依存部
　　・shx_config.h		カーネル実装のコア依存の定義

２．チップ依存部
　サポートするチップの型番をshxxxxとする。
　　・shxxxx.tf			kernel.tfのチップ依存部
　　・shxxxx_config.h	カーネル実装のチップ依存の定義
　　・shxxxx.h			ハードウェア資源のヘッダーファイル


コア依存部／チップ依存部には，以下のマクロや関数を定義する．
ターゲット依存部では，使用するチップのチップ依存部のファイルをインク
ルードする。
チップ依存部のファイルからは、コア依存部、アーキテクチャ依存部の順にイ
ンクルードされる。
チップ依存部に該当するファイルがない場合は、コア依存部のファイルをイン
クルードする。コア依存部に該当するファイルがない場合はアーキテクチャ依
存部のファイルをインクルードする。

○コア毎の定義内容

●Makefile.shx		Makefileのコア依存部

・コンパイルオプション COPTS
　　例：COPTS := $(COPTS) -m2a-nofpu

・マクロ定義 CDEFS


●shx.tf			kernel.tfのコア依存部

・NMIの割込み番号	TINTNO_NMI
・割込み属性中のターゲット依存に用いるビット	TARGET_INTATR
・CFG_INTで設定できる割込み属性のリスト
　　・IRQ割込みで使用できる割込み属性	valid_irq_intatr_list
　　・NMIで使用できる割込み属性			valid_nmi_intatr_list

●shx_config.h		カーネル実装のコア依存の定義

・コアの種類
・コア（命令セット）の種類

使用するプロセッサ・コアの種類をターゲット依存部の Makefile.target内で
PRC_COREとして定義する．現在は、PRC_CORE＝sh2aの場合のみ、実装している。
sh1/sh2/sh2e/sh2aのいずれかに定義されることを想定している。
また、使用できる命令セットの種類を以下のマクロとして、コア依存部のイン
クルードファイル内（例：sh2a_config.h）で定義する。
SH1用命令については、すべてのコアでサポートされるので、特に定義しない。

#define TOPPERS_SUPPORT_SH2_INSTRUCTION
#define TOPPERS_SUPPORT_SH2E_INSTRUCTION
#define TOPPERS_SUPPORT_SH2A_INSTRUCTION

・INTNO_IS_IRQ(intno)　	IRQ割込みかどうかを判定するためのマクロ
・INTNO_TO_IRQNO(intno)	割込み番号からIRQ番号への変換マクロ
・void irc_initialize(void)
						割込みコントローラの初期化
・void x_config_intatr(INTNO intno, ATR intatr)
						割込みの属性設定
・void i_begin_int(INTNO intno)
						割込みハンドラ入口で必要なIRC操作

○チップ毎の定義内容

●shxxxx.tf			kernel.tfのチップ依存部

CFG用のテンプレートファイルには以下の変数をを定義する．ターゲット依存
部のCFG用テンプレートファイルでは，prc.tf をインクルードする前に，使用
するターゲットプロセッサのCFG用テンプレートファイルをインクルードする
こと．

・有効な割込み番号，割込みハンドラ番号，CPU例外ハンドラ番号

$INTNO_VALID
$INHNO_VALID
$EXCNO_VALID

・同じ割込み優先度を設定しなければならない割込み番号のリスト

$same_intpri_list
（-1をセパレータとする。）

●shxxxx_config.h	カーネル実装のチップ依存の定義

・CPU例外番号に関する定義

  TMIN_EXCNO : CPU例外番号の最小値
  TMAX_EXCNO : CPU例外番号の最大値
  TNUM_EXC   : CPU例外番号数(スパースな場合はその間もカウントする)

・割込みハンドラ番号に関する定義

  TMIN_INHNO : 割込みハンドラ番号の最小値
  TMAX_INHNO : 割込みハンドラ番号の最大値
  TNUM_INH   : 割込みハンドラ数(スパースな場合はその間もカウントする)

・割込み番号に関する定義

  TMIN_INTNO : 割込み番号の最小値
  TMAX_INTNO : 割込み番号の最大値
  TNUM_INT   : 割込み数(スパースな場合はその間もカウントする)
  
  TMIN_INTNO_IRQ : IRQ割込みの割込み番号の最小値
  TMAX_INTNO_IRQ : IRQ割込みの割込み番号の最大値

・割込み要求ライン毎の優先レベル設定レジスタの設定情報

  IPR_INFO_TBL_DATA

・割込み優先レベル設定レジスタの初期化関数

  Inline void init_ipr(void);

●shxxxx.h			ハードウェア資源のヘッダーファイル

・例外ベクタ番号
　　yyyyyyyy_VECTOR：yyyyyyyyはCPU例外要因
・割込みベクタ番号
　　yyyyyyyy_VECTOR：yyyyyyyyは割込み要因
・内蔵ペリフェラルのレジスタの定義
　　・割込みコントローラ
　　・タイマ
　　・シリアルインターフェース
　　・ピンファンクションコントローラ
・スロット不当命令の指定
　　遅延スロットにldc命令を配置するとスロット不当命令になる場合
　　（sh7619(sh2コア＋Ethernet)がこのケースに相当）は
　　TOPPERS_LDC_IS_SLOT_ILLEGAL_INSTRUCTIONマクロを定義すると
　　prc_support.S内の該当個所が、条件アセンブルでldc命令を遅延スロット
　　に配置しないように切り替わる。

○変更履歴

'09/07/30 
　・SH2A-DUAL向けの変更点を追記

'09/04/10 
　・TOPPERS_LDC_IS_SLOT_ILLEGAL_INSTRUCTIONマクロの説明を追加

'09/04/02 
　・shxxxx.tfの定義内容から以下の変数を削除
　　　EXCNO_RANGE、INTNO_RANGE、INHNO_RANGE
　　　TMIN_INTNO_IRQ、TMAX_INTNO_IRQ
　・set_irc_ipr()
　　　shx_config.hからprc_config.hへ移動
　・i_begin_int()
　　　prc_config.hからshx_config.hへ移動
　・init_irc(), set_irc_ipr()
　　　それぞれirc_initialize(),irc_set_ipr()にリネーム

'09/03/31 
　・以下の2節を追加
　　　・割込み／CPU例外の出口での戻り先のコンテキスト判別について
　　　・実行すべきタスクがない場合の省電力モードについて

'09/03/27 
　・ユーザーズ・マニュアルから分離
　
