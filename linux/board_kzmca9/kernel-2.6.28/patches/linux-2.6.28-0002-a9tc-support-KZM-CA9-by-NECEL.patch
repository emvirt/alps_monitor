From 60cf85e7e651bc520248a66395a6a52d6145703a Mon Sep 17 00:00:00 2001
From: Keitaro Kitagawa <kita@kmckk.co.jp>
Date: Fri, 13 Nov 2009 20:54:40 +0900
Subject: [PATCH 2/2] a9tc: support KZM-CA9 by NECEL

---
 arch/arm/Kconfig                              |   15 +-
 arch/arm/Makefile                             |    4 +-
 arch/arm/boot/Makefile                        |    3 +-
 arch/arm/common/gic.c                         |   10 +-
 arch/arm/configs/a9tc-single_defconfig        | 1102 ++++++++++++++++++++++++
 arch/arm/configs/a9tc-smp_defconfig           | 1106 +++++++++++++++++++++++++
 arch/arm/mach-a9tc/Kconfig                    |   20 +
 arch/arm/mach-a9tc/Makefile                   |   10 +
 arch/arm/mach-a9tc/Makefile.boot              |    3 +
 arch/arm/mach-a9tc/audio.c                    |  396 +++++++++
 arch/arm/mach-a9tc/board.c                    |  390 +++++++++
 arch/arm/mach-a9tc/clock.c                    |  120 +++
 arch/arm/mach-a9tc/clock.h                    |   25 +
 arch/arm/mach-a9tc/codec.c                    |  267 ++++++
 arch/arm/mach-a9tc/codec.h                    |   38 +
 arch/arm/mach-a9tc/core.c                     |  214 +++++
 arch/arm/mach-a9tc/core.h                     |   57 ++
 arch/arm/mach-a9tc/headsmp.S                  |   39 +
 arch/arm/mach-a9tc/hotplug.c                  |  141 ++++
 arch/arm/mach-a9tc/include/Kconfig            |   20 +
 arch/arm/mach-a9tc/include/Makefile           |   10 +
 arch/arm/mach-a9tc/include/Makefile.boot      |    3 +
 arch/arm/mach-a9tc/include/audio.c            |  396 +++++++++
 arch/arm/mach-a9tc/include/board.c            |  390 +++++++++
 arch/arm/mach-a9tc/include/clock.c            |  120 +++
 arch/arm/mach-a9tc/include/clock.h            |   25 +
 arch/arm/mach-a9tc/include/codec.c            |  267 ++++++
 arch/arm/mach-a9tc/include/codec.h            |   38 +
 arch/arm/mach-a9tc/include/core.c             |  214 +++++
 arch/arm/mach-a9tc/include/core.h             |   57 ++
 arch/arm/mach-a9tc/include/headsmp.S          |   39 +
 arch/arm/mach-a9tc/include/hotplug.c          |  141 ++++
 arch/arm/mach-a9tc/include/localtimer.c       |  202 +++++
 arch/arm/mach-a9tc/include/mach/board.h       |  112 +++
 arch/arm/mach-a9tc/include/mach/debug-macro.S |   21 +
 arch/arm/mach-a9tc/include/mach/dma.h         |   20 +
 arch/arm/mach-a9tc/include/mach/entry-macro.S |   87 ++
 arch/arm/mach-a9tc/include/mach/hardware.h    |   31 +
 arch/arm/mach-a9tc/include/mach/io.h          |   33 +
 arch/arm/mach-a9tc/include/mach/irqs.h        |   35 +
 arch/arm/mach-a9tc/include/mach/memory.h      |   38 +
 arch/arm/mach-a9tc/include/mach/platform.h    |   53 ++
 arch/arm/mach-a9tc/include/mach/scu.h         |   13 +
 arch/arm/mach-a9tc/include/mach/smp.h         |   30 +
 arch/arm/mach-a9tc/include/mach/system.h      |   41 +
 arch/arm/mach-a9tc/include/mach/timex.h       |   23 +
 arch/arm/mach-a9tc/include/mach/uncompress.h  |   63 ++
 arch/arm/mach-a9tc/include/mach/vmalloc.h     |   20 +
 arch/arm/mach-a9tc/include/platsmp.c          |  247 ++++++
 arch/arm/mach-a9tc/localtimer.c               |  202 +++++
 arch/arm/mach-a9tc/platsmp.c                  |  247 ++++++
 arch/arm/mm/Kconfig                           |    4 +-
 arch/arm/mm/alignment.c                       |    2 +-
 arch/arm/mm/cache-v7.S                        |   49 ++
 arch/arm/mm/proc-v7.S                         |   22 +-
 arch/arm/tools/mach-types                     |    1 +
 drivers/input/keyboard/Kconfig                |    5 +
 drivers/input/keyboard/Makefile               |    1 +
 drivers/input/keyboard/a9tc_keypad.c          |  285 +++++++
 drivers/input/touchscreen/Kconfig             |   10 +
 drivers/input/touchscreen/Makefile            |    1 +
 drivers/input/touchscreen/a9tc_ts.c           |  213 +++++
 drivers/mmc/host/Kconfig                      |    5 +
 drivers/mmc/host/Makefile                     |    1 +
 drivers/mmc/host/a9tc_mmc.c                   |  760 +++++++++++++++++
 drivers/mmc/host/a9tc_mmc.h                   |  221 +++++
 drivers/net/smc911x.c                         |   12 +
 drivers/rtc/Kconfig                           |    6 +
 drivers/rtc/Makefile                          |    1 +
 drivers/rtc/rtc-a9tc.c                        |  559 +++++++++++++
 fs/Kconfig                                    |   33 +
 fs/cramfs/inode.c                             |   92 ++
 include/linux/amba/clcd.h                     |    2 +-
 include/linux/cramfs_fs_sb.h                  |    4 +
 init/do_mounts.c                              |   17 +
 75 files changed, 9492 insertions(+), 12 deletions(-)
 create mode 100644 arch/arm/configs/a9tc-single_defconfig
 create mode 100644 arch/arm/configs/a9tc-smp_defconfig
 create mode 100644 arch/arm/mach-a9tc/Kconfig
 create mode 100644 arch/arm/mach-a9tc/Makefile
 create mode 100644 arch/arm/mach-a9tc/Makefile.boot
 create mode 100644 arch/arm/mach-a9tc/audio.c
 create mode 100644 arch/arm/mach-a9tc/board.c
 create mode 100644 arch/arm/mach-a9tc/clock.c
 create mode 100644 arch/arm/mach-a9tc/clock.h
 create mode 100644 arch/arm/mach-a9tc/codec.c
 create mode 100644 arch/arm/mach-a9tc/codec.h
 create mode 100644 arch/arm/mach-a9tc/core.c
 create mode 100644 arch/arm/mach-a9tc/core.h
 create mode 100644 arch/arm/mach-a9tc/headsmp.S
 create mode 100644 arch/arm/mach-a9tc/hotplug.c
 create mode 100644 arch/arm/mach-a9tc/include/Kconfig
 create mode 100644 arch/arm/mach-a9tc/include/Makefile
 create mode 100644 arch/arm/mach-a9tc/include/Makefile.boot
 create mode 100644 arch/arm/mach-a9tc/include/audio.c
 create mode 100644 arch/arm/mach-a9tc/include/board.c
 create mode 100644 arch/arm/mach-a9tc/include/clock.c
 create mode 100644 arch/arm/mach-a9tc/include/clock.h
 create mode 100644 arch/arm/mach-a9tc/include/codec.c
 create mode 100644 arch/arm/mach-a9tc/include/codec.h
 create mode 100644 arch/arm/mach-a9tc/include/core.c
 create mode 100644 arch/arm/mach-a9tc/include/core.h
 create mode 100644 arch/arm/mach-a9tc/include/headsmp.S
 create mode 100644 arch/arm/mach-a9tc/include/hotplug.c
 create mode 100644 arch/arm/mach-a9tc/include/localtimer.c
 create mode 100644 arch/arm/mach-a9tc/include/mach/board.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-a9tc/include/mach/dma.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-a9tc/include/mach/hardware.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/io.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/irqs.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/memory.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/platform.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/scu.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/smp.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/system.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/timex.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-a9tc/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-a9tc/include/platsmp.c
 create mode 100644 arch/arm/mach-a9tc/localtimer.c
 create mode 100644 arch/arm/mach-a9tc/platsmp.c
 create mode 100644 drivers/input/keyboard/a9tc_keypad.c
 create mode 100644 drivers/input/touchscreen/a9tc_ts.c
 create mode 100644 drivers/mmc/host/a9tc_mmc.c
 create mode 100644 drivers/mmc/host/a9tc_mmc.h
 create mode 100644 drivers/rtc/rtc-a9tc.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index df497fa..5dc269d 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -552,6 +552,15 @@ config ARCH_MSM
 	  interface to the ARM9 modem processor which runs the baseband stack
 	  and controls some vital subsystems (clock and power control, etc).
 
+config ARCH_A9TC
+	bool "NECEL Cortex-A9 TestChip"
+	select ARM_AMBA
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
+	select ARM_GIC
+	help
+	  This enables support for A9TC.
+
 endchoice
 
 source "arch/arm/mach-clps711x/Kconfig"
@@ -630,6 +639,8 @@ source "arch/arm/mach-ks8695/Kconfig"
 
 source "arch/arm/mach-msm/Kconfig"
 
+source "arch/arm/mach-a9tc/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -826,7 +837,7 @@ source "kernel/time/Kconfig"
 
 config SMP
 	bool "Symmetric Multi-Processing (EXPERIMENTAL)"
-	depends on EXPERIMENTAL && (REALVIEW_EB_ARM11MP || REALVIEW_EB_A9MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PBX)
+	depends on EXPERIMENTAL && (REALVIEW_EB_ARM11MP || REALVIEW_EB_A9MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PBX) || ARCH_A9TC
 	select USE_GENERIC_SMP_HELPERS
 	help
 	  This enables support for systems with more than one CPU. If you have
@@ -883,7 +894,7 @@ config HOTPLUG_CPU
 
 config LOCAL_TIMERS
 	bool "Use local timer interrupts"
-	depends on SMP && (REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || REALVIEW_EB_A9MP || MACH_REALVIEW_PBX)
+	depends on SMP && (REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || REALVIEW_EB_A9MP || MACH_REALVIEW_PBX || ARCH_A9TC)
 	default y
 	help
 	  Enable support for local timers on SMP platforms, rather then the
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 5d55e85..5b72644 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -157,6 +157,7 @@ endif
  machine-$(CONFIG_ARCH_MSM)	   := msm
  machine-$(CONFIG_ARCH_LOKI)       := loki
  machine-$(CONFIG_ARCH_MV78XX0)    := mv78xx0
+ machine-$(CONFIG_ARCH_A9TC)    := a9tc
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
@@ -207,7 +208,8 @@ libs-y				:= arch/arm/lib/ $(libs-y)
 ifeq ($(CONFIG_XIP_KERNEL),y)
 KBUILD_IMAGE := xipImage
 else
-KBUILD_IMAGE := zImage
+#KBUILD_IMAGE := zImage
+KBUILD_IMAGE := uImage
 endif
 
 all:	$(KBUILD_IMAGE)
diff --git a/arch/arm/boot/Makefile b/arch/arm/boot/Makefile
index b2b146d..d25bf77 100644
--- a/arch/arm/boot/Makefile
+++ b/arch/arm/boot/Makefile
@@ -77,7 +77,8 @@ else
 $(obj)/uImage: STARTADDR=$(LOADADDR)
 endif
 
-$(obj)/uImage:	$(obj)/zImage FORCE
+//$(obj)/uImage:	$(obj)/zImage FORCE
+$(obj)/uImage:	$(obj)/Image FORCE
 	$(call if_changed,uimage)
 	@echo '  Image $@ is ready'
 
diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index 7fc9860..9ea2412 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -113,15 +113,16 @@ static void gic_set_cpu(unsigned int irq, cpumask_t mask_val)
 {
 	void __iomem *reg = gic_dist_base(irq) + GIC_DIST_TARGET + (gic_irq(irq) & ~3);
 	unsigned int shift = (irq % 4) * 8;
-	unsigned int cpu = first_cpu(mask_val);
+	unsigned int cpu = any_online_cpu(mask_val);
 	u32 val;
+	unsigned long flags;
 
-	spin_lock(&irq_controller_lock);
+	spin_lock_irqsave(&irq_controller_lock, flags);
 	irq_desc[irq].cpu = cpu;
 	val = readl(reg) & ~(0xff << shift);
 	val |= 1 << (cpu + shift);
 	writel(val, reg);
-	spin_unlock(&irq_controller_lock);
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
 }
 #endif
 
@@ -236,6 +237,9 @@ void __init gic_dist_init(unsigned int gic_nr, void __iomem *base,
 		set_irq_chip_data(i, &gic_data[gic_nr]);
 		set_irq_handler(i, handle_level_irq);
 		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+		if (i < 32) {
+			irq_desc[i].status |= IRQ_PER_CPU;
+		}
 	}
 
 	writel(1, base + GIC_DIST_CTRL);
diff --git a/arch/arm/configs/a9tc-single_defconfig b/arch/arm/configs/a9tc-single_defconfig
new file mode 100644
index 0000000..036a96a
--- /dev/null
+++ b/arch/arm/configs/a9tc-single_defconfig
@@ -0,0 +1,1102 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Fri Jul 24 08:56:43 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_ARCH_A9TC=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# A9TC platform type
+#
+# CONFIG_A9TC_ANDROID is not set
+# CONFIG_A9TC_AUDIO is not set
+# CONFIG_A9TC_L310 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_IFAR=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_L2X0=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATUM_451034 is not set
+# CONFIG_ARM_ERRATA_484863 is not set
+CONFIG_ARM_GIC=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_SMP is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs nfsroot=10.114.117.101:/work/m2_arm ip=192.168.0.13:10.114.117.101:192.168.0.1:255.255.255.0 console=ttyAMA0 mem=128M"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+CONFIG_SMC911X=y
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_KEYBOARD_A9TC=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+CONFIG_TOUCHSCREEN_A9TC=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+CONFIG_LOGO_LINUX_VGA16=y
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_DEBUG=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_COMPAT is not set
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_BRIGHT=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DELL=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_ISP1760_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_A9TC=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+# CONFIG_RTC_INTF_PROC is not set
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+CONFIG_RTC_DRV_A9TC=y
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+CONFIG_CRAMFS_LINEAR=y
+CONFIG_ROOT_CRAMFS_LINEAR=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+CONFIG_DYNAMIC_PRINTK_DEBUG=y
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_RVIDCC is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/a9tc-smp_defconfig b/arch/arm/configs/a9tc-smp_defconfig
new file mode 100644
index 0000000..f69e485
--- /dev/null
+++ b/arch/arm/configs/a9tc-smp_defconfig
@@ -0,0 +1,1106 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Wed Jul 22 14:58:16 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_ARCH_A9TC=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# A9TC platform type
+#
+# CONFIG_A9TC_ANDROID is not set
+# CONFIG_A9TC_AUDIO is not set
+CONFIG_A9TC_L310=y
+# CONFIG_A9TC_L310_WT is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_IFAR=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_L2X0=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATUM_451034 is not set
+# CONFIG_ARM_ERRATA_484863 is not set
+CONFIG_ARM_GIC=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+# CONFIG_HOTPLUG_CPU is not set
+CONFIG_LOCAL_TIMERS=y
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs nfsroot=10.114.117.101:/work/m2_arm ip=192.168.0.13:10.114.117.101:192.168.0.1:255.255.255.0 console=ttyAMA0 mem=128M"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+CONFIG_SMC911X=y
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_KEYBOARD_A9TC=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+CONFIG_TOUCHSCREEN_A9TC=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+CONFIG_LOGO_LINUX_VGA16=y
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_DEBUG=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_COMPAT is not set
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_BRIGHT=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DELL=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_ISP1760_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_A9TC=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+# CONFIG_RTC_INTF_PROC is not set
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+CONFIG_RTC_DRV_A9TC=y
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+CONFIG_CRAMFS_LINEAR=y
+CONFIG_ROOT_CRAMFS_LINEAR=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+CONFIG_DYNAMIC_PRINTK_DEBUG=y
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_RVIDCC is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/mach-a9tc/Kconfig b/arch/arm/mach-a9tc/Kconfig
new file mode 100644
index 0000000..cdf2e2e
--- /dev/null
+++ b/arch/arm/mach-a9tc/Kconfig
@@ -0,0 +1,20 @@
+menu "A9TC platform type"
+	depends on ARCH_A9TC
+
+config A9TC_ANDROID
+	bool "Use Android setting"
+
+config A9TC_AUDIO
+	bool "Use Audio driver"
+
+config A9TC_L310
+	bool "ARM L2 cache Enable"
+	default y
+	select CACHE_L2X0
+
+config A9TC_L310_WT
+	bool "ARM L2 cache WriteThrough"
+	depends on A9TC_L310
+	default n
+
+endmenu
diff --git a/arch/arm/mach-a9tc/Makefile b/arch/arm/mach-a9tc/Makefile
new file mode 100644
index 0000000..0225b6b
--- /dev/null
+++ b/arch/arm/mach-a9tc/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y					:= core.o clock.o board.o
+obj-$(CONFIG_SMP)		+= platsmp.o headsmp.o localtimer.o
+obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
+
+obj-$(CONFIG_A9TC_AUDIO) += codec.o audio.o
+
diff --git a/arch/arm/mach-a9tc/Makefile.boot b/arch/arm/mach-a9tc/Makefile.boot
new file mode 100644
index 0000000..07c2d9c
--- /dev/null
+++ b/arch/arm/mach-a9tc/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x60008000
+params_phys-y	:= 0x60000100
+initrd_phys-y	:= 0x60800000
diff --git a/arch/arm/mach-a9tc/audio.c b/arch/arm/mach-a9tc/audio.c
new file mode 100644
index 0000000..da1c940
--- /dev/null
+++ b/arch/arm/mach-a9tc/audio.c
@@ -0,0 +1,396 @@
+/*
+ *  File Name       : linux/arch/arm/mach-a9tc/audio.c
+ *  Function        : Audio driver
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/07/01
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it under the terms of
+ *  the GNU General Public License as published by Free Softwere Foundation; either version 2
+ *  of License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/platform_device.h>
+
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include "codec.h"
+
+#define MAX_BUF_NUM	8
+
+#define READ_BUFFER_SIZE        16384
+#define WRITE_BUFFER_SIZE       16384
+
+struct a9tc_audio {
+	int in_irq;
+	int out_irq;
+
+	spinlock_t lock;
+	wait_queue_head_t wait;
+	int buffer_status;
+
+	unsigned int *write_buffer;    /* write buffer virtual address */
+	unsigned int *read_buffer;      /* read buffer virtual address */
+	int count;
+
+	int codec_status;
+
+	int read_supported;         /* true if we have audio input support */
+};
+
+/* temporary variable used between a9tc_audio_probe() and a9tc_audio_open() */
+static struct a9tc_audio* audio_data;
+
+static atomic_t open_count = ATOMIC_INIT(0);
+
+static ssize_t a9tc_audio_read(struct file *fp, char __user *buf,
+							size_t count, loff_t *pos)
+{
+	struct a9tc_audio* data = fp->private_data;
+	int result = 0;
+
+	if (!data->read_supported)
+		return -ENODEV;
+
+	return result;
+}
+
+static ssize_t a9tc_audio_write(struct file *fp, const char __user *buf, size_t count, loff_t *pos)
+{
+	struct a9tc_audio* data = fp->private_data;
+
+//printk("count=%d\n", count);
+
+	data->count = count / 4;
+	data->buffer_status = 0;
+
+	if (copy_from_user(data->write_buffer, buf, count)) {
+		printk("copy_from_user failed!\n");
+		kfree(data->write_buffer);
+		return -EFAULT;
+	}
+
+#if 1
+	if (data->codec_status != 1) {
+		a9tc_codec_out_start(1);
+		data->codec_status = 1;
+	}
+
+	enable_irq(data->out_irq);
+
+	wait_event_interruptible(data->wait, data->buffer_status != 0);
+#else
+{
+#if 1
+	int i;
+	unsigned int *buf2 = data->write_buffer;
+	unsigned int val1, val2;
+
+
+	if (data->codec_status != 1) {
+		a9tc_codec_out_start(1);
+		data->codec_status = 1;
+	}
+
+	for (i = 0; i < data->count; i++) {
+		val1 = ((*buf2 & 0xffff) * 24) / 16;
+		val2 = (((*buf2 >> 16) & 0xffff) * 24) / 16;
+		writel(val1, A9TC_FPGA_PLAY_D);
+		writel(val2, A9TC_FPGA_PLAY_D);
+		buf++;
+		while ((readl(A9TC_FPGA_PLAY_C) & 0x2) == 0);
+	}
+#else
+	unsigned int f, i, j, k, c, p;
+	unsigned int l_ch = 0x00100000, r_ch = 0x00100000;
+
+	if (data->codec_status != 1) {
+		a9tc_codec_out_start(1);
+		data->codec_status = 1;
+
+	k = 0x6D;	/* 218 / 2 */
+	c = k;
+	f = 0;
+
+	i = l_ch;
+	j = r_ch;
+
+	for (p = 0; p <= 96000; p++) {
+		while ((readl(A9TC_FPGA_PLAY_C) & 0x2) == 0);
+
+		writel(i, A9TC_FPGA_PLAY_D);
+		writel(j, A9TC_FPGA_PLAY_D);
+		if ( c == 0 ) {
+			c = k;
+			if ( f == 0 ) {
+				f = 1;
+				i = 0x0;
+				j = 0x0;
+			} else {
+				f = 0;
+				i = l_ch;
+				j = r_ch;
+			}
+		} else {
+			c--;
+		}
+	}
+	}
+#endif
+}
+#endif
+
+	return count;
+}
+
+
+static irqreturn_t a9tc_audio_out_interrupt(int irq, void *dev_id)
+{
+	struct a9tc_audio *data = dev_id;
+	int count;
+
+	if ((readl(A9TC_FPGA_PLAY_C) & 0x02) == 0) {
+		return IRQ_HANDLED;
+	}
+//printk("%s: c=%d %x\n", __FUNCTION__, data->count, readl(A9TC_FPGA_PLAY_C));
+
+	count = a9tc_codec_data_write(data->write_buffer, data->count);
+	if (count > 0) {
+		data->count -= count;
+	}
+
+	if (data->count <= 0) {
+		disable_irq_nosync(data->out_irq);
+		data->buffer_status = 1;
+		wake_up(&data->wait);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int a9tc_audio_open(struct inode *ip, struct file *fp)
+{
+	struct a9tc_audio *data = audio_data;
+
+	if (!data)
+		return -ENODEV;
+
+	if (atomic_inc_return(&open_count) == 1) {
+		fp->private_data = data;
+
+
+//		a9tc_path_mute(DMA_CH_OUT, 0);
+//		a9tc_path_audio_rate(44100);
+
+		return 0;
+	} else {
+		atomic_dec(&open_count);
+		return -EBUSY;
+	}
+}
+
+static int a9tc_audio_release(struct inode *ip, struct file* fp)
+{
+	struct a9tc_audio* data = fp->private_data;
+
+#if 0
+	if (data->count > 0) {
+		disable_irq(data->out_irq);
+	}
+#endif
+
+	if (data->codec_status == 1) {
+		a9tc_codec_out_start(0);
+		data->codec_status = 0;
+	}
+
+	atomic_dec(&open_count);
+
+	return 0;
+}
+
+
+static int a9tc_audio_ioctl(struct inode* ip, struct file* fp, unsigned int cmd, unsigned long arg)
+{
+	int __user *p = (int __user *)arg;
+	int res;
+
+//printk("%s: cmd=%x\n", __FUNCTION__, cmd);
+
+	switch (cmd) {
+	case SNDCTL_DSP_RESET:
+		return 0;
+	case SNDCTL_DSP_SYNC:
+		return 0;
+
+	case SNDCTL_DSP_SPEED:
+		if (get_user(res, p))
+			return -EFAULT;
+printk("%s: speed = %d", __FUNCTION__, res);
+//		a9tc_path_audio_rate(res);
+		return 0;
+	case SNDCTL_DSP_STEREO:
+		if (get_user(res, p))
+			return -EFAULT;
+		res = res > 0 ? 2 : 1;
+printk("%s: stereo = %d", __FUNCTION__, res);
+		return 0;
+	case SNDCTL_DSP_GETBLKSIZE:
+		res = 64*1024;
+		return put_user(res, p);
+	case SNDCTL_DSP_SAMPLESIZE:
+		if (get_user(res, p))
+			return -EFAULT;
+		return 0;
+
+	/* temporary workaround, until we switch to the ALSA API */
+	case 315:
+		return -1;
+	default:
+		printk("%s: unsuppport cmd=0x%x\n", __FUNCTION__, cmd);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* file operations for /dev/eac */
+static struct file_operations a9tc_audio_fops = {
+	.owner	= THIS_MODULE,
+	.read	= a9tc_audio_read,
+	.write	= a9tc_audio_write,
+	.open	= a9tc_audio_open,
+	.release	= a9tc_audio_release,
+	.ioctl	= a9tc_audio_ioctl,
+};
+
+static struct miscdevice a9tc_audio_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "eac",
+	.fops = &a9tc_audio_fops,
+};
+
+static int a9tc_audio_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct a9tc_audio *data;
+	unsigned long flag;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if(data == NULL) {
+		ret = -ENOMEM;
+		goto err_data_alloc_failed;
+	}
+
+	data->write_buffer = kmalloc(64*1024, GFP_KERNEL);
+	if (data->write_buffer == NULL) {
+		printk("%s: kmalloc failed\n", __FUNCTION__);
+		ret = -ENOMEM;
+		goto err_buffer_alloc;
+	}
+
+	spin_lock_init(&data->lock);
+	init_waitqueue_head(&data->wait);
+	platform_set_drvdata(pdev, data);
+
+
+	spin_lock_irqsave(&data->lock, flag);
+	data->out_irq = IRQ_I2S_DI_EMPTY;
+	ret = request_irq(data->out_irq, a9tc_audio_out_interrupt, IRQF_DISABLED, "I2S_OUT", data);
+	if (ret) {
+		goto err_request_irq;
+	}
+	disable_irq(data->out_irq);
+	spin_unlock_irqrestore(&data->lock, flag);
+
+	if((ret = misc_register(&a9tc_audio_device))) {
+		printk("misc_register returned %d in a9tc_audio_init\n", ret);
+		goto err_misc_register_failed;
+	}
+
+	data->read_supported = 0;
+	data->buffer_status = 0;
+
+	a9tc_codec_init();
+
+	audio_data = data;
+	return 0;
+
+err_misc_register_failed:
+	free_irq(data->out_irq, data);
+err_request_irq:
+	kfree(data->write_buffer);
+err_buffer_alloc:
+	kfree(data);
+err_data_alloc_failed:
+	return ret;
+}
+
+static int a9tc_audio_remove(struct platform_device *pdev)
+{
+	struct a9tc_audio *data = platform_get_drvdata(pdev);
+
+	misc_deregister(&a9tc_audio_device);
+
+	free_irq(data->out_irq, data);
+	kfree(data);
+
+	audio_data = NULL;
+
+	return 0;
+}
+
+static struct platform_driver a9tc_audio_driver = {
+	.probe		= a9tc_audio_probe,
+	.remove		= a9tc_audio_remove,
+	.driver = {
+		.name = "a9tc_audio"
+	}
+};
+
+static int __init a9tc_audio_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&a9tc_audio_driver);
+	if (ret < 0) {
+		printk("platform_driver_register returned %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit a9tc_audio_exit(void)
+{
+	platform_driver_unregister(&a9tc_audio_driver);
+}
+
+module_init(a9tc_audio_init);
+module_exit(a9tc_audio_exit);
+
+MODULE_DESCRIPTION("MP200 Audio Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
diff --git a/arch/arm/mach-a9tc/board.c b/arch/arm/mach-a9tc/board.c
new file mode 100644
index 0000000..e7b5b8e
--- /dev/null
+++ b/arch/arm/mach-a9tc/board.c
@@ -0,0 +1,390 @@
+/*
+ *  linux/arch/arm/mach-a9tc/board.c
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/sysdev.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/cache-l2x0.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <mach/irqs.h>
+
+#include "core.h"
+
+static struct map_desc a9tc_io_desc[] __initdata = {
+	{
+		.virtual	= IO_ADDRESS(A9TC_INTERNAL_IO_BASE),
+		.pfn		= __phys_to_pfn(A9TC_INTERNAL_IO_BASE),
+		.length		= SZ_4M,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= IO_ADDRESS(A9TC_SCU_BASE),
+		.pfn		= __phys_to_pfn(A9TC_SCU_BASE),
+		.length		= SZ_64K,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= IO_ADDRESS(A9TC_FPGA_BASE),
+		.pfn		= __phys_to_pfn(A9TC_FPGA_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	},
+};
+
+static void __init a9tc_map_io(void)
+{
+	iotable_init(a9tc_io_desc, ARRAY_SIZE(a9tc_io_desc));
+}
+
+/*
+ * AMBA devices
+ */
+/* CLCD support. */
+static struct clcd_panel a9tc_panel = {
+	.mode		= {
+		.name		= "800x480",
+		.refresh	= 60,
+		.xres		= 800,
+		.yres		= 480,
+		.pixclock	= 42000,
+		.left_margin	= 4,	// HBP
+		.right_margin	= 6,	// HFP
+		.upper_margin	= 6,	// VBP
+		.lower_margin	= 3,	// VFP
+		.hsync_len	= 1,
+		.vsync_len	= 1,
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+	.width		= -1,
+	.height		= -1,
+	.tim2		= TIM2_BCD | TIM2_IPC | TIM2_IOE,
+	.cntl		= CNTL_LCDTFT | CNTL_LCDVCOMP(1) | CNTL_BGR,
+	.bpp		= 16,
+};
+
+#define FPGA_LCD_FLON	(1 << 9)
+static void a9tc_clcd_disable(struct clcd_fb *fb)
+{
+	unsigned int val;
+
+	val = readl(A9TC_FPGA_LCD_KEY);
+	val &= ~FPGA_LCD_FLON;
+	writel(val, A9TC_FPGA_LCD_KEY);
+}
+static void a9tc_clcd_enable(struct clcd_fb *fb)
+{
+	unsigned int val;
+
+	val = readl(A9TC_FPGA_LCD_KEY);
+	val |= FPGA_LCD_FLON;
+	writel(val, A9TC_FPGA_LCD_KEY);
+}
+static int a9tc_clcd_setup(struct clcd_fb *fb)
+{
+	unsigned long framesize;
+	dma_addr_t dma;
+
+	framesize = a9tc_panel.mode.xres * a9tc_panel.mode.yres * 2 * 2;
+
+	fb->panel = &a9tc_panel;
+
+	fb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev, framesize,
+						    &dma, GFP_KERNEL | GFP_DMA);
+	if (!fb->fb.screen_base) {
+		printk(KERN_ERR "CLCD: unable to map framebuffer\n");
+		return -ENOMEM;
+	}
+
+	fb->fb.fix.smem_start	= dma;
+	fb->fb.fix.smem_len	= framesize;
+
+	return 0;
+}
+static int a9tc_clcdfb_check(struct clcd_fb *fb, struct fb_var_screeninfo *var)
+{
+	var->nonstd = 0;
+	var->accel_flags = 0;
+
+	return 0;
+}
+static int a9tc_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
+{
+	return dma_mmap_writecombine(&fb->dev->dev, vma,
+				     fb->fb.screen_base,
+				     fb->fb.fix.smem_start,
+				     fb->fb.fix.smem_len);
+}
+
+static void a9tc_clcd_remove(struct clcd_fb *fb)
+{
+	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
+			      fb->fb.screen_base, fb->fb.fix.smem_start);
+}
+
+struct clcd_board clcd_plat_data = {
+	.name		= "a9tc",
+	.check		= a9tc_clcdfb_check,
+	.decode		= clcdfb_decode,
+	.disable	= a9tc_clcd_disable,
+	.enable		= a9tc_clcd_enable,
+	.setup		= a9tc_clcd_setup,
+	.mmap		= a9tc_clcd_mmap,
+	.remove		= a9tc_clcd_remove,
+};
+
+/*
+ * These devices are connected directly to the multi-layer AHB switch
+ */
+#define CLCD_IRQ	{ IRQ_CLCD, NO_IRQ }
+#define CLCD_DMA	{ 0, 0 }
+
+/*
+ * These devices are connected via the DMA APB bridge
+ */
+#define UART0_IRQ	{ IRQ_UART0, NO_IRQ }
+#define UART0_DMA	{ 0, 0 }
+
+/* DevChip Primecells */
+AMBA_DEVICE(clcd,  "dev:20",  CLCD,  &clcd_plat_data);
+AMBA_DEVICE(uart0, "dev:f1",  UART0, NULL);
+
+static struct amba_device *amba_devs[] __initdata = {
+	&clcd_device,
+	&uart0_device,
+};
+
+
+
+
+/*
+ * A9TC platform devices
+ */
+
+/* ---- LAN9118 NIC ---- */
+static struct resource a9tc_eth_resources[] = {
+	[0] = {
+		.start		= A9TC_ETH_BASE,
+		.end		= A9TC_ETH_BASE + SZ_64K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_ETH,
+		.end		= IRQ_ETH,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+#include <linux/smc911x.h>
+static struct smc911x_platdata a9tc_smc911x_platdata = {
+	.flags		= SMC911X_USE_32BIT,
+	.irq_flags	= IRQF_DISABLED,
+	.irq_polarity	= 0,
+};
+static struct platform_device a9tc_eth_device = {
+	.name	= "smc911x",
+	.id		= 0,
+	.dev  = {
+		.platform_data = &a9tc_smc911x_platdata,
+		},
+	.num_resources	= ARRAY_SIZE(a9tc_eth_resources),
+	.resource	= a9tc_eth_resources,
+};
+
+/* ---- USB ISP1761 ---- */
+static struct resource a9tc_isp1761_resources[] = {
+	[0] = {
+		.start		= A9TC_USB_BASE,
+		.end		= A9TC_USB_BASE + SZ_128K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_USB,
+		.end		= IRQ_USB,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+struct platform_device a9tc_usb_device = {
+	.name			= "isp1760",
+	.num_resources	= ARRAY_SIZE(a9tc_isp1761_resources),
+	.resource	= a9tc_isp1761_resources,
+};
+
+/* ---- RTC RV5C348B ---- */
+static struct resource a9tc_rtc_resources[] = {
+	{
+		.start = IRQ_RTC,
+		.end   = IRQ_RTC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+static struct platform_device a9tc_rtc_device = {
+	.name = "a9tc-rtc",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(a9tc_rtc_resources),
+	.resource = a9tc_rtc_resources,
+};
+
+/* ---- mmc ---- */
+static struct resource a9tc_mmc_resources[] = {
+	[0] = {
+		.start		= A9TC_SDC_BASE,
+		.end		= A9TC_SDC_BASE + SZ_4K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_SD,
+		.end		= IRQ_SD,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+struct platform_device a9tc_mmc_device = {
+	.name			= "a9tc_mmc",
+	.num_resources	= ARRAY_SIZE(a9tc_mmc_resources),
+	.resource	= a9tc_mmc_resources,
+};
+
+/* ---- Keypad ---- */
+static struct platform_device a9tc_key_device = {
+	.name = "a9tc_key",
+	.id = -1,
+};
+
+/* ---- Touch ---- */
+static struct platform_device a9tc_touch_device = {
+	.name = "a9tc_touch",
+	.id = -1,
+};
+
+/* ---- nand ---- */
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+static struct mtd_partition a9tc_nand_partition[] = {
+	{
+	 .name   = "nand device",
+	 .offset = 0,
+	 .size   = SZ_256M
+	 },
+};
+static struct platform_nand_chip a9tc_nand_data = {
+	.nr_chips      = 1,
+	.chip_delay    = 100,
+	.options       = 0,
+	.partitions    = a9tc_nand_partition,
+	.nr_partitions = ARRAY_SIZE(a9tc_nand_partition),
+};
+static struct resource a9tc_nand_resource[] = {
+	[0] = {
+		.start = A9TC_NAND_BASE,
+		.end   = A9TC_NAND_BASE + SZ_16M - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_NMC,
+		.end	= IRQ_NMC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+static struct platform_device a9tc_nand_device = {
+	.name = "a9tc_nand",
+	.id   = -1,
+	.dev  = {
+		.platform_data = &a9tc_nand_data,
+		},
+	.resource = a9tc_nand_resource,
+	.num_resources = ARRAY_SIZE(a9tc_nand_resource),
+};
+
+/* ---- Audio ---- */
+static struct platform_device a9tc_audio_device = {
+	.name = "a9tc_audio",
+	.id = -1,
+};
+
+
+static struct platform_device *devs[] __initdata = {
+	&a9tc_eth_device,
+	&a9tc_usb_device,
+	&a9tc_rtc_device,
+	&a9tc_mmc_device,
+	&a9tc_key_device,
+	&a9tc_touch_device,
+	&a9tc_nand_device,
+	&a9tc_audio_device,
+};
+
+
+static void __init gic_init_irq(void)
+{
+	/* core tile GIC, primary */
+	gic_cpu_base_addr = __io_address(A9TC_GIC_CPU_BASE);
+	gic_dist_init(0, __io_address(A9TC_GIC_DIST_BASE), 29);
+	gic_cpu_init(0, gic_cpu_base_addr);
+}
+
+
+static void __init a9tc_init(void)
+{
+	int i;
+
+	platform_add_devices(devs, ARRAY_SIZE(devs));
+
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+#ifdef CONFIG_A9TC_L310
+	{
+		void __iomem *l2x0_base = __io_address(A9TC_L2CC_BASE);
+#ifdef CONFIG_A9TC_L310_WT
+		/* Force L2 write through */
+		writel(0x2, l2x0_base + L2X0_DEBUG_CTRL);
+#endif
+		writel(0x111, l2x0_base + L2X0_TAG_LATENCY_CTRL);
+		writel(0x111, l2x0_base + L2X0_DATA_LATENCY_CTRL);
+		// 8-way 64KB cache, Shared attribute override enable
+		l2x0_init(l2x0_base, 0x02460000, 0xc0000fff);
+	}
+#endif
+}
+
+MACHINE_START(A9TC, "A9TC")
+	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
+	.phys_io	= A9TC_UART0_BASE,
+	.io_pg_offst	= (IO_ADDRESS(A9TC_UART0_BASE) >> 18) & 0xfffc,
+	.boot_params	= PHYS_OFFSET + 0x00000100,
+	.map_io		= a9tc_map_io,
+	.init_irq	= gic_init_irq,
+	.timer		= &a9tc_timer,
+	.init_machine	= a9tc_init,
+MACHINE_END
diff --git a/arch/arm/mach-a9tc/clock.c b/arch/arm/mach-a9tc/clock.c
new file mode 100644
index 0000000..f3e2965
--- /dev/null
+++ b/arch/arm/mach-a9tc/clock.c
@@ -0,0 +1,120 @@
+/*
+ *  linux/arch/arm/mach-a9tc/clock.c
+ *
+ *  Copyright (C) 2004 ARM Limited.
+ *  Written by Deep Blue Solutions Limited.
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include "clock.h"
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	struct clk *p, *clk = ERR_PTR(-ENOENT);
+
+	mutex_lock(&clocks_mutex);
+	list_for_each_entry(p, &clocks, node) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			break;
+		}
+	}
+	mutex_unlock(&clocks_mutex);
+
+	return clk;
+}
+EXPORT_SYMBOL(clk_get);
+
+void clk_put(struct clk *clk)
+{
+	module_put(clk->owner);
+}
+EXPORT_SYMBOL(clk_put);
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return rate;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EIO;
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+/*
+ * These are fixed clocks.
+ */
+static struct clk uart_clk = {
+	.name	= "UARTCLK",
+	.rate	= 7372800,
+};
+
+static struct clk mmci_clk = {
+	.name	= "MCLK",
+	.rate	= 24000000,
+};
+
+static struct clk clcd_clk = {
+	.name	= "CLCDCLK",
+	.rate	= 0,	// dummy
+};
+
+int clk_register(struct clk *clk)
+{
+	mutex_lock(&clocks_mutex);
+	list_add(&clk->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(clk_register);
+
+void clk_unregister(struct clk *clk)
+{
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->node);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clk_unregister);
+
+static int __init clk_init(void)
+{
+	clk_register(&uart_clk);
+	clk_register(&mmci_clk);
+	clk_register(&clcd_clk);
+	return 0;
+}
+arch_initcall(clk_init);
diff --git a/arch/arm/mach-a9tc/clock.h b/arch/arm/mach-a9tc/clock.h
new file mode 100644
index 0000000..f8d1bd0
--- /dev/null
+++ b/arch/arm/mach-a9tc/clock.h
@@ -0,0 +1,25 @@
+/*
+ *  linux/arch/arm/mach-a9tc/clock.h
+ *
+ *  Copyright (C) 2004 ARM Limited.
+ *  Written by Deep Blue Solutions Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_CLOCK_H
+#define __ASM_ARCH_CLOCK_H
+struct module;
+
+struct clk {
+	struct list_head	node;
+	unsigned long		rate;
+	struct module		*owner;
+	const char		*name;
+	void			*data;
+};
+
+int clk_register(struct clk *clk);
+void clk_unregister(struct clk *clk);
+#endif
diff --git a/arch/arm/mach-a9tc/codec.c b/arch/arm/mach-a9tc/codec.c
new file mode 100644
index 0000000..dbb220d
--- /dev/null
+++ b/arch/arm/mach-a9tc/codec.c
@@ -0,0 +1,267 @@
+/*
+ *  File Name       : linux/arch/arm/mach-a9tc/codec.c
+ *  Function        : codec driver
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/07/01
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it under the terms of
+ *  the GNU General Public License as published by Free Softwere Foundation; either version 2
+ *  of License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+
+
+/* A9TC_FPGA_MISC_F register bit*/
+#define CODEC_RESET	(1 << 31)
+
+/* A9TC_FPGA_CODEC register bit*/
+#define CODEC_EXEC	(1 << 23)
+#define CODEC_BUSY	(1 << 22)
+#define CODEC_DONE	(1 << 21)
+#define CODEC_ERR	(1 << 20)
+#define CODEC_MODE(x)	(((x) & 0x7) << 16)
+#define CODEC_WD(x)	(((x) & 0xff) << 8)
+#define CODEC_RD(x)	((x) & 0xff)
+
+/* I2C MODE list */
+#define I2C_MODE_SWI  0x0	/* 000 = START + WD(Address+RW) + ACI_IN        */
+#define I2C_MODE_SWIP 0x1	/* 001 = START + WD(Address+RW) + ACK_IN + STOP */
+#define I2C_MODE_WI   0x2	/* 010 = WD + ACK_IN                            */
+#define I2C_MODE_WIP  0x3	/* 011 = WD + ACK_IN   + STOP                   */
+#define I2C_MODE_RO   0x4	/* 100 = RD + ACK_OUT                           */
+#define I2C_MODE_ROP  0x5	/* 101 = RD + ACK_OUT  + STOP                   */
+#define I2C_MODE_NOP  0x6	/* 110 = NOP (Not used)                         */
+#define I2C_MODE_RNOP 0x7	/* 111 = RD + NACK_OUT + STOP                   */
+
+/* A9TC_FPGA_PLAY_C register bit*/
+#define CODEC_PLAY	(1 << 3)
+#define CODEC_PLAY_RUN	(1 << 2)
+#define CODEC_DI_EMPTY	(1 << 1)
+#define CODEC_DI_FULL	(1 << 0)
+
+/* I2C Address + Write/Read operation */
+#define CODEC_I2C_W 0x94	/* 10010100 = 100101 + AD0(0) + Write operation */
+#define CODEC_I2C_R 0x95	/* 10010101 = 100101 + AD0(0) + Read operation  */
+
+/* Power Control 1 Register (0x02) P.49       */
+#define I2C_CODEC_PHONE_OUT 0x1E
+#define I2C_CODEC_LINE_OUT  0x1E
+#define I2C_CODEC_MIC_IN    0x74
+#define I2C_CODEC_LINE_IN   0x78
+
+
+static void codec_reset(int en)
+{
+	unsigned int val;
+
+	val = readl(A9TC_FPGA_MISC_F);
+	if (en) {
+		val &= ~CODEC_RESET;
+	} else {
+		val |= CODEC_RESET;
+	}
+	writel(val, A9TC_FPGA_MISC_F);
+}
+
+static int codec_i2c(unsigned char mode, unsigned char wd, unsigned char *rd)
+{
+	int ret = 0;
+	unsigned int val;
+
+	while (readl(A9TC_FPGA_CODEC) & CODEC_BUSY);
+
+	val = CODEC_MODE(mode) | CODEC_WD(wd);
+	writel(val, A9TC_FPGA_CODEC);
+	val |= CODEC_EXEC;
+	writel(val, A9TC_FPGA_CODEC);
+
+	while ((readl(A9TC_FPGA_CODEC) & CODEC_DONE) == 0);
+
+	val = readl(A9TC_FPGA_CODEC);
+	if (val & CODEC_ERR) {
+		ret = 1;
+	}
+
+	if (rd) {
+		*rd = CODEC_RD(val);
+	}
+
+	val &= ~CODEC_EXEC;
+	writel(val, A9TC_FPGA_CODEC);
+
+	return ret;
+}
+
+static int codec_read(unsigned char addr, unsigned char *data)
+{
+	int ret;
+
+	ret = codec_i2c(I2C_MODE_SWI, CODEC_I2C_W, NULL);
+	if (ret) {
+		printk("%s: CHIP ADDRESS err. addr=0x%x\n", __FUNCTION__, addr);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_WIP, addr, NULL);
+	if (ret) {
+		printk("%s: MAP BYTE err. addr=0x%x\n", __FUNCTION__, addr);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_SWI, CODEC_I2C_R, NULL);
+	if (ret) {
+		printk("%s: CHIP ADDRESS2 err. addr=0x%x\n", __FUNCTION__, addr);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_ROP, 0x00, data);
+	if (ret) {
+		printk("%s: REGISTER WRITE err. addr=0x%x\n", __FUNCTION__, addr);
+		data = 0;
+		return ret;
+	}
+	return ret;
+}
+
+
+static int codec_write(unsigned char addr, unsigned char data)
+{
+	int ret;
+
+	ret = codec_i2c(I2C_MODE_SWI, CODEC_I2C_W, NULL);
+	if (ret) {
+		printk("%s: CHIP ADDRESS err. addr=0x%x data=%x\n", __FUNCTION__, addr, data);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_WI, addr, NULL);
+	if (ret) {
+		printk("%s: MAP BYTE err. addr=0x%x data=%x\n", __FUNCTION__, addr, data);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_WIP, data, NULL);
+	if (ret) {
+		printk("%s: REGISTER WRITE err. addr=0x%x data=%x\n", __FUNCTION__, addr, data);
+		return ret;
+	}
+	return ret;
+}
+
+static int codec_up(unsigned char pd)
+{
+	return codec_write(0x02, pd);
+}
+
+static int codec_down(void)
+{
+	return codec_write(0x02, 0x01);
+}
+
+int codec_init(void)
+{
+	int ret;
+	unsigned char data;
+
+	ret = codec_down();
+	if (ret) {
+		printk("codec_down() err\n");
+		return ret;
+	}
+
+	// Speed & MIC power
+	codec_write(0x03, 0x08);
+//	codec_write(0x03, 0x68);
+	// Interface control
+	codec_write(0x04, 0x4C);
+
+	codec_read(0x01, &data);
+	printk("codec id = 0x%x\n", data);
+
+	return ret;
+}
+
+int a9tc_codec_init(void)
+{
+	codec_reset(0);
+	codec_init();
+	codec_up(I2C_CODEC_PHONE_OUT);
+
+	codec_write(0x08, 0x60);
+
+#if 0
+	codec_write(0x09, 0x40);
+	codec_write(0x10, 0x00);
+	codec_write(0x11, 0x00);
+#endif
+
+	return 0;
+}
+
+void a9tc_codec_deinit(void)
+{
+	codec_down();
+	codec_reset(1);
+}
+
+#define MAX_LOOP_COUNT	256
+int a9tc_codec_data_write(unsigned int *buf, int count)
+{
+	int loop_count, i;
+	int val1, val2;
+
+	if (count > MAX_LOOP_COUNT) {
+		loop_count = MAX_LOOP_COUNT;
+	} else {
+		loop_count = count;
+	}
+
+	for (i = 0; i < loop_count; i++) {
+#if 0
+		val1 = ((*buf & 0xffff) * 24) /16;
+		val2 = (((*buf >> 16) & 0xffff) * 24) /16;
+#else
+		val1 = (*buf & 0xffff);
+		val2 = ((*buf >> 16) & 0xffff);
+#endif
+		writel(val1, A9TC_FPGA_PLAY_D);
+		writel(val2, A9TC_FPGA_PLAY_D);
+		buf++;
+	}
+
+	return loop_count;
+}
+
+int a9tc_codec_out_start(int start)
+{
+	if (start) {
+		writel(CODEC_PLAY, A9TC_FPGA_PLAY_C);
+	} else {
+		writel(0, A9TC_FPGA_PLAY_C);
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(a9tc_codec_init);
+EXPORT_SYMBOL(a9tc_codec_deinit);
+EXPORT_SYMBOL(a9tc_codec_data_write);
+EXPORT_SYMBOL(a9tc_codec_out_start);
diff --git a/arch/arm/mach-a9tc/codec.h b/arch/arm/mach-a9tc/codec.h
new file mode 100644
index 0000000..6cb81dc
--- /dev/null
+++ b/arch/arm/mach-a9tc/codec.h
@@ -0,0 +1,38 @@
+/*
+ *  File Name       : linux/arch/arm/mach-a9tc/codec.h
+ *  Function        : codec header
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/07/01
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it under the terms of
+ *  the GNU General Public License as published by Free Softwere Foundation; either version 2
+ *  of License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARCH_CODEC_H
+#define __ASM_ARCH_CODEC_H
+
+#include <linux/io.h>
+
+extern int a9tc_codec_init(void);
+extern void a9tc_codec_deinit(void);
+extern int a9tc_codec_data_write(unsigned int *buf, int count);
+extern int a9tc_codec_out_start(int start);
+
+
+
+
+
+#endif
diff --git a/arch/arm/mach-a9tc/core.c b/arch/arm/mach-a9tc/core.c
new file mode 100644
index 0000000..f432cf7
--- /dev/null
+++ b/arch/arm/mach-a9tc/core.c
@@ -0,0 +1,214 @@
+
+/*
+ *  linux/arch/arm/mach-a9tc/core.c
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/io.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include <asm/hardware/arm_timer.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+
+#include "core.h"
+
+/* used by entry-macro.S and platsmp.c */
+void __iomem *gic_cpu_base_addr;
+
+
+/*
+ * Where is the timer (VA)?
+ */
+void __iomem *timer0_va_base;
+void __iomem *timer1_va_base;
+
+/*
+ * How long is the timer interval?
+ */
+#define	TIMER_PCLK	(80000000)	/* 80.000 MHz */
+#define TIMER_INTERVAL	(TIMER_PCLK / 100)	/* ticks per 10 msec */
+#define TIMER_RELOAD	(TIMER_INTERVAL)
+#define TIMER_DIVISOR	(TIMER_CTRL_DIV1)
+#define TICKS2USECS(x)	((x) / TICKS_PER_uSEC)
+
+static void timer_set_mode(enum clock_event_mode mode,
+			   struct clock_event_device *clk)
+{
+	unsigned long ctrl;
+
+	switch(mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		writel(TIMER_RELOAD, timer0_va_base + TIMER_LOAD);
+
+		ctrl = TIMER_CTRL_PERIODIC;
+		ctrl |= TIMER_CTRL_32BIT | TIMER_CTRL_IE | TIMER_CTRL_ENABLE;
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* period set, and timer enabled in 'next_event' hook */
+		ctrl = TIMER_CTRL_ONESHOT;
+		ctrl |= TIMER_CTRL_32BIT | TIMER_CTRL_IE;
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	default:
+		ctrl = 0;
+	}
+
+	writel(ctrl, timer0_va_base + TIMER_CTRL);
+}
+
+static int timer_set_next_event(unsigned long evt,
+				struct clock_event_device *unused)
+{
+	unsigned long ctrl = readl(timer0_va_base + TIMER_CTRL);
+
+	writel(evt, timer0_va_base + TIMER_LOAD);
+	writel(ctrl | TIMER_CTRL_ENABLE, timer0_va_base + TIMER_CTRL);
+
+	return 0;
+}
+
+static struct clock_event_device timer0_clockevent =	 {
+	.name		= "timer0",
+	.shift		= 32,
+	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode	= timer_set_mode,
+	.set_next_event	= timer_set_next_event,
+	.rating		= 300,
+	.cpumask	= CPU_MASK_ALL,
+};
+
+static void __init a9tc_clockevents_init(unsigned int timer_irq)
+{
+	timer0_clockevent.irq = timer_irq;
+	timer0_clockevent.mult =
+		div_sc(TIMER_PCLK, NSEC_PER_SEC, timer0_clockevent.shift);
+	timer0_clockevent.max_delta_ns =
+		clockevent_delta2ns(0xffffffff, &timer0_clockevent);
+	timer0_clockevent.min_delta_ns =
+		clockevent_delta2ns(0xf, &timer0_clockevent);
+
+	clockevents_register_device(&timer0_clockevent);
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t a9tc_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &timer0_clockevent;
+
+	/* clear the interrupt */
+	writel(1, timer0_va_base + TIMER_INTCLR);
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction a9tc_timer_irq = {
+	.name		= "timer0",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= a9tc_timer_interrupt,
+};
+
+static cycle_t a9tc_get_cycles(void)
+{
+	return ~readl(timer1_va_base + TIMER_VALUE);
+}
+
+static struct clocksource clocksource_a9tc = {
+	.name	= "timer1",
+	.rating	= 200,
+	.read	= a9tc_get_cycles,
+	.mask	= CLOCKSOURCE_MASK(32),
+	.shift	= 20,
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void __init a9tc_clocksource_init(void)
+{
+	/* setup timer 0 as free-running clocksource */
+	writel(0, timer1_va_base + TIMER_CTRL);
+	writel(0xffffffff, timer1_va_base + TIMER_LOAD);
+	writel(0xffffffff, timer1_va_base + TIMER_VALUE);
+	writel(TIMER_CTRL_32BIT | TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC,
+		timer1_va_base + TIMER_CTRL);
+
+	clocksource_a9tc.mult =
+		clocksource_khz2mult(TIMER_PCLK / 1000, clocksource_a9tc.shift);
+	clocksource_register(&clocksource_a9tc);
+}
+
+/*
+ * Set up the clock source and clock events devices
+ */
+static void __init a9tc_timer_init(void)
+{
+
+	timer0_va_base = __io_address(A9TC_TIMER0_BASE);
+	timer1_va_base = __io_address(A9TC_TIMER1_BASE);
+#ifdef CONFIG_LOCAL_TIMERS
+	twd_base = __io_address(A9TC_TWD_BASE);
+#endif
+
+#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
+	/*
+	 * The dummy clock device has to be registered before the main device
+	 * so that the latter will broadcast the clock events
+	 */
+	local_timer_setup();
+#endif
+
+
+	/* 
+	 * set clock frequency: 
+	 */
+
+	/*
+	 * Initialise to a known state (all timers off)
+	 */
+	writel(0, timer0_va_base + TIMER_CTRL);
+	writel(0, timer1_va_base + TIMER_CTRL);
+
+	/* 
+	 * Make irqs happen for the system timer
+	 */
+	setup_irq(IRQ_TIMER0, &a9tc_timer_irq);
+
+	a9tc_clocksource_init();
+	a9tc_clockevents_init(IRQ_TIMER0);
+}
+
+struct sys_timer a9tc_timer = {
+	.init	= a9tc_timer_init,
+};
+
diff --git a/arch/arm/mach-a9tc/core.h b/arch/arm/mach-a9tc/core.h
new file mode 100644
index 0000000..e21801f
--- /dev/null
+++ b/arch/arm/mach-a9tc/core.h
@@ -0,0 +1,57 @@
+/*
+ *  linux/arch/arm/mach-a9tc/core.h
+ *
+ *  Copyright (C) 2004 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_CORE_H
+#define __ASM_ARCH_CORE_H
+
+#include <linux/amba/bus.h>
+#include <linux/io.h>
+
+#include <asm/leds.h>
+
+#define AMBA_DEVICE(name,busid,base,plat)			\
+static struct amba_device name##_device = {			\
+	.dev		= {					\
+		.coherent_dma_mask = ~0,			\
+		.bus_id	= busid,				\
+		.platform_data = plat,				\
+	},							\
+	.res		= {					\
+		.start	= A9TC_##base##_BASE,		\
+		.end	= (A9TC_##base##_BASE) + SZ_4K - 1,	\
+		.flags	= IORESOURCE_MEM,			\
+	},							\
+	.dma_mask	= ~0,					\
+	.irq		= base##_IRQ,				\
+	/* .dma		= base##_DMA,*/				\
+}
+
+extern void __iomem *gic_cpu_base_addr;
+#ifdef CONFIG_LOCAL_TIMERS
+extern void __iomem *twd_base;
+#endif
+extern void __iomem *timer0_va_base;
+extern void __iomem *timer1_va_base;
+
+extern struct sys_timer a9tc_timer;
+
+#endif
diff --git a/arch/arm/mach-a9tc/headsmp.S b/arch/arm/mach-a9tc/headsmp.S
new file mode 100644
index 0000000..da15f88
--- /dev/null
+++ b/arch/arm/mach-a9tc/headsmp.S
@@ -0,0 +1,39 @@
+/*
+ *  linux/arch/arm/mach-a9tc/headsmp.S
+ *
+ *  Copyright (c) 2003 ARM Limited
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+	__INIT
+
+/*
+ * A9TC specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(a9tc_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+
+1:	.long	.
+	.long	pen_release
diff --git a/arch/arm/mach-a9tc/hotplug.c b/arch/arm/mach-a9tc/hotplug.c
new file mode 100644
index 0000000..dd61b0f
--- /dev/null
+++ b/arch/arm/mach-a9tc/hotplug.c
@@ -0,0 +1,141 @@
+/*
+ *  linux/arch/arm/mach-a9tc/hotplug.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/completion.h>
+
+#include <asm/cacheflush.h>
+
+extern volatile int pen_release;
+
+static DECLARE_COMPLETION(cpu_killed);
+
+static inline void cpu_enter_lowpower(void)
+{
+	unsigned int v;
+
+	flush_cache_all();
+	asm volatile(
+	"	mcr	p15, 0, %1, c7, c5, 0\n"
+	"	mcr	p15, 0, %1, c7, c10, 4\n"
+	/*
+	 * Turn off coherency
+	 */
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	bic	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	"	mrc	p15, 0, %0, c1, c0, 0\n"
+	"	bic	%0, %0, #0x04\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	  : "=&r" (v)
+	  : "r" (0)
+	  : "cc");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile(	"mrc	p15, 0, %0, c1, c0, 0\n"
+	"	orr	%0, %0, #0x04\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	orr	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	  : "=&r" (v)
+	  :
+	  : "cc");
+}
+
+static inline void platform_do_lowpower(unsigned int cpu)
+{
+	/*
+	 * there is no power-control hardware on this platform, so all
+	 * we can do is put the core into WFI; this is safe as the calling
+	 * code will have already disabled interrupts
+	 */
+	for (;;) {
+		/*
+		 * here's the WFI
+		 */
+		asm(".word	0xe320f003\n"
+		    :
+		    :
+		    : "memory", "cc");
+
+		if (pen_release == cpu) {
+			/*
+			 * OK, proper wakeup, we're done
+			 */
+			break;
+		}
+
+		/*
+		 * getting here, means that we have come out of WFI without
+		 * having been woken up - this shouldn't happen
+		 *
+		 * The trouble is, letting people know about this is not really
+		 * possible, since we are currently running incoherently, and
+		 * therefore cannot safely call printk() or anything else
+		 */
+#ifdef DEBUG
+		printk("CPU%u: spurious wakeup call\n", cpu);
+#endif
+	}
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+	return wait_for_completion_timeout(&cpu_killed, 5000);
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void platform_cpu_die(unsigned int cpu)
+{
+#ifdef DEBUG
+	unsigned int this_cpu = hard_smp_processor_id();
+
+	if (cpu != this_cpu) {
+		printk(KERN_CRIT "Eek! platform_cpu_die running on %u, should be %u\n",
+			   this_cpu, cpu);
+		BUG();
+	}
+#endif
+
+	printk(KERN_NOTICE "CPU%u: shutdown\n", cpu);
+	complete(&cpu_killed);
+
+	/*
+	 * we're ready for shutdown now, so do it
+	 */
+	cpu_enter_lowpower();
+	platform_do_lowpower(cpu);
+
+	/*
+	 * bring this CPU back into the world of cache
+	 * coherency, and then restore interrupts
+	 */
+	cpu_leave_lowpower();
+}
+
+int mach_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-a9tc/include/Kconfig b/arch/arm/mach-a9tc/include/Kconfig
new file mode 100644
index 0000000..cdf2e2e
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/Kconfig
@@ -0,0 +1,20 @@
+menu "A9TC platform type"
+	depends on ARCH_A9TC
+
+config A9TC_ANDROID
+	bool "Use Android setting"
+
+config A9TC_AUDIO
+	bool "Use Audio driver"
+
+config A9TC_L310
+	bool "ARM L2 cache Enable"
+	default y
+	select CACHE_L2X0
+
+config A9TC_L310_WT
+	bool "ARM L2 cache WriteThrough"
+	depends on A9TC_L310
+	default n
+
+endmenu
diff --git a/arch/arm/mach-a9tc/include/Makefile b/arch/arm/mach-a9tc/include/Makefile
new file mode 100644
index 0000000..0225b6b
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y					:= core.o clock.o board.o
+obj-$(CONFIG_SMP)		+= platsmp.o headsmp.o localtimer.o
+obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
+
+obj-$(CONFIG_A9TC_AUDIO) += codec.o audio.o
+
diff --git a/arch/arm/mach-a9tc/include/Makefile.boot b/arch/arm/mach-a9tc/include/Makefile.boot
new file mode 100644
index 0000000..07c2d9c
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x60008000
+params_phys-y	:= 0x60000100
+initrd_phys-y	:= 0x60800000
diff --git a/arch/arm/mach-a9tc/include/audio.c b/arch/arm/mach-a9tc/include/audio.c
new file mode 100644
index 0000000..da1c940
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/audio.c
@@ -0,0 +1,396 @@
+/*
+ *  File Name       : linux/arch/arm/mach-a9tc/audio.c
+ *  Function        : Audio driver
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/07/01
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it under the terms of
+ *  the GNU General Public License as published by Free Softwere Foundation; either version 2
+ *  of License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/platform_device.h>
+
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include "codec.h"
+
+#define MAX_BUF_NUM	8
+
+#define READ_BUFFER_SIZE        16384
+#define WRITE_BUFFER_SIZE       16384
+
+struct a9tc_audio {
+	int in_irq;
+	int out_irq;
+
+	spinlock_t lock;
+	wait_queue_head_t wait;
+	int buffer_status;
+
+	unsigned int *write_buffer;    /* write buffer virtual address */
+	unsigned int *read_buffer;      /* read buffer virtual address */
+	int count;
+
+	int codec_status;
+
+	int read_supported;         /* true if we have audio input support */
+};
+
+/* temporary variable used between a9tc_audio_probe() and a9tc_audio_open() */
+static struct a9tc_audio* audio_data;
+
+static atomic_t open_count = ATOMIC_INIT(0);
+
+static ssize_t a9tc_audio_read(struct file *fp, char __user *buf,
+							size_t count, loff_t *pos)
+{
+	struct a9tc_audio* data = fp->private_data;
+	int result = 0;
+
+	if (!data->read_supported)
+		return -ENODEV;
+
+	return result;
+}
+
+static ssize_t a9tc_audio_write(struct file *fp, const char __user *buf, size_t count, loff_t *pos)
+{
+	struct a9tc_audio* data = fp->private_data;
+
+//printk("count=%d\n", count);
+
+	data->count = count / 4;
+	data->buffer_status = 0;
+
+	if (copy_from_user(data->write_buffer, buf, count)) {
+		printk("copy_from_user failed!\n");
+		kfree(data->write_buffer);
+		return -EFAULT;
+	}
+
+#if 1
+	if (data->codec_status != 1) {
+		a9tc_codec_out_start(1);
+		data->codec_status = 1;
+	}
+
+	enable_irq(data->out_irq);
+
+	wait_event_interruptible(data->wait, data->buffer_status != 0);
+#else
+{
+#if 1
+	int i;
+	unsigned int *buf2 = data->write_buffer;
+	unsigned int val1, val2;
+
+
+	if (data->codec_status != 1) {
+		a9tc_codec_out_start(1);
+		data->codec_status = 1;
+	}
+
+	for (i = 0; i < data->count; i++) {
+		val1 = ((*buf2 & 0xffff) * 24) / 16;
+		val2 = (((*buf2 >> 16) & 0xffff) * 24) / 16;
+		writel(val1, A9TC_FPGA_PLAY_D);
+		writel(val2, A9TC_FPGA_PLAY_D);
+		buf++;
+		while ((readl(A9TC_FPGA_PLAY_C) & 0x2) == 0);
+	}
+#else
+	unsigned int f, i, j, k, c, p;
+	unsigned int l_ch = 0x00100000, r_ch = 0x00100000;
+
+	if (data->codec_status != 1) {
+		a9tc_codec_out_start(1);
+		data->codec_status = 1;
+
+	k = 0x6D;	/* 218 / 2 */
+	c = k;
+	f = 0;
+
+	i = l_ch;
+	j = r_ch;
+
+	for (p = 0; p <= 96000; p++) {
+		while ((readl(A9TC_FPGA_PLAY_C) & 0x2) == 0);
+
+		writel(i, A9TC_FPGA_PLAY_D);
+		writel(j, A9TC_FPGA_PLAY_D);
+		if ( c == 0 ) {
+			c = k;
+			if ( f == 0 ) {
+				f = 1;
+				i = 0x0;
+				j = 0x0;
+			} else {
+				f = 0;
+				i = l_ch;
+				j = r_ch;
+			}
+		} else {
+			c--;
+		}
+	}
+	}
+#endif
+}
+#endif
+
+	return count;
+}
+
+
+static irqreturn_t a9tc_audio_out_interrupt(int irq, void *dev_id)
+{
+	struct a9tc_audio *data = dev_id;
+	int count;
+
+	if ((readl(A9TC_FPGA_PLAY_C) & 0x02) == 0) {
+		return IRQ_HANDLED;
+	}
+//printk("%s: c=%d %x\n", __FUNCTION__, data->count, readl(A9TC_FPGA_PLAY_C));
+
+	count = a9tc_codec_data_write(data->write_buffer, data->count);
+	if (count > 0) {
+		data->count -= count;
+	}
+
+	if (data->count <= 0) {
+		disable_irq_nosync(data->out_irq);
+		data->buffer_status = 1;
+		wake_up(&data->wait);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int a9tc_audio_open(struct inode *ip, struct file *fp)
+{
+	struct a9tc_audio *data = audio_data;
+
+	if (!data)
+		return -ENODEV;
+
+	if (atomic_inc_return(&open_count) == 1) {
+		fp->private_data = data;
+
+
+//		a9tc_path_mute(DMA_CH_OUT, 0);
+//		a9tc_path_audio_rate(44100);
+
+		return 0;
+	} else {
+		atomic_dec(&open_count);
+		return -EBUSY;
+	}
+}
+
+static int a9tc_audio_release(struct inode *ip, struct file* fp)
+{
+	struct a9tc_audio* data = fp->private_data;
+
+#if 0
+	if (data->count > 0) {
+		disable_irq(data->out_irq);
+	}
+#endif
+
+	if (data->codec_status == 1) {
+		a9tc_codec_out_start(0);
+		data->codec_status = 0;
+	}
+
+	atomic_dec(&open_count);
+
+	return 0;
+}
+
+
+static int a9tc_audio_ioctl(struct inode* ip, struct file* fp, unsigned int cmd, unsigned long arg)
+{
+	int __user *p = (int __user *)arg;
+	int res;
+
+//printk("%s: cmd=%x\n", __FUNCTION__, cmd);
+
+	switch (cmd) {
+	case SNDCTL_DSP_RESET:
+		return 0;
+	case SNDCTL_DSP_SYNC:
+		return 0;
+
+	case SNDCTL_DSP_SPEED:
+		if (get_user(res, p))
+			return -EFAULT;
+printk("%s: speed = %d", __FUNCTION__, res);
+//		a9tc_path_audio_rate(res);
+		return 0;
+	case SNDCTL_DSP_STEREO:
+		if (get_user(res, p))
+			return -EFAULT;
+		res = res > 0 ? 2 : 1;
+printk("%s: stereo = %d", __FUNCTION__, res);
+		return 0;
+	case SNDCTL_DSP_GETBLKSIZE:
+		res = 64*1024;
+		return put_user(res, p);
+	case SNDCTL_DSP_SAMPLESIZE:
+		if (get_user(res, p))
+			return -EFAULT;
+		return 0;
+
+	/* temporary workaround, until we switch to the ALSA API */
+	case 315:
+		return -1;
+	default:
+		printk("%s: unsuppport cmd=0x%x\n", __FUNCTION__, cmd);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* file operations for /dev/eac */
+static struct file_operations a9tc_audio_fops = {
+	.owner	= THIS_MODULE,
+	.read	= a9tc_audio_read,
+	.write	= a9tc_audio_write,
+	.open	= a9tc_audio_open,
+	.release	= a9tc_audio_release,
+	.ioctl	= a9tc_audio_ioctl,
+};
+
+static struct miscdevice a9tc_audio_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "eac",
+	.fops = &a9tc_audio_fops,
+};
+
+static int a9tc_audio_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct a9tc_audio *data;
+	unsigned long flag;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if(data == NULL) {
+		ret = -ENOMEM;
+		goto err_data_alloc_failed;
+	}
+
+	data->write_buffer = kmalloc(64*1024, GFP_KERNEL);
+	if (data->write_buffer == NULL) {
+		printk("%s: kmalloc failed\n", __FUNCTION__);
+		ret = -ENOMEM;
+		goto err_buffer_alloc;
+	}
+
+	spin_lock_init(&data->lock);
+	init_waitqueue_head(&data->wait);
+	platform_set_drvdata(pdev, data);
+
+
+	spin_lock_irqsave(&data->lock, flag);
+	data->out_irq = IRQ_I2S_DI_EMPTY;
+	ret = request_irq(data->out_irq, a9tc_audio_out_interrupt, IRQF_DISABLED, "I2S_OUT", data);
+	if (ret) {
+		goto err_request_irq;
+	}
+	disable_irq(data->out_irq);
+	spin_unlock_irqrestore(&data->lock, flag);
+
+	if((ret = misc_register(&a9tc_audio_device))) {
+		printk("misc_register returned %d in a9tc_audio_init\n", ret);
+		goto err_misc_register_failed;
+	}
+
+	data->read_supported = 0;
+	data->buffer_status = 0;
+
+	a9tc_codec_init();
+
+	audio_data = data;
+	return 0;
+
+err_misc_register_failed:
+	free_irq(data->out_irq, data);
+err_request_irq:
+	kfree(data->write_buffer);
+err_buffer_alloc:
+	kfree(data);
+err_data_alloc_failed:
+	return ret;
+}
+
+static int a9tc_audio_remove(struct platform_device *pdev)
+{
+	struct a9tc_audio *data = platform_get_drvdata(pdev);
+
+	misc_deregister(&a9tc_audio_device);
+
+	free_irq(data->out_irq, data);
+	kfree(data);
+
+	audio_data = NULL;
+
+	return 0;
+}
+
+static struct platform_driver a9tc_audio_driver = {
+	.probe		= a9tc_audio_probe,
+	.remove		= a9tc_audio_remove,
+	.driver = {
+		.name = "a9tc_audio"
+	}
+};
+
+static int __init a9tc_audio_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&a9tc_audio_driver);
+	if (ret < 0) {
+		printk("platform_driver_register returned %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit a9tc_audio_exit(void)
+{
+	platform_driver_unregister(&a9tc_audio_driver);
+}
+
+module_init(a9tc_audio_init);
+module_exit(a9tc_audio_exit);
+
+MODULE_DESCRIPTION("MP200 Audio Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
diff --git a/arch/arm/mach-a9tc/include/board.c b/arch/arm/mach-a9tc/include/board.c
new file mode 100644
index 0000000..e7b5b8e
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/board.c
@@ -0,0 +1,390 @@
+/*
+ *  linux/arch/arm/mach-a9tc/board.c
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/sysdev.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/cache-l2x0.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <mach/irqs.h>
+
+#include "core.h"
+
+static struct map_desc a9tc_io_desc[] __initdata = {
+	{
+		.virtual	= IO_ADDRESS(A9TC_INTERNAL_IO_BASE),
+		.pfn		= __phys_to_pfn(A9TC_INTERNAL_IO_BASE),
+		.length		= SZ_4M,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= IO_ADDRESS(A9TC_SCU_BASE),
+		.pfn		= __phys_to_pfn(A9TC_SCU_BASE),
+		.length		= SZ_64K,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= IO_ADDRESS(A9TC_FPGA_BASE),
+		.pfn		= __phys_to_pfn(A9TC_FPGA_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	},
+};
+
+static void __init a9tc_map_io(void)
+{
+	iotable_init(a9tc_io_desc, ARRAY_SIZE(a9tc_io_desc));
+}
+
+/*
+ * AMBA devices
+ */
+/* CLCD support. */
+static struct clcd_panel a9tc_panel = {
+	.mode		= {
+		.name		= "800x480",
+		.refresh	= 60,
+		.xres		= 800,
+		.yres		= 480,
+		.pixclock	= 42000,
+		.left_margin	= 4,	// HBP
+		.right_margin	= 6,	// HFP
+		.upper_margin	= 6,	// VBP
+		.lower_margin	= 3,	// VFP
+		.hsync_len	= 1,
+		.vsync_len	= 1,
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+	.width		= -1,
+	.height		= -1,
+	.tim2		= TIM2_BCD | TIM2_IPC | TIM2_IOE,
+	.cntl		= CNTL_LCDTFT | CNTL_LCDVCOMP(1) | CNTL_BGR,
+	.bpp		= 16,
+};
+
+#define FPGA_LCD_FLON	(1 << 9)
+static void a9tc_clcd_disable(struct clcd_fb *fb)
+{
+	unsigned int val;
+
+	val = readl(A9TC_FPGA_LCD_KEY);
+	val &= ~FPGA_LCD_FLON;
+	writel(val, A9TC_FPGA_LCD_KEY);
+}
+static void a9tc_clcd_enable(struct clcd_fb *fb)
+{
+	unsigned int val;
+
+	val = readl(A9TC_FPGA_LCD_KEY);
+	val |= FPGA_LCD_FLON;
+	writel(val, A9TC_FPGA_LCD_KEY);
+}
+static int a9tc_clcd_setup(struct clcd_fb *fb)
+{
+	unsigned long framesize;
+	dma_addr_t dma;
+
+	framesize = a9tc_panel.mode.xres * a9tc_panel.mode.yres * 2 * 2;
+
+	fb->panel = &a9tc_panel;
+
+	fb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev, framesize,
+						    &dma, GFP_KERNEL | GFP_DMA);
+	if (!fb->fb.screen_base) {
+		printk(KERN_ERR "CLCD: unable to map framebuffer\n");
+		return -ENOMEM;
+	}
+
+	fb->fb.fix.smem_start	= dma;
+	fb->fb.fix.smem_len	= framesize;
+
+	return 0;
+}
+static int a9tc_clcdfb_check(struct clcd_fb *fb, struct fb_var_screeninfo *var)
+{
+	var->nonstd = 0;
+	var->accel_flags = 0;
+
+	return 0;
+}
+static int a9tc_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
+{
+	return dma_mmap_writecombine(&fb->dev->dev, vma,
+				     fb->fb.screen_base,
+				     fb->fb.fix.smem_start,
+				     fb->fb.fix.smem_len);
+}
+
+static void a9tc_clcd_remove(struct clcd_fb *fb)
+{
+	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
+			      fb->fb.screen_base, fb->fb.fix.smem_start);
+}
+
+struct clcd_board clcd_plat_data = {
+	.name		= "a9tc",
+	.check		= a9tc_clcdfb_check,
+	.decode		= clcdfb_decode,
+	.disable	= a9tc_clcd_disable,
+	.enable		= a9tc_clcd_enable,
+	.setup		= a9tc_clcd_setup,
+	.mmap		= a9tc_clcd_mmap,
+	.remove		= a9tc_clcd_remove,
+};
+
+/*
+ * These devices are connected directly to the multi-layer AHB switch
+ */
+#define CLCD_IRQ	{ IRQ_CLCD, NO_IRQ }
+#define CLCD_DMA	{ 0, 0 }
+
+/*
+ * These devices are connected via the DMA APB bridge
+ */
+#define UART0_IRQ	{ IRQ_UART0, NO_IRQ }
+#define UART0_DMA	{ 0, 0 }
+
+/* DevChip Primecells */
+AMBA_DEVICE(clcd,  "dev:20",  CLCD,  &clcd_plat_data);
+AMBA_DEVICE(uart0, "dev:f1",  UART0, NULL);
+
+static struct amba_device *amba_devs[] __initdata = {
+	&clcd_device,
+	&uart0_device,
+};
+
+
+
+
+/*
+ * A9TC platform devices
+ */
+
+/* ---- LAN9118 NIC ---- */
+static struct resource a9tc_eth_resources[] = {
+	[0] = {
+		.start		= A9TC_ETH_BASE,
+		.end		= A9TC_ETH_BASE + SZ_64K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_ETH,
+		.end		= IRQ_ETH,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+#include <linux/smc911x.h>
+static struct smc911x_platdata a9tc_smc911x_platdata = {
+	.flags		= SMC911X_USE_32BIT,
+	.irq_flags	= IRQF_DISABLED,
+	.irq_polarity	= 0,
+};
+static struct platform_device a9tc_eth_device = {
+	.name	= "smc911x",
+	.id		= 0,
+	.dev  = {
+		.platform_data = &a9tc_smc911x_platdata,
+		},
+	.num_resources	= ARRAY_SIZE(a9tc_eth_resources),
+	.resource	= a9tc_eth_resources,
+};
+
+/* ---- USB ISP1761 ---- */
+static struct resource a9tc_isp1761_resources[] = {
+	[0] = {
+		.start		= A9TC_USB_BASE,
+		.end		= A9TC_USB_BASE + SZ_128K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_USB,
+		.end		= IRQ_USB,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+struct platform_device a9tc_usb_device = {
+	.name			= "isp1760",
+	.num_resources	= ARRAY_SIZE(a9tc_isp1761_resources),
+	.resource	= a9tc_isp1761_resources,
+};
+
+/* ---- RTC RV5C348B ---- */
+static struct resource a9tc_rtc_resources[] = {
+	{
+		.start = IRQ_RTC,
+		.end   = IRQ_RTC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+static struct platform_device a9tc_rtc_device = {
+	.name = "a9tc-rtc",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(a9tc_rtc_resources),
+	.resource = a9tc_rtc_resources,
+};
+
+/* ---- mmc ---- */
+static struct resource a9tc_mmc_resources[] = {
+	[0] = {
+		.start		= A9TC_SDC_BASE,
+		.end		= A9TC_SDC_BASE + SZ_4K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_SD,
+		.end		= IRQ_SD,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+struct platform_device a9tc_mmc_device = {
+	.name			= "a9tc_mmc",
+	.num_resources	= ARRAY_SIZE(a9tc_mmc_resources),
+	.resource	= a9tc_mmc_resources,
+};
+
+/* ---- Keypad ---- */
+static struct platform_device a9tc_key_device = {
+	.name = "a9tc_key",
+	.id = -1,
+};
+
+/* ---- Touch ---- */
+static struct platform_device a9tc_touch_device = {
+	.name = "a9tc_touch",
+	.id = -1,
+};
+
+/* ---- nand ---- */
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+static struct mtd_partition a9tc_nand_partition[] = {
+	{
+	 .name   = "nand device",
+	 .offset = 0,
+	 .size   = SZ_256M
+	 },
+};
+static struct platform_nand_chip a9tc_nand_data = {
+	.nr_chips      = 1,
+	.chip_delay    = 100,
+	.options       = 0,
+	.partitions    = a9tc_nand_partition,
+	.nr_partitions = ARRAY_SIZE(a9tc_nand_partition),
+};
+static struct resource a9tc_nand_resource[] = {
+	[0] = {
+		.start = A9TC_NAND_BASE,
+		.end   = A9TC_NAND_BASE + SZ_16M - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_NMC,
+		.end	= IRQ_NMC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+static struct platform_device a9tc_nand_device = {
+	.name = "a9tc_nand",
+	.id   = -1,
+	.dev  = {
+		.platform_data = &a9tc_nand_data,
+		},
+	.resource = a9tc_nand_resource,
+	.num_resources = ARRAY_SIZE(a9tc_nand_resource),
+};
+
+/* ---- Audio ---- */
+static struct platform_device a9tc_audio_device = {
+	.name = "a9tc_audio",
+	.id = -1,
+};
+
+
+static struct platform_device *devs[] __initdata = {
+	&a9tc_eth_device,
+	&a9tc_usb_device,
+	&a9tc_rtc_device,
+	&a9tc_mmc_device,
+	&a9tc_key_device,
+	&a9tc_touch_device,
+	&a9tc_nand_device,
+	&a9tc_audio_device,
+};
+
+
+static void __init gic_init_irq(void)
+{
+	/* core tile GIC, primary */
+	gic_cpu_base_addr = __io_address(A9TC_GIC_CPU_BASE);
+	gic_dist_init(0, __io_address(A9TC_GIC_DIST_BASE), 29);
+	gic_cpu_init(0, gic_cpu_base_addr);
+}
+
+
+static void __init a9tc_init(void)
+{
+	int i;
+
+	platform_add_devices(devs, ARRAY_SIZE(devs));
+
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+#ifdef CONFIG_A9TC_L310
+	{
+		void __iomem *l2x0_base = __io_address(A9TC_L2CC_BASE);
+#ifdef CONFIG_A9TC_L310_WT
+		/* Force L2 write through */
+		writel(0x2, l2x0_base + L2X0_DEBUG_CTRL);
+#endif
+		writel(0x111, l2x0_base + L2X0_TAG_LATENCY_CTRL);
+		writel(0x111, l2x0_base + L2X0_DATA_LATENCY_CTRL);
+		// 8-way 64KB cache, Shared attribute override enable
+		l2x0_init(l2x0_base, 0x02460000, 0xc0000fff);
+	}
+#endif
+}
+
+MACHINE_START(A9TC, "A9TC")
+	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
+	.phys_io	= A9TC_UART0_BASE,
+	.io_pg_offst	= (IO_ADDRESS(A9TC_UART0_BASE) >> 18) & 0xfffc,
+	.boot_params	= PHYS_OFFSET + 0x00000100,
+	.map_io		= a9tc_map_io,
+	.init_irq	= gic_init_irq,
+	.timer		= &a9tc_timer,
+	.init_machine	= a9tc_init,
+MACHINE_END
diff --git a/arch/arm/mach-a9tc/include/clock.c b/arch/arm/mach-a9tc/include/clock.c
new file mode 100644
index 0000000..f3e2965
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/clock.c
@@ -0,0 +1,120 @@
+/*
+ *  linux/arch/arm/mach-a9tc/clock.c
+ *
+ *  Copyright (C) 2004 ARM Limited.
+ *  Written by Deep Blue Solutions Limited.
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include "clock.h"
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	struct clk *p, *clk = ERR_PTR(-ENOENT);
+
+	mutex_lock(&clocks_mutex);
+	list_for_each_entry(p, &clocks, node) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			break;
+		}
+	}
+	mutex_unlock(&clocks_mutex);
+
+	return clk;
+}
+EXPORT_SYMBOL(clk_get);
+
+void clk_put(struct clk *clk)
+{
+	module_put(clk->owner);
+}
+EXPORT_SYMBOL(clk_put);
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return rate;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EIO;
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+/*
+ * These are fixed clocks.
+ */
+static struct clk uart_clk = {
+	.name	= "UARTCLK",
+	.rate	= 7372800,
+};
+
+static struct clk mmci_clk = {
+	.name	= "MCLK",
+	.rate	= 24000000,
+};
+
+static struct clk clcd_clk = {
+	.name	= "CLCDCLK",
+	.rate	= 0,	// dummy
+};
+
+int clk_register(struct clk *clk)
+{
+	mutex_lock(&clocks_mutex);
+	list_add(&clk->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(clk_register);
+
+void clk_unregister(struct clk *clk)
+{
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->node);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clk_unregister);
+
+static int __init clk_init(void)
+{
+	clk_register(&uart_clk);
+	clk_register(&mmci_clk);
+	clk_register(&clcd_clk);
+	return 0;
+}
+arch_initcall(clk_init);
diff --git a/arch/arm/mach-a9tc/include/clock.h b/arch/arm/mach-a9tc/include/clock.h
new file mode 100644
index 0000000..f8d1bd0
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/clock.h
@@ -0,0 +1,25 @@
+/*
+ *  linux/arch/arm/mach-a9tc/clock.h
+ *
+ *  Copyright (C) 2004 ARM Limited.
+ *  Written by Deep Blue Solutions Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_CLOCK_H
+#define __ASM_ARCH_CLOCK_H
+struct module;
+
+struct clk {
+	struct list_head	node;
+	unsigned long		rate;
+	struct module		*owner;
+	const char		*name;
+	void			*data;
+};
+
+int clk_register(struct clk *clk);
+void clk_unregister(struct clk *clk);
+#endif
diff --git a/arch/arm/mach-a9tc/include/codec.c b/arch/arm/mach-a9tc/include/codec.c
new file mode 100644
index 0000000..dbb220d
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/codec.c
@@ -0,0 +1,267 @@
+/*
+ *  File Name       : linux/arch/arm/mach-a9tc/codec.c
+ *  Function        : codec driver
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/07/01
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it under the terms of
+ *  the GNU General Public License as published by Free Softwere Foundation; either version 2
+ *  of License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+
+
+/* A9TC_FPGA_MISC_F register bit*/
+#define CODEC_RESET	(1 << 31)
+
+/* A9TC_FPGA_CODEC register bit*/
+#define CODEC_EXEC	(1 << 23)
+#define CODEC_BUSY	(1 << 22)
+#define CODEC_DONE	(1 << 21)
+#define CODEC_ERR	(1 << 20)
+#define CODEC_MODE(x)	(((x) & 0x7) << 16)
+#define CODEC_WD(x)	(((x) & 0xff) << 8)
+#define CODEC_RD(x)	((x) & 0xff)
+
+/* I2C MODE list */
+#define I2C_MODE_SWI  0x0	/* 000 = START + WD(Address+RW) + ACI_IN        */
+#define I2C_MODE_SWIP 0x1	/* 001 = START + WD(Address+RW) + ACK_IN + STOP */
+#define I2C_MODE_WI   0x2	/* 010 = WD + ACK_IN                            */
+#define I2C_MODE_WIP  0x3	/* 011 = WD + ACK_IN   + STOP                   */
+#define I2C_MODE_RO   0x4	/* 100 = RD + ACK_OUT                           */
+#define I2C_MODE_ROP  0x5	/* 101 = RD + ACK_OUT  + STOP                   */
+#define I2C_MODE_NOP  0x6	/* 110 = NOP (Not used)                         */
+#define I2C_MODE_RNOP 0x7	/* 111 = RD + NACK_OUT + STOP                   */
+
+/* A9TC_FPGA_PLAY_C register bit*/
+#define CODEC_PLAY	(1 << 3)
+#define CODEC_PLAY_RUN	(1 << 2)
+#define CODEC_DI_EMPTY	(1 << 1)
+#define CODEC_DI_FULL	(1 << 0)
+
+/* I2C Address + Write/Read operation */
+#define CODEC_I2C_W 0x94	/* 10010100 = 100101 + AD0(0) + Write operation */
+#define CODEC_I2C_R 0x95	/* 10010101 = 100101 + AD0(0) + Read operation  */
+
+/* Power Control 1 Register (0x02) P.49       */
+#define I2C_CODEC_PHONE_OUT 0x1E
+#define I2C_CODEC_LINE_OUT  0x1E
+#define I2C_CODEC_MIC_IN    0x74
+#define I2C_CODEC_LINE_IN   0x78
+
+
+static void codec_reset(int en)
+{
+	unsigned int val;
+
+	val = readl(A9TC_FPGA_MISC_F);
+	if (en) {
+		val &= ~CODEC_RESET;
+	} else {
+		val |= CODEC_RESET;
+	}
+	writel(val, A9TC_FPGA_MISC_F);
+}
+
+static int codec_i2c(unsigned char mode, unsigned char wd, unsigned char *rd)
+{
+	int ret = 0;
+	unsigned int val;
+
+	while (readl(A9TC_FPGA_CODEC) & CODEC_BUSY);
+
+	val = CODEC_MODE(mode) | CODEC_WD(wd);
+	writel(val, A9TC_FPGA_CODEC);
+	val |= CODEC_EXEC;
+	writel(val, A9TC_FPGA_CODEC);
+
+	while ((readl(A9TC_FPGA_CODEC) & CODEC_DONE) == 0);
+
+	val = readl(A9TC_FPGA_CODEC);
+	if (val & CODEC_ERR) {
+		ret = 1;
+	}
+
+	if (rd) {
+		*rd = CODEC_RD(val);
+	}
+
+	val &= ~CODEC_EXEC;
+	writel(val, A9TC_FPGA_CODEC);
+
+	return ret;
+}
+
+static int codec_read(unsigned char addr, unsigned char *data)
+{
+	int ret;
+
+	ret = codec_i2c(I2C_MODE_SWI, CODEC_I2C_W, NULL);
+	if (ret) {
+		printk("%s: CHIP ADDRESS err. addr=0x%x\n", __FUNCTION__, addr);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_WIP, addr, NULL);
+	if (ret) {
+		printk("%s: MAP BYTE err. addr=0x%x\n", __FUNCTION__, addr);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_SWI, CODEC_I2C_R, NULL);
+	if (ret) {
+		printk("%s: CHIP ADDRESS2 err. addr=0x%x\n", __FUNCTION__, addr);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_ROP, 0x00, data);
+	if (ret) {
+		printk("%s: REGISTER WRITE err. addr=0x%x\n", __FUNCTION__, addr);
+		data = 0;
+		return ret;
+	}
+	return ret;
+}
+
+
+static int codec_write(unsigned char addr, unsigned char data)
+{
+	int ret;
+
+	ret = codec_i2c(I2C_MODE_SWI, CODEC_I2C_W, NULL);
+	if (ret) {
+		printk("%s: CHIP ADDRESS err. addr=0x%x data=%x\n", __FUNCTION__, addr, data);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_WI, addr, NULL);
+	if (ret) {
+		printk("%s: MAP BYTE err. addr=0x%x data=%x\n", __FUNCTION__, addr, data);
+		return ret;
+	}
+	ret = codec_i2c(I2C_MODE_WIP, data, NULL);
+	if (ret) {
+		printk("%s: REGISTER WRITE err. addr=0x%x data=%x\n", __FUNCTION__, addr, data);
+		return ret;
+	}
+	return ret;
+}
+
+static int codec_up(unsigned char pd)
+{
+	return codec_write(0x02, pd);
+}
+
+static int codec_down(void)
+{
+	return codec_write(0x02, 0x01);
+}
+
+int codec_init(void)
+{
+	int ret;
+	unsigned char data;
+
+	ret = codec_down();
+	if (ret) {
+		printk("codec_down() err\n");
+		return ret;
+	}
+
+	// Speed & MIC power
+	codec_write(0x03, 0x08);
+//	codec_write(0x03, 0x68);
+	// Interface control
+	codec_write(0x04, 0x4C);
+
+	codec_read(0x01, &data);
+	printk("codec id = 0x%x\n", data);
+
+	return ret;
+}
+
+int a9tc_codec_init(void)
+{
+	codec_reset(0);
+	codec_init();
+	codec_up(I2C_CODEC_PHONE_OUT);
+
+	codec_write(0x08, 0x60);
+
+#if 0
+	codec_write(0x09, 0x40);
+	codec_write(0x10, 0x00);
+	codec_write(0x11, 0x00);
+#endif
+
+	return 0;
+}
+
+void a9tc_codec_deinit(void)
+{
+	codec_down();
+	codec_reset(1);
+}
+
+#define MAX_LOOP_COUNT	256
+int a9tc_codec_data_write(unsigned int *buf, int count)
+{
+	int loop_count, i;
+	int val1, val2;
+
+	if (count > MAX_LOOP_COUNT) {
+		loop_count = MAX_LOOP_COUNT;
+	} else {
+		loop_count = count;
+	}
+
+	for (i = 0; i < loop_count; i++) {
+#if 0
+		val1 = ((*buf & 0xffff) * 24) /16;
+		val2 = (((*buf >> 16) & 0xffff) * 24) /16;
+#else
+		val1 = (*buf & 0xffff);
+		val2 = ((*buf >> 16) & 0xffff);
+#endif
+		writel(val1, A9TC_FPGA_PLAY_D);
+		writel(val2, A9TC_FPGA_PLAY_D);
+		buf++;
+	}
+
+	return loop_count;
+}
+
+int a9tc_codec_out_start(int start)
+{
+	if (start) {
+		writel(CODEC_PLAY, A9TC_FPGA_PLAY_C);
+	} else {
+		writel(0, A9TC_FPGA_PLAY_C);
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(a9tc_codec_init);
+EXPORT_SYMBOL(a9tc_codec_deinit);
+EXPORT_SYMBOL(a9tc_codec_data_write);
+EXPORT_SYMBOL(a9tc_codec_out_start);
diff --git a/arch/arm/mach-a9tc/include/codec.h b/arch/arm/mach-a9tc/include/codec.h
new file mode 100644
index 0000000..6cb81dc
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/codec.h
@@ -0,0 +1,38 @@
+/*
+ *  File Name       : linux/arch/arm/mach-a9tc/codec.h
+ *  Function        : codec header
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/07/01
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it under the terms of
+ *  the GNU General Public License as published by Free Softwere Foundation; either version 2
+ *  of License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARCH_CODEC_H
+#define __ASM_ARCH_CODEC_H
+
+#include <linux/io.h>
+
+extern int a9tc_codec_init(void);
+extern void a9tc_codec_deinit(void);
+extern int a9tc_codec_data_write(unsigned int *buf, int count);
+extern int a9tc_codec_out_start(int start);
+
+
+
+
+
+#endif
diff --git a/arch/arm/mach-a9tc/include/core.c b/arch/arm/mach-a9tc/include/core.c
new file mode 100644
index 0000000..f432cf7
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/core.c
@@ -0,0 +1,214 @@
+
+/*
+ *  linux/arch/arm/mach-a9tc/core.c
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/io.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include <asm/hardware/arm_timer.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+
+#include "core.h"
+
+/* used by entry-macro.S and platsmp.c */
+void __iomem *gic_cpu_base_addr;
+
+
+/*
+ * Where is the timer (VA)?
+ */
+void __iomem *timer0_va_base;
+void __iomem *timer1_va_base;
+
+/*
+ * How long is the timer interval?
+ */
+#define	TIMER_PCLK	(80000000)	/* 80.000 MHz */
+#define TIMER_INTERVAL	(TIMER_PCLK / 100)	/* ticks per 10 msec */
+#define TIMER_RELOAD	(TIMER_INTERVAL)
+#define TIMER_DIVISOR	(TIMER_CTRL_DIV1)
+#define TICKS2USECS(x)	((x) / TICKS_PER_uSEC)
+
+static void timer_set_mode(enum clock_event_mode mode,
+			   struct clock_event_device *clk)
+{
+	unsigned long ctrl;
+
+	switch(mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		writel(TIMER_RELOAD, timer0_va_base + TIMER_LOAD);
+
+		ctrl = TIMER_CTRL_PERIODIC;
+		ctrl |= TIMER_CTRL_32BIT | TIMER_CTRL_IE | TIMER_CTRL_ENABLE;
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* period set, and timer enabled in 'next_event' hook */
+		ctrl = TIMER_CTRL_ONESHOT;
+		ctrl |= TIMER_CTRL_32BIT | TIMER_CTRL_IE;
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	default:
+		ctrl = 0;
+	}
+
+	writel(ctrl, timer0_va_base + TIMER_CTRL);
+}
+
+static int timer_set_next_event(unsigned long evt,
+				struct clock_event_device *unused)
+{
+	unsigned long ctrl = readl(timer0_va_base + TIMER_CTRL);
+
+	writel(evt, timer0_va_base + TIMER_LOAD);
+	writel(ctrl | TIMER_CTRL_ENABLE, timer0_va_base + TIMER_CTRL);
+
+	return 0;
+}
+
+static struct clock_event_device timer0_clockevent =	 {
+	.name		= "timer0",
+	.shift		= 32,
+	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode	= timer_set_mode,
+	.set_next_event	= timer_set_next_event,
+	.rating		= 300,
+	.cpumask	= CPU_MASK_ALL,
+};
+
+static void __init a9tc_clockevents_init(unsigned int timer_irq)
+{
+	timer0_clockevent.irq = timer_irq;
+	timer0_clockevent.mult =
+		div_sc(TIMER_PCLK, NSEC_PER_SEC, timer0_clockevent.shift);
+	timer0_clockevent.max_delta_ns =
+		clockevent_delta2ns(0xffffffff, &timer0_clockevent);
+	timer0_clockevent.min_delta_ns =
+		clockevent_delta2ns(0xf, &timer0_clockevent);
+
+	clockevents_register_device(&timer0_clockevent);
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t a9tc_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &timer0_clockevent;
+
+	/* clear the interrupt */
+	writel(1, timer0_va_base + TIMER_INTCLR);
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction a9tc_timer_irq = {
+	.name		= "timer0",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= a9tc_timer_interrupt,
+};
+
+static cycle_t a9tc_get_cycles(void)
+{
+	return ~readl(timer1_va_base + TIMER_VALUE);
+}
+
+static struct clocksource clocksource_a9tc = {
+	.name	= "timer1",
+	.rating	= 200,
+	.read	= a9tc_get_cycles,
+	.mask	= CLOCKSOURCE_MASK(32),
+	.shift	= 20,
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void __init a9tc_clocksource_init(void)
+{
+	/* setup timer 0 as free-running clocksource */
+	writel(0, timer1_va_base + TIMER_CTRL);
+	writel(0xffffffff, timer1_va_base + TIMER_LOAD);
+	writel(0xffffffff, timer1_va_base + TIMER_VALUE);
+	writel(TIMER_CTRL_32BIT | TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC,
+		timer1_va_base + TIMER_CTRL);
+
+	clocksource_a9tc.mult =
+		clocksource_khz2mult(TIMER_PCLK / 1000, clocksource_a9tc.shift);
+	clocksource_register(&clocksource_a9tc);
+}
+
+/*
+ * Set up the clock source and clock events devices
+ */
+static void __init a9tc_timer_init(void)
+{
+
+	timer0_va_base = __io_address(A9TC_TIMER0_BASE);
+	timer1_va_base = __io_address(A9TC_TIMER1_BASE);
+#ifdef CONFIG_LOCAL_TIMERS
+	twd_base = __io_address(A9TC_TWD_BASE);
+#endif
+
+#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
+	/*
+	 * The dummy clock device has to be registered before the main device
+	 * so that the latter will broadcast the clock events
+	 */
+	local_timer_setup();
+#endif
+
+
+	/* 
+	 * set clock frequency: 
+	 */
+
+	/*
+	 * Initialise to a known state (all timers off)
+	 */
+	writel(0, timer0_va_base + TIMER_CTRL);
+	writel(0, timer1_va_base + TIMER_CTRL);
+
+	/* 
+	 * Make irqs happen for the system timer
+	 */
+	setup_irq(IRQ_TIMER0, &a9tc_timer_irq);
+
+	a9tc_clocksource_init();
+	a9tc_clockevents_init(IRQ_TIMER0);
+}
+
+struct sys_timer a9tc_timer = {
+	.init	= a9tc_timer_init,
+};
+
diff --git a/arch/arm/mach-a9tc/include/core.h b/arch/arm/mach-a9tc/include/core.h
new file mode 100644
index 0000000..e21801f
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/core.h
@@ -0,0 +1,57 @@
+/*
+ *  linux/arch/arm/mach-a9tc/core.h
+ *
+ *  Copyright (C) 2004 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_CORE_H
+#define __ASM_ARCH_CORE_H
+
+#include <linux/amba/bus.h>
+#include <linux/io.h>
+
+#include <asm/leds.h>
+
+#define AMBA_DEVICE(name,busid,base,plat)			\
+static struct amba_device name##_device = {			\
+	.dev		= {					\
+		.coherent_dma_mask = ~0,			\
+		.bus_id	= busid,				\
+		.platform_data = plat,				\
+	},							\
+	.res		= {					\
+		.start	= A9TC_##base##_BASE,		\
+		.end	= (A9TC_##base##_BASE) + SZ_4K - 1,	\
+		.flags	= IORESOURCE_MEM,			\
+	},							\
+	.dma_mask	= ~0,					\
+	.irq		= base##_IRQ,				\
+	/* .dma		= base##_DMA,*/				\
+}
+
+extern void __iomem *gic_cpu_base_addr;
+#ifdef CONFIG_LOCAL_TIMERS
+extern void __iomem *twd_base;
+#endif
+extern void __iomem *timer0_va_base;
+extern void __iomem *timer1_va_base;
+
+extern struct sys_timer a9tc_timer;
+
+#endif
diff --git a/arch/arm/mach-a9tc/include/headsmp.S b/arch/arm/mach-a9tc/include/headsmp.S
new file mode 100644
index 0000000..da15f88
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/headsmp.S
@@ -0,0 +1,39 @@
+/*
+ *  linux/arch/arm/mach-a9tc/headsmp.S
+ *
+ *  Copyright (c) 2003 ARM Limited
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+	__INIT
+
+/*
+ * A9TC specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(a9tc_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+
+1:	.long	.
+	.long	pen_release
diff --git a/arch/arm/mach-a9tc/include/hotplug.c b/arch/arm/mach-a9tc/include/hotplug.c
new file mode 100644
index 0000000..dd61b0f
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/hotplug.c
@@ -0,0 +1,141 @@
+/*
+ *  linux/arch/arm/mach-a9tc/hotplug.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/completion.h>
+
+#include <asm/cacheflush.h>
+
+extern volatile int pen_release;
+
+static DECLARE_COMPLETION(cpu_killed);
+
+static inline void cpu_enter_lowpower(void)
+{
+	unsigned int v;
+
+	flush_cache_all();
+	asm volatile(
+	"	mcr	p15, 0, %1, c7, c5, 0\n"
+	"	mcr	p15, 0, %1, c7, c10, 4\n"
+	/*
+	 * Turn off coherency
+	 */
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	bic	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	"	mrc	p15, 0, %0, c1, c0, 0\n"
+	"	bic	%0, %0, #0x04\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	  : "=&r" (v)
+	  : "r" (0)
+	  : "cc");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile(	"mrc	p15, 0, %0, c1, c0, 0\n"
+	"	orr	%0, %0, #0x04\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	orr	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	  : "=&r" (v)
+	  :
+	  : "cc");
+}
+
+static inline void platform_do_lowpower(unsigned int cpu)
+{
+	/*
+	 * there is no power-control hardware on this platform, so all
+	 * we can do is put the core into WFI; this is safe as the calling
+	 * code will have already disabled interrupts
+	 */
+	for (;;) {
+		/*
+		 * here's the WFI
+		 */
+		asm(".word	0xe320f003\n"
+		    :
+		    :
+		    : "memory", "cc");
+
+		if (pen_release == cpu) {
+			/*
+			 * OK, proper wakeup, we're done
+			 */
+			break;
+		}
+
+		/*
+		 * getting here, means that we have come out of WFI without
+		 * having been woken up - this shouldn't happen
+		 *
+		 * The trouble is, letting people know about this is not really
+		 * possible, since we are currently running incoherently, and
+		 * therefore cannot safely call printk() or anything else
+		 */
+#ifdef DEBUG
+		printk("CPU%u: spurious wakeup call\n", cpu);
+#endif
+	}
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+	return wait_for_completion_timeout(&cpu_killed, 5000);
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void platform_cpu_die(unsigned int cpu)
+{
+#ifdef DEBUG
+	unsigned int this_cpu = hard_smp_processor_id();
+
+	if (cpu != this_cpu) {
+		printk(KERN_CRIT "Eek! platform_cpu_die running on %u, should be %u\n",
+			   this_cpu, cpu);
+		BUG();
+	}
+#endif
+
+	printk(KERN_NOTICE "CPU%u: shutdown\n", cpu);
+	complete(&cpu_killed);
+
+	/*
+	 * we're ready for shutdown now, so do it
+	 */
+	cpu_enter_lowpower();
+	platform_do_lowpower(cpu);
+
+	/*
+	 * bring this CPU back into the world of cache
+	 * coherency, and then restore interrupts
+	 */
+	cpu_leave_lowpower();
+}
+
+int mach_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-a9tc/include/localtimer.c b/arch/arm/mach-a9tc/include/localtimer.c
new file mode 100644
index 0000000..43be362
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/localtimer.c
@@ -0,0 +1,202 @@
+/*
+ *  linux/arch/arm/mach-a9tc/localtimer.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/jiffies.h>
+#include <linux/percpu.h>
+#include <linux/clockchips.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+
+#include <asm/hardware/arm_twd.h>
+#include <asm/hardware/gic.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+
+static DEFINE_PER_CPU(struct clock_event_device, local_clockevent);
+
+/*
+ * Used on SMP for either the local timer or IPI_TIMER
+ */
+void local_timer_interrupt(void)
+{
+	struct clock_event_device *clk = &__get_cpu_var(local_clockevent);
+
+	clk->event_handler(clk);
+}
+
+#ifdef CONFIG_LOCAL_TIMERS
+
+/* set up by the platform code */
+void __iomem *twd_base;
+
+static unsigned long mpcore_timer_rate;
+
+static void local_timer_set_mode(enum clock_event_mode mode,
+				 struct clock_event_device *clk)
+{
+	unsigned long ctrl;
+
+	switch(mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		/* timer load already set up */
+		ctrl = TWD_TIMER_CONTROL_ENABLE | TWD_TIMER_CONTROL_IT_ENABLE
+			| TWD_TIMER_CONTROL_PERIODIC;
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* period set, and timer enabled in 'next_event' hook */
+		ctrl = TWD_TIMER_CONTROL_IT_ENABLE | TWD_TIMER_CONTROL_ONESHOT;
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	default:
+		ctrl = 0;
+	}
+
+	__raw_writel(ctrl, twd_base + TWD_TIMER_CONTROL);
+}
+
+static int local_timer_set_next_event(unsigned long evt,
+				      struct clock_event_device *unused)
+{
+	unsigned long ctrl = __raw_readl(twd_base + TWD_TIMER_CONTROL);
+
+	__raw_writel(evt, twd_base + TWD_TIMER_COUNTER);
+	__raw_writel(ctrl | TWD_TIMER_CONTROL_ENABLE, twd_base + TWD_TIMER_CONTROL);
+
+	return 0;
+}
+
+/*
+ * local_timer_ack: checks for a local timer interrupt.
+ *
+ * If a local timer interrupt has occurred, acknowledge and return 1.
+ * Otherwise, return 0.
+ */
+int local_timer_ack(void)
+{
+	if (__raw_readl(twd_base + TWD_TIMER_INTSTAT)) {
+		__raw_writel(1, twd_base + TWD_TIMER_INTSTAT);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void __cpuinit twd_calibrate_rate(void)
+{
+	unsigned long load, count;
+	u64 waitjiffies;
+
+	/*
+	 * If this is the first time round, we need to work out how fast
+	 * the timer ticks
+	 */
+	if (mpcore_timer_rate == 0) {
+		printk("Calibrating local timer... ");
+
+		/* Wait for a tick to start */
+		waitjiffies = get_jiffies_64() + 1;
+
+		while (get_jiffies_64() < waitjiffies)
+			udelay(10);
+
+		/* OK, now the tick has started, let's get the timer going */
+		waitjiffies += 5;
+
+				 /* enable, no interrupt or reload */
+		__raw_writel(0x1, twd_base + TWD_TIMER_CONTROL);
+
+				 /* maximum value */
+		__raw_writel(0xFFFFFFFFU, twd_base + TWD_TIMER_COUNTER);
+
+		while (get_jiffies_64() < waitjiffies)
+			udelay(10);
+
+		count = __raw_readl(twd_base + TWD_TIMER_COUNTER);
+
+		mpcore_timer_rate = (0xFFFFFFFFU - count) * (HZ / 5);
+
+		printk("%lu.%02luMHz.\n", mpcore_timer_rate / 1000000,
+			(mpcore_timer_rate / 100000) % 100);
+	}
+
+	load = mpcore_timer_rate / HZ;
+
+	__raw_writel(load, twd_base + TWD_TIMER_LOAD);
+}
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+void __cpuinit local_timer_setup(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct clock_event_device *clk = &per_cpu(local_clockevent, cpu);
+	unsigned long flags;
+
+	twd_calibrate_rate();
+
+	clk->name		= "local_timer";
+	clk->features		= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;
+	clk->rating		= 350;
+	clk->set_mode		= local_timer_set_mode;
+	clk->set_next_event	= local_timer_set_next_event;
+	clk->irq		= IRQ_LOCALTIMER;
+	clk->cpumask		= cpumask_of_cpu(cpu);
+	clk->shift		= 20;
+	clk->mult		= div_sc(mpcore_timer_rate, NSEC_PER_SEC, clk->shift);
+	clk->max_delta_ns	= clockevent_delta2ns(0xffffffff, clk);
+	clk->min_delta_ns	= clockevent_delta2ns(0xf, clk);
+
+	/* Make sure our local interrupt controller has this enabled */
+	local_irq_save(flags);
+	get_irq_chip(IRQ_LOCALTIMER)->unmask(IRQ_LOCALTIMER);
+	local_irq_restore(flags);
+
+	clockevents_register_device(clk);
+}
+
+/*
+ * take a local timer down
+ */
+//void __cpuexit local_timer_stop(void)
+void local_timer_stop(void)
+{
+	__raw_writel(0, twd_base + TWD_TIMER_CONTROL);
+}
+
+#else	/* CONFIG_LOCAL_TIMERS */
+
+static void dummy_timer_set_mode(enum clock_event_mode mode,
+				 struct clock_event_device *clk)
+{
+}
+
+void __cpuinit local_timer_setup(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct clock_event_device *clk = &per_cpu(local_clockevent, cpu);
+
+	clk->name		= "dummy_timer";
+	clk->features		= CLOCK_EVT_FEAT_DUMMY;
+	clk->rating		= 200;
+	clk->set_mode		= dummy_timer_set_mode;
+	clk->broadcast		= smp_timer_broadcast;
+	clk->cpumask		= cpumask_of_cpu(cpu);
+
+	clockevents_register_device(clk);
+}
+
+#endif	/* !CONFIG_LOCAL_TIMERS */
diff --git a/arch/arm/mach-a9tc/include/mach/board.h b/arch/arm/mach-a9tc/include/mach/board.h
new file mode 100644
index 0000000..aeaa6b3
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/board.h
@@ -0,0 +1,112 @@
+/*
+ * arch/arm/mach-a9tc/include/mach/board.h
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_BOARD_H
+#define __ASM_ARCH_BOARD_H
+
+#include <mach/hardware.h>
+#include <mach/platform.h>
+
+/*
+ * A9TC board peripheral addresses
+ */
+#define A9TC_FLASH_BASE	0x40000000
+#define A9TC_SDC_BASE	0x4A000000
+#define A9TC_FPGA_BASE	0x4A800000
+#define A9TC_ETH_BASE	0x4C000000
+#define A9TC_USB_BASE	0x4E000000
+#define A9TC_NAND_BASE	0x5C000000
+
+/*
+ * A9TC board FPGA
+ */
+#define A9TC_FPGA_VIRT_ADDRESS	IO_ADDRESS(A9TC_FPGA_BASE)
+#define A9TC_FPGA_LCD_KEY	(A9TC_FPGA_VIRT_ADDRESS + 0x00)
+#define A9TC_FPGA_LCD_PAD	(A9TC_FPGA_VIRT_ADDRESS + 0x04)
+#define A9TC_FPGA_CODEC		(A9TC_FPGA_VIRT_ADDRESS + 0x08)
+#define A9TC_FPGA_PLAY_C	(A9TC_FPGA_VIRT_ADDRESS + 0x0C)
+#define A9TC_FPGA_PLAY_D	(A9TC_FPGA_VIRT_ADDRESS + 0x10)
+#define A9TC_FPGA_REC_C		(A9TC_FPGA_VIRT_ADDRESS + 0x14)
+#define A9TC_FPGA_REC_D		(A9TC_FPGA_VIRT_ADDRESS + 0x18)
+#define A9TC_FPGA_RTC		(A9TC_FPGA_VIRT_ADDRESS + 0x24)
+#define A9TC_FPGA_PEX_I2S	(A9TC_FPGA_VIRT_ADDRESS + 0x28)
+#define A9TC_FPGA_MISC_F	(A9TC_FPGA_VIRT_ADDRESS + 0x3C)
+
+/*
+ * A9TC interrupt sources
+ */
+// External
+#define IRQ_PEX_DONE		(IRQ_GIC_START + 15)
+#define IRQ_PEX				(IRQ_GIC_START + 16)
+#define IRQ_RTC_BUSY		(IRQ_GIC_START + 17)
+#define IRQ_RTC_DONE		(IRQ_GIC_START + 18)
+#define IRQ_I2S_DO			(IRQ_GIC_START + 19)
+#define IRQ_I2S_DI			(IRQ_GIC_START + 20)
+#define IRQ_I2S_DO_EMPTY	(IRQ_GIC_START + 21)
+#define IRQ_I2S_DI_EMPTY	(IRQ_GIC_START + 22)
+#define IRQ_I2C_DONE		(IRQ_GIC_START + 23)
+#define IRQ_PAD_DONE		(IRQ_GIC_START + 24)
+#define IRQ_RTC				(IRQ_GIC_START + 25)
+#define IRQ_SD				(IRQ_GIC_START + 26)
+#define IRQ_UART2_RXRDY		(IRQ_GIC_START + 27)
+#define IRQ_UART2_TXRDY		(IRQ_GIC_START + 28)
+#define IRQ_UART2_INTD		(IRQ_GIC_START + 29)
+#define IRQ_UART2_INTC		(IRQ_GIC_START + 30)
+#define IRQ_UART2_INTB		(IRQ_GIC_START + 31)
+#define IRQ_UART2_INTA		(IRQ_GIC_START + 32)
+
+#define IRQ_ETH				(IRQ_GIC_START + 34)
+#define IRQ_USB				(IRQ_GIC_START + 35)
+
+#define IRQ_PAD				(IRQ_GIC_START + 37)
+
+#define IRQ_TINT			(IRQ_GIC_START + 38)
+#define IRQ_PMUIRQ0			(IRQ_GIC_START + 39)
+#define IRQ_PMUIRQ1			(IRQ_GIC_START + 40)
+#define IRQ_PMUIRQ2			(IRQ_GIC_START + 41)
+#define IRQ_PMUIRQ3			(IRQ_GIC_START + 42)
+
+// Internal
+#define IRQ_L2CC		(IRQ_GIC_START + 43)
+#define IRQ_CLCD		(IRQ_GIC_START + 44)
+#define IRQ_SMC0		(IRQ_GIC_START + 45)
+#define IRQ_SMC1		(IRQ_GIC_START + 46)
+#define IRQ_NMC			(IRQ_GIC_START + 47)
+#define IRQ_TIMER0		(IRQ_GIC_START + 48)
+#define IRQ_TIMER1		(IRQ_GIC_START + 49)
+#define IRQ_GPIO		(IRQ_GIC_START + 50)
+#define IRQ_WDT			(IRQ_GIC_START + 51)
+#define IRQ_UART0		(IRQ_GIC_START + 52)
+#define IRQ_TZASC		(IRQ_GIC_START + 53)
+#define IRQ_PCIA		(IRQ_GIC_START + 56)
+#define IRQ_PCIB		(IRQ_GIC_START + 57)
+#define IRQ_PCIC		(IRQ_GIC_START + 58)
+#define IRQ_PCID		(IRQ_GIC_START + 59)
+#define IRQ_PMU0		(IRQ_GIC_START + 60)
+#define IRQ_PMU1		(IRQ_GIC_START + 61)
+#define IRQ_PMU2		(IRQ_GIC_START + 62)
+#define IRQ_PMU3		(IRQ_GIC_START + 63)
+
+
+#define IRQ_LAST	IRQ_PMU3
+
+#define NR_IRQS	(IRQ_LAST + 1)
+
+#endif	/* __ASM_ARCH_BOARD_H */
diff --git a/arch/arm/mach-a9tc/include/mach/debug-macro.S b/arch/arm/mach-a9tc/include/mach/debug-macro.S
new file mode 100644
index 0000000..8928eba
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/debug-macro.S
@@ -0,0 +1,21 @@
+/* arch/arm/mach-a9tc/include/mach/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+	.macro	addruart,rx
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1			@ MMU enabled?
+	mov	\rx,#0x10000000		@ physical base
+	movne	\rx,\rx,lsr #4		@ virtual base
+	orrne	\rx,\rx,#0xf0000000
+	orr	\rx, \rx, #0xe3000
+	.endm
+
+#include <asm/hardware/debug-pl01x.S>
diff --git a/arch/arm/mach-a9tc/include/mach/dma.h b/arch/arm/mach-a9tc/include/mach/dma.h
new file mode 100644
index 0000000..00e1009
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/dma.h
@@ -0,0 +1,20 @@
+/*
+ *  arch/arm/mach-a9tc/include/mach/dma.h
+ *
+ *  Copyright (C) 2003 ARM Limited.
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff --git a/arch/arm/mach-a9tc/include/mach/entry-macro.S b/arch/arm/mach-a9tc/include/mach/entry-macro.S
new file mode 100644
index 0000000..1f89603
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/entry-macro.S
@@ -0,0 +1,87 @@
+/*
+ * arch/arm/mach-a9tc/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for A9TC platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <mach/hardware.h>
+#include <asm/hardware/gic.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		ldr	\base, =gic_cpu_base_addr
+		ldr	\base, [\base]
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		/*
+		 * The interrupt numbering scheme is defined in the
+		 * interrupt controller spec.  To wit:
+		 *
+		 * Interrupts 0-15 are IPI
+		 * 16-28 are reserved
+		 * 29-31 are local.  We allow 30 to be used for the watchdog.
+		 * 32-1020 are global
+		 * 1021-1022 are reserved
+		 * 1023 is "spurious" (no interrupt)
+		 *
+		 * For now, we ignore all local interrupts so only return an interrupt if it's
+		 * between 30 and 1020.  The test_for_ipi routine below will pick up on IPIs.
+		 *
+		 * A simple read from the controller will tell us the number of the highest
+                 * priority enabled interrupt.  We then just need to check whether it is in the
+		 * valid range for an IRQ (30-1020 inclusive).
+		 */
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+		ldr     \irqstat, [\base, #GIC_CPU_INTACK] /* bits 12-10 = src CPU, 9-0 = int # */
+
+		ldr	\tmp, =1021
+
+		bic     \irqnr, \irqstat, #0x1c00
+
+		cmp     \irqnr, #29
+		it	cc
+		cmpcc	\irqnr, \irqnr
+		it	ne
+		cmpne	\irqnr, \tmp
+		it	cs
+		cmpcs	\irqnr, \irqnr
+
+		.endm
+
+		/* We assume that irqstat (the raw value of the IRQ acknowledge
+		 * register) is preserved from the macro above.
+		 * If there is an IPI, we immediately signal end of interrupt on the
+		 * controller, since this requires the original irqstat value which
+		 * we won't easily be able to recreate later.
+		 */
+
+		.macro test_for_ipi, irqnr, irqstat, base, tmp
+		bic	\irqnr, \irqstat, #0x1c00
+		cmp	\irqnr, #16
+		it	cc
+		strcc	\irqstat, [\base, #GIC_CPU_EOI]
+		it	cs
+		cmpcs	\irqnr, \irqnr
+		.endm
+
+		/* As above, this assumes that irqstat and base are preserved.. */
+
+		.macro test_for_ltirq, irqnr, irqstat, base, tmp
+		bic	\irqnr, \irqstat, #0x1c00
+		mov 	\tmp, #0
+		cmp	\irqnr, #29
+		itt	eq
+		moveq	\tmp, #1
+		streq	\irqstat, [\base, #GIC_CPU_EOI]
+		cmp	\tmp, #0
+		.endm
diff --git a/arch/arm/mach-a9tc/include/mach/hardware.h b/arch/arm/mach-a9tc/include/mach/hardware.h
new file mode 100644
index 0000000..dbd3e06
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/hardware.h
@@ -0,0 +1,31 @@
+/*
+ *  arch/arm/mach-a9tc/include/mach/hardware.h
+ *
+ *  This file contains the hardware definitions of the A9TC boards.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+#define IO_ADDRESS(x)	(0xf0000000 + ((((x) >> 4) & 0x0ff00000) | ((x) & 0x000fffff)))
+
+#define __io_address(n)		__io(IO_ADDRESS(n))
+
+#endif
diff --git a/arch/arm/mach-a9tc/include/mach/io.h b/arch/arm/mach-a9tc/include/mach/io.h
new file mode 100644
index 0000000..10fb560
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/io.h
@@ -0,0 +1,33 @@
+/*
+ *  arch/arm/mach-a9tc/include/mach/io.h
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)addr;
+}
+
+#define __io(a)			__io(a)
+#define __mem_pci(a)		(a)
+
+#endif
diff --git a/arch/arm/mach-a9tc/include/mach/irqs.h b/arch/arm/mach-a9tc/include/mach/irqs.h
new file mode 100644
index 0000000..31a6b8d
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/irqs.h
@@ -0,0 +1,35 @@
+/*
+ *  arch/arm/mach-a9tc/include/mach/irqs.h
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#include <mach/board.h>
+
+#define IRQ_LOCALTIMER		29
+#define IRQ_LOCALWDOG		30
+
+#define IRQ_GIC_START		32
+
+#ifndef NR_IRQS
+#error "NR_IRQS not defined by the board-specific files"
+#endif
+
+#endif
diff --git a/arch/arm/mach-a9tc/include/mach/memory.h b/arch/arm/mach-a9tc/include/mach/memory.h
new file mode 100644
index 0000000..66f374b
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/memory.h
@@ -0,0 +1,38 @@
+/*
+ *  arch/arm/mach-a9tc/include/mach/memory.h
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET		UL(0x60000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+#endif
diff --git a/arch/arm/mach-a9tc/include/mach/platform.h b/arch/arm/mach-a9tc/include/mach/platform.h
new file mode 100644
index 0000000..9d89a68
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/platform.h
@@ -0,0 +1,53 @@
+/*
+ * arch/arm/mach-a9tc/include/mach/platform.h
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_PLATFORM_H
+#define __ASM_ARCH_PLATFORM_H
+
+/*
+ * A9TC Internal peripheral addresses
+ */
+#define A9TC_INTERNAL_IO_BASE	0x10000000
+#define A9TC_CLCD_BASE		0x10020000
+#define A9TC_SRAM_BASE		0x10060000
+#define A9TC_DMC_BASE		0x100E0000
+#define A9TC_SMC_BASE		0x100E1000
+#define A9TC_SYSTEM_BASE	0x100E2000
+#define A9TC_UART0_BASE		0x100E3000
+#define A9TC_TIMER0_BASE	0x100E4000
+#define A9TC_TIMER1_BASE	0x100E4020
+#define A9TC_WDT_BASE		0x100E5000
+#define A9TC_TZPC_BASE		0x100E6000
+#define A9TC_NMC_BASE		0x100E7000
+#define A9TC_GPIO_BASE		0x100E8000
+#define A9TC_FPL301_BASE	0x100E9000
+#define A9TC_SPL301_BASE	0x100EA000
+#define A9TC_TZMPU_BASE		0x100EC000
+#define A9TC_SCU_BASE		0x1E000000
+#define A9TC_GIC_CPU_BASE	0x1E000100
+#define A9TC_TWD_BASE		0x1E000600
+#define A9TC_GIC_DIST_BASE	0x1E001000
+#define A9TC_L2CC_BASE		0x1E00A000
+
+#define A9TC_SMC0_BASE		0x40000000
+#define A9TC_SMC1_BASE		0x50000000
+#define A9TC_SDRAM_BASE		0x60000000
+
+#endif	/* __ASM_ARCH_PLATFORM_H */
diff --git a/arch/arm/mach-a9tc/include/mach/scu.h b/arch/arm/mach-a9tc/include/mach/scu.h
new file mode 100644
index 0000000..d55802d
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/scu.h
@@ -0,0 +1,13 @@
+#ifndef __ASMARM_ARCH_SCU_H
+#define __ASMARM_ARCH_SCU_H
+
+/*
+ * SCU registers
+ */
+#define SCU_CTRL		0x00
+#define SCU_CONFIG		0x04
+#define SCU_CPU_STATUS		0x08
+#define SCU_INVALIDATE		0x0c
+#define SCU_FPGA_REVISION	0x10
+
+#endif
diff --git a/arch/arm/mach-a9tc/include/mach/smp.h b/arch/arm/mach-a9tc/include/mach/smp.h
new file mode 100644
index 0000000..515819e
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/smp.h
@@ -0,0 +1,30 @@
+#ifndef ASMARM_ARCH_SMP_H
+#define ASMARM_ARCH_SMP_H
+
+
+#include <asm/hardware/gic.h>
+
+#define hard_smp_processor_id()			\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+/*
+ * We use IRQ1 as the IPI
+ */
+static inline void smp_cross_call(cpumask_t callmap)
+{
+	gic_raise_softirq(callmap, 1);
+}
+
+/*
+ * Do nothing on MPcore.
+ */
+static inline void smp_cross_call_done(cpumask_t callmap)
+{
+}
+
+#endif
diff --git a/arch/arm/mach-a9tc/include/mach/system.h b/arch/arm/mach-a9tc/include/mach/system.h
new file mode 100644
index 0000000..849191a
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/system.h
@@ -0,0 +1,41 @@
+/*
+ *  arch/arm/mach-a9tc/include/mach/system.h
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	while(1);
+}
+
+#endif
diff --git a/arch/arm/mach-a9tc/include/mach/timex.h b/arch/arm/mach-a9tc/include/mach/timex.h
new file mode 100644
index 0000000..8dd525e
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/timex.h
@@ -0,0 +1,23 @@
+/*
+ *  arch/arm/mach-a9tc/include/mach/timex.h
+ *
+ *  A9TC architecture timex specifications
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define CLOCK_TICK_RATE		100000000
diff --git a/arch/arm/mach-a9tc/include/mach/uncompress.h b/arch/arm/mach-a9tc/include/mach/uncompress.h
new file mode 100644
index 0000000..f54a225
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/uncompress.h
@@ -0,0 +1,63 @@
+/*
+ *  arch/arm/mach-a9tc/include/mach/uncompress.h
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+
+#include <mach/board.h>
+
+#define AMBA_UART_DR(base)	(*(volatile unsigned char *)((base) + 0x00))
+#define AMBA_UART_LCRH(base)	(*(volatile unsigned char *)((base) + 0x2c))
+#define AMBA_UART_CR(base)	(*(volatile unsigned char *)((base) + 0x30))
+#define AMBA_UART_FR(base)	(*(volatile unsigned char *)((base) + 0x18))
+
+/*
+ * Return the UART base address
+ */
+static inline unsigned long get_uart_base(void)
+{
+	return UART0_BASE;
+}
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	unsigned long base = get_uart_base();
+
+	while (AMBA_UART_FR(base) & (1 << 5))
+		barrier();
+
+	AMBA_UART_DR(base) = c;
+}
+
+static inline void flush(void)
+{
+	unsigned long base = get_uart_base();
+
+	while (AMBA_UART_FR(base) & (1 << 3))
+		barrier();
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff --git a/arch/arm/mach-a9tc/include/mach/vmalloc.h b/arch/arm/mach-a9tc/include/mach/vmalloc.h
new file mode 100644
index 0000000..9fcc57d
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/mach/vmalloc.h
@@ -0,0 +1,20 @@
+/*
+ *  arch/arm/mach-a9tc/include/mach/vmalloc.h
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		(PAGE_OFFSET + 0x20000000)
diff --git a/arch/arm/mach-a9tc/include/platsmp.c b/arch/arm/mach-a9tc/include/platsmp.c
new file mode 100644
index 0000000..db23048
--- /dev/null
+++ b/arch/arm/mach-a9tc/include/platsmp.c
@@ -0,0 +1,247 @@
+/*
+ *  linux/arch/arm/mach-a9tc/platsmp.c
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/timer.h>
+
+#include <asm/cacheflush.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/unified.h>
+
+#include <mach/board.h>
+#include <mach/scu.h>
+
+#include "core.h"
+
+extern void a9tc_secondary_startup(void);
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int __cpuinitdata pen_release = -1;
+
+static void __iomem *scu_base_addr(void)
+{
+	return __io_address(A9TC_SCU_BASE);
+}
+
+static unsigned int __init get_core_count(void)
+{
+	unsigned int ncores;
+	void __iomem *scu_base = scu_base_addr();
+
+	if (scu_base) {
+		ncores = __raw_readl(scu_base + SCU_CONFIG);
+		ncores = (ncores & 0x03) + 1;
+	} else
+		ncores = 1;
+
+	return ncores;
+}
+
+/*
+ * Setup the SCU
+ */
+static void scu_enable(void)
+{
+	u32 scu_ctrl;
+	void __iomem *scu_base = scu_base_addr();
+
+	scu_ctrl = __raw_readl(scu_base + SCU_CTRL);
+	if (!(scu_ctrl & 1)) {
+		/* not enabled yet */
+		scu_ctrl |= 1;
+		__raw_writel(scu_ctrl, scu_base + SCU_CTRL);
+	}
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	trace_hardirqs_off();
+
+	/*
+	 * the primary core may have used a "cross call" soft interrupt
+	 * to get this processor out of WFI in the BootMonitor - make
+	 * sure that we are no longer being sent this soft interrupt
+	 */
+	smp_cross_call_done(cpumask_of_cpu(cpu));
+
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_cpu_init(0, gic_cpu_base_addr);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	pen_release = -1;
+	smp_wmb();
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	flush_cache_all();
+	outer_clean_range(__pa(&secondary_data), __pa(&secondary_data + 1));
+	pen_release = cpu;
+	flush_cache_all();
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+
+	/*
+	 * XXX
+	 *
+	 * This is a later addition to the booting protocol: the
+	 * bootMonitor now puts secondary cores into WFI, so
+	 * poke_milo() no longer gets the cores moving; we need
+	 * to send a soft interrupt to wake the secondary core.
+	 * Use smp_cross_call() for this, since there's little
+	 * point duplicating the code here
+	 */
+	smp_cross_call(cpumask_of_cpu(cpu));
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+static void __init poke_milo(void)
+{
+	/* nobody is to be released from the pen yet */
+	pen_release = -1;
+
+	/*
+	 * Write the address of secondary startup into the system-wide flags
+	 * register. The BootMonitor waits for this register to become
+	 * non-zero.
+	 */
+	__raw_writel(BSYM(virt_to_phys(a9tc_secondary_startup)),
+		     IO_ADDRESS(A9TC_SRAM_BASE) + 0x00);
+
+	mb();
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	unsigned int i, ncores = get_core_count();
+
+	for (i = 0; i < ncores; i++)
+		cpu_set(i, cpu_possible_map);
+}
+
+void __init smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = get_core_count();
+	unsigned int cpu = smp_processor_id();
+	int i;
+
+	/* sanity check */
+	if (ncores == 0) {
+		printk(KERN_ERR
+		       "A9TC: strange CM count of 0? Default to 1\n");
+
+		ncores = 1;
+	}
+
+	if (ncores > NR_CPUS) {
+		printk(KERN_WARNING
+		       "A9TC: no. of cores (%d) greater than configured "
+		       "maximum of %d - clipping\n",
+		       ncores, NR_CPUS);
+		ncores = NR_CPUS;
+	}
+
+	smp_store_cpu_info(cpu);
+
+	/*
+	 * are we trying to boot more cores than exist?
+	 */
+	if (max_cpus > ncores)
+		max_cpus = ncores;
+
+#ifdef CONFIG_LOCAL_TIMERS
+	/*
+	 * Enable the local timer for primary CPU
+	 */
+	local_timer_setup();
+#endif
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		cpu_set(i, cpu_present_map);
+
+	/*
+	 * Initialise the SCU if there are more than one CPU and let
+	 * them know where to start. Note that, on modern versions of
+	 * MILO, the "poke" doesn't actually do anything until each
+	 * individual core is sent a soft interrupt to get it out of
+	 * WFI
+	 */
+	if (max_cpus > 1) {
+		scu_enable();
+		/*
+		 * Ensure that the data accessed by CPU0 before the SCU was
+		 * initialised is visible to the other CPUs.
+		 */
+		flush_cache_all();
+		poke_milo();
+	}
+}
diff --git a/arch/arm/mach-a9tc/localtimer.c b/arch/arm/mach-a9tc/localtimer.c
new file mode 100644
index 0000000..43be362
--- /dev/null
+++ b/arch/arm/mach-a9tc/localtimer.c
@@ -0,0 +1,202 @@
+/*
+ *  linux/arch/arm/mach-a9tc/localtimer.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/jiffies.h>
+#include <linux/percpu.h>
+#include <linux/clockchips.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+
+#include <asm/hardware/arm_twd.h>
+#include <asm/hardware/gic.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+
+static DEFINE_PER_CPU(struct clock_event_device, local_clockevent);
+
+/*
+ * Used on SMP for either the local timer or IPI_TIMER
+ */
+void local_timer_interrupt(void)
+{
+	struct clock_event_device *clk = &__get_cpu_var(local_clockevent);
+
+	clk->event_handler(clk);
+}
+
+#ifdef CONFIG_LOCAL_TIMERS
+
+/* set up by the platform code */
+void __iomem *twd_base;
+
+static unsigned long mpcore_timer_rate;
+
+static void local_timer_set_mode(enum clock_event_mode mode,
+				 struct clock_event_device *clk)
+{
+	unsigned long ctrl;
+
+	switch(mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		/* timer load already set up */
+		ctrl = TWD_TIMER_CONTROL_ENABLE | TWD_TIMER_CONTROL_IT_ENABLE
+			| TWD_TIMER_CONTROL_PERIODIC;
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* period set, and timer enabled in 'next_event' hook */
+		ctrl = TWD_TIMER_CONTROL_IT_ENABLE | TWD_TIMER_CONTROL_ONESHOT;
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	default:
+		ctrl = 0;
+	}
+
+	__raw_writel(ctrl, twd_base + TWD_TIMER_CONTROL);
+}
+
+static int local_timer_set_next_event(unsigned long evt,
+				      struct clock_event_device *unused)
+{
+	unsigned long ctrl = __raw_readl(twd_base + TWD_TIMER_CONTROL);
+
+	__raw_writel(evt, twd_base + TWD_TIMER_COUNTER);
+	__raw_writel(ctrl | TWD_TIMER_CONTROL_ENABLE, twd_base + TWD_TIMER_CONTROL);
+
+	return 0;
+}
+
+/*
+ * local_timer_ack: checks for a local timer interrupt.
+ *
+ * If a local timer interrupt has occurred, acknowledge and return 1.
+ * Otherwise, return 0.
+ */
+int local_timer_ack(void)
+{
+	if (__raw_readl(twd_base + TWD_TIMER_INTSTAT)) {
+		__raw_writel(1, twd_base + TWD_TIMER_INTSTAT);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void __cpuinit twd_calibrate_rate(void)
+{
+	unsigned long load, count;
+	u64 waitjiffies;
+
+	/*
+	 * If this is the first time round, we need to work out how fast
+	 * the timer ticks
+	 */
+	if (mpcore_timer_rate == 0) {
+		printk("Calibrating local timer... ");
+
+		/* Wait for a tick to start */
+		waitjiffies = get_jiffies_64() + 1;
+
+		while (get_jiffies_64() < waitjiffies)
+			udelay(10);
+
+		/* OK, now the tick has started, let's get the timer going */
+		waitjiffies += 5;
+
+				 /* enable, no interrupt or reload */
+		__raw_writel(0x1, twd_base + TWD_TIMER_CONTROL);
+
+				 /* maximum value */
+		__raw_writel(0xFFFFFFFFU, twd_base + TWD_TIMER_COUNTER);
+
+		while (get_jiffies_64() < waitjiffies)
+			udelay(10);
+
+		count = __raw_readl(twd_base + TWD_TIMER_COUNTER);
+
+		mpcore_timer_rate = (0xFFFFFFFFU - count) * (HZ / 5);
+
+		printk("%lu.%02luMHz.\n", mpcore_timer_rate / 1000000,
+			(mpcore_timer_rate / 100000) % 100);
+	}
+
+	load = mpcore_timer_rate / HZ;
+
+	__raw_writel(load, twd_base + TWD_TIMER_LOAD);
+}
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+void __cpuinit local_timer_setup(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct clock_event_device *clk = &per_cpu(local_clockevent, cpu);
+	unsigned long flags;
+
+	twd_calibrate_rate();
+
+	clk->name		= "local_timer";
+	clk->features		= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;
+	clk->rating		= 350;
+	clk->set_mode		= local_timer_set_mode;
+	clk->set_next_event	= local_timer_set_next_event;
+	clk->irq		= IRQ_LOCALTIMER;
+	clk->cpumask		= cpumask_of_cpu(cpu);
+	clk->shift		= 20;
+	clk->mult		= div_sc(mpcore_timer_rate, NSEC_PER_SEC, clk->shift);
+	clk->max_delta_ns	= clockevent_delta2ns(0xffffffff, clk);
+	clk->min_delta_ns	= clockevent_delta2ns(0xf, clk);
+
+	/* Make sure our local interrupt controller has this enabled */
+	local_irq_save(flags);
+	get_irq_chip(IRQ_LOCALTIMER)->unmask(IRQ_LOCALTIMER);
+	local_irq_restore(flags);
+
+	clockevents_register_device(clk);
+}
+
+/*
+ * take a local timer down
+ */
+//void __cpuexit local_timer_stop(void)
+void local_timer_stop(void)
+{
+	__raw_writel(0, twd_base + TWD_TIMER_CONTROL);
+}
+
+#else	/* CONFIG_LOCAL_TIMERS */
+
+static void dummy_timer_set_mode(enum clock_event_mode mode,
+				 struct clock_event_device *clk)
+{
+}
+
+void __cpuinit local_timer_setup(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct clock_event_device *clk = &per_cpu(local_clockevent, cpu);
+
+	clk->name		= "dummy_timer";
+	clk->features		= CLOCK_EVT_FEAT_DUMMY;
+	clk->rating		= 200;
+	clk->set_mode		= dummy_timer_set_mode;
+	clk->broadcast		= smp_timer_broadcast;
+	clk->cpumask		= cpumask_of_cpu(cpu);
+
+	clockevents_register_device(clk);
+}
+
+#endif	/* !CONFIG_LOCAL_TIMERS */
diff --git a/arch/arm/mach-a9tc/platsmp.c b/arch/arm/mach-a9tc/platsmp.c
new file mode 100644
index 0000000..db23048
--- /dev/null
+++ b/arch/arm/mach-a9tc/platsmp.c
@@ -0,0 +1,247 @@
+/*
+ *  linux/arch/arm/mach-a9tc/platsmp.c
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/timer.h>
+
+#include <asm/cacheflush.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/unified.h>
+
+#include <mach/board.h>
+#include <mach/scu.h>
+
+#include "core.h"
+
+extern void a9tc_secondary_startup(void);
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int __cpuinitdata pen_release = -1;
+
+static void __iomem *scu_base_addr(void)
+{
+	return __io_address(A9TC_SCU_BASE);
+}
+
+static unsigned int __init get_core_count(void)
+{
+	unsigned int ncores;
+	void __iomem *scu_base = scu_base_addr();
+
+	if (scu_base) {
+		ncores = __raw_readl(scu_base + SCU_CONFIG);
+		ncores = (ncores & 0x03) + 1;
+	} else
+		ncores = 1;
+
+	return ncores;
+}
+
+/*
+ * Setup the SCU
+ */
+static void scu_enable(void)
+{
+	u32 scu_ctrl;
+	void __iomem *scu_base = scu_base_addr();
+
+	scu_ctrl = __raw_readl(scu_base + SCU_CTRL);
+	if (!(scu_ctrl & 1)) {
+		/* not enabled yet */
+		scu_ctrl |= 1;
+		__raw_writel(scu_ctrl, scu_base + SCU_CTRL);
+	}
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	trace_hardirqs_off();
+
+	/*
+	 * the primary core may have used a "cross call" soft interrupt
+	 * to get this processor out of WFI in the BootMonitor - make
+	 * sure that we are no longer being sent this soft interrupt
+	 */
+	smp_cross_call_done(cpumask_of_cpu(cpu));
+
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_cpu_init(0, gic_cpu_base_addr);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	pen_release = -1;
+	smp_wmb();
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	flush_cache_all();
+	outer_clean_range(__pa(&secondary_data), __pa(&secondary_data + 1));
+	pen_release = cpu;
+	flush_cache_all();
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+
+	/*
+	 * XXX
+	 *
+	 * This is a later addition to the booting protocol: the
+	 * bootMonitor now puts secondary cores into WFI, so
+	 * poke_milo() no longer gets the cores moving; we need
+	 * to send a soft interrupt to wake the secondary core.
+	 * Use smp_cross_call() for this, since there's little
+	 * point duplicating the code here
+	 */
+	smp_cross_call(cpumask_of_cpu(cpu));
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+static void __init poke_milo(void)
+{
+	/* nobody is to be released from the pen yet */
+	pen_release = -1;
+
+	/*
+	 * Write the address of secondary startup into the system-wide flags
+	 * register. The BootMonitor waits for this register to become
+	 * non-zero.
+	 */
+	__raw_writel(BSYM(virt_to_phys(a9tc_secondary_startup)),
+		     IO_ADDRESS(A9TC_SRAM_BASE) + 0x00);
+
+	mb();
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	unsigned int i, ncores = get_core_count();
+
+	for (i = 0; i < ncores; i++)
+		cpu_set(i, cpu_possible_map);
+}
+
+void __init smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = get_core_count();
+	unsigned int cpu = smp_processor_id();
+	int i;
+
+	/* sanity check */
+	if (ncores == 0) {
+		printk(KERN_ERR
+		       "A9TC: strange CM count of 0? Default to 1\n");
+
+		ncores = 1;
+	}
+
+	if (ncores > NR_CPUS) {
+		printk(KERN_WARNING
+		       "A9TC: no. of cores (%d) greater than configured "
+		       "maximum of %d - clipping\n",
+		       ncores, NR_CPUS);
+		ncores = NR_CPUS;
+	}
+
+	smp_store_cpu_info(cpu);
+
+	/*
+	 * are we trying to boot more cores than exist?
+	 */
+	if (max_cpus > ncores)
+		max_cpus = ncores;
+
+#ifdef CONFIG_LOCAL_TIMERS
+	/*
+	 * Enable the local timer for primary CPU
+	 */
+	local_timer_setup();
+#endif
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		cpu_set(i, cpu_present_map);
+
+	/*
+	 * Initialise the SCU if there are more than one CPU and let
+	 * them know where to start. Note that, on modern versions of
+	 * MILO, the "poke" doesn't actually do anything until each
+	 * individual core is sent a soft interrupt to get it out of
+	 * WFI
+	 */
+	if (max_cpus > 1) {
+		scu_enable();
+		/*
+		 * Ensure that the data accessed by CPU0 before the SCU was
+		 * initialised is visible to the other CPUs.
+		 */
+		flush_cache_all();
+		poke_milo();
+	}
+}
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 2a47599..3d18e7e 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -428,7 +428,7 @@ config CPU_32v6K
 # ARMv7
 config CPU_V7
 	bool "Support ARM V7 processor"
-	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP3 || MACH_REALVIEW_PBA8 || MACH_REALVIEW_PBX
+	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP3 || MACH_REALVIEW_PBA8 || MACH_REALVIEW_PBX || ARCH_A9TC
 	select CPU_32v6K
 	select CPU_32v7
 	select CPU_ABRT_EV7
@@ -757,7 +757,7 @@ config CACHE_FEROCEON_L2_WRITETHROUGH
 
 config CACHE_L2X0
 	bool "Enable the L2x0 outer cache controller"
-	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || REALVIEW_EB_A9MP || MACH_REALVIEW_PBX
+	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || REALVIEW_EB_A9MP || MACH_REALVIEW_PBX || ARCH_A9TC
 	default y
 	select OUTER_CACHE
 	help
diff --git a/arch/arm/mm/alignment.c b/arch/arm/mm/alignment.c
index e0464c9..cbc4593 100644
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@ -68,7 +68,7 @@ static unsigned long ai_half;
 static unsigned long ai_word;
 static unsigned long ai_dword;
 static unsigned long ai_multi;
-static int ai_usermode;
+static int ai_usermode = 2;
 
 #define UM_WARN		(1 << 0)
 #define UM_FIXUP	(1 << 1)
diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
index 29e6904..572799c 100644
--- a/arch/arm/mm/cache-v7.S
+++ b/arch/arm/mm/cache-v7.S
@@ -74,6 +74,55 @@ finished:
 	mov	pc, lr
 ENDPROC(v7_flush_dcache_all)
 
+ENTRY(v7_inv_dcache_all)
+	dmb					@ ensure ordering with previous memory accesses
+	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
+	ands	r3, r0, #0x7000000		@ extract loc from clidr
+	mov	r3, r3, lsr #23			@ left align loc bit field
+	beq	invfinished			@ if loc is 0, then no need to clean
+	mov	r10, #0				@ start clean at cache level 0
+invloop1:
+	add	r2, r10, r10, lsr #1		@ work out 3x current cache level
+	mov	r1, r0, lsr r2			@ extract cache type bits from clidr
+	and	r1, r1, #7			@ mask of the bits for current cache only
+	cmp	r1, #2				@ see what cache we have at this level
+	blt	invskip				@ skip if no cache, or just i-cache
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
+	isb					@ isb to sych the new cssr&csidr
+	mrc	p15, 1, r1, c0, c0, 0		@ read the new csidr
+	and	r2, r1, #7			@ extract the length of the cache lines
+	add	r2, r2, #4			@ add 4 (line length offset)
+	ldr	r4, =0x3ff
+	ands	r4, r4, r1, lsr #3		@ find maximum number on the way size
+	clz	r5, r4				@ find bit position of way size increment
+	ldr	r7, =0x7fff
+	ands	r7, r7, r1, lsr #13		@ extract max number of the index size
+invloop2:
+	mov	r9, r4				@ create working copy of max way size
+invloop3:
+ ARM(	orr	r11, r10, r9, lsl r5	)	@ factor way and cache number into r11
+ THUMB(	lsl	r6, r9, r5		)
+ THUMB(	orr	r11, r10, r6		)	@ factor way and cache number into r11
+ ARM(	orr	r11, r11, r7, lsl r2	)	@ factor index number into r11
+ THUMB(	lsl	r6, r7, r2		)
+ THUMB(	orr	r11, r11, r6		)	@ factor index number into r11
+	mcr	p15, 0, r11, c7, c6, 2		@ clean & invalidate by set/way
+	subs	r9, r9, #1			@ decrement the way
+	bge	invloop3
+	subs	r7, r7, #1			@ decrement the index
+	bge	invloop2
+invskip:
+	add	r10, r10, #2			@ increment cache number
+	cmp	r3, r10
+	bgt	invloop1
+invfinished:
+	mov	r10, #0				@ swith back to cache level 0
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
+	dsb
+	isb
+	mov	pc, lr
+ENDPROC(v7_inv_dcache_all)
+
 /*
  *	v7_flush_cache_all()
  *
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index e78920f..fa58d73 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -29,10 +29,20 @@
 #define TTB_IRGN_WB	((1 << 0) | (1 << 6))
 
 #ifndef CONFIG_SMP
+#ifdef CONFIG_A9TC_L310_WT
+#define TTB_FLAGS	TTB_IRGN_WB|TTB_RGN_OC_WT		@ mark PTWs cacheable, outer WB
+#else
 #define TTB_FLAGS	TTB_IRGN_WB|TTB_RGN_OC_WB		@ mark PTWs cacheable, outer WB
+#endif
+#define PMD_SECT_SMP	0
+#else
+#ifdef CONFIG_A9TC_L310_WT
+#define TTB_FLAGS	TTB_IRGN_WBWA|TTB_S|TTB_RGN_OC_WT	@ mark PTWs cacheable and shared, outer WBWA
 #else
 #define TTB_FLAGS	TTB_IRGN_WBWA|TTB_S|TTB_RGN_OC_WBWA	@ mark PTWs cacheable and shared, outer WBWA
 #endif
+#define PMD_SECT_SMP	PMD_SECT_S
+#endif
 
 ENTRY(cpu_v7_proc_init)
 	mov	pc, lr
@@ -193,7 +203,11 @@ __v7_setup:
 #endif
 	adr	r12, __v7_setup_stack		@ the local stack
 	stmia	r12, {r0-r5, r7, r9, r11, lr}
+#if 0
 	bl	v7_flush_dcache_all
+#else
+	bl	v7_inv_dcache_all
+#endif
 	ldmia	r12, {r0-r5, r7, r9, r11, lr}
 #ifdef CONFIG_ARM_ERRATA_430973
 	mrc	p15, 0, r10, c1, c0, 1		@ read aux control register
@@ -224,7 +238,11 @@ __v7_setup:
 	mov	r10, #0x1f			@ domains 0, 1 = manager
 	mcr	p15, 0, r10, c3, c0, 0		@ load domain access register
 	ldr	r5, =0xff0aa1a8
+#ifdef CONFIG_A9TC_L310_WT
+	ldr	r6, =0x80a040e0
+#else
 	ldr	r6, =0x40e040e0
+#endif
 	mcr	p15, 0, r5, c10, c2, 0		@ write PRRR
 	mcr	p15, 0, r6, c10, c2, 1		@ write NMRR
 #endif
@@ -251,6 +269,7 @@ ENDPROC(__v7_setup)
 	.type	v7_crval, #object
 v7_crval:
  ARM(	crval	clear=0x0120c302, mmuset=0x10c0387d, ucset=0x00c0187c	)
+ ARM(	crval	clear=0x0120c302, mmuset=0x10c0387d, ucset=0x00c0187c	)
  THUMB(	crval	clear=0x0120c302, mmuset=0x50c0387d, ucset=0x40c0187c	)
 
 __v7_setup_stack:
@@ -293,7 +312,8 @@ __v7_proc_info:
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_SECT_AP_WRITE | \
-		PMD_SECT_AP_READ
+		PMD_SECT_AP_READ | \
+		PMD_SECT_SMP
 	.long   PMD_TYPE_SECT | \
 		PMD_SECT_XN | \
 		PMD_SECT_AP_WRITE | \
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 43aa202..2df7418 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1899,3 +1899,4 @@ rut100			MACH_RUT100		RUT100			1908
 asusp535		MACH_ASUSP535		ASUSP535		1909
 htcraphael		MACH_HTCRAPHAEL		HTCRAPHAEL		1910
 sygdg1			MACH_SYGDG1		SYGDG1			1911
+a9tc			MACH_A9TC		A9TC			3000
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index efd70a9..e376feb 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -323,4 +323,9 @@ config KEYBOARD_SH_KEYSC
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called sh_keysc.
+
+config KEYBOARD_A9TC
+	tristate "A9TC keypad support"
+	depends on ARCH_A9TC
+
 endif
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index 0edc8f2..56e1c54 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -27,3 +27,4 @@ obj-$(CONFIG_KEYBOARD_HP7XX)		+= jornada720_kbd.o
 obj-$(CONFIG_KEYBOARD_MAPLE)		+= maple_keyb.o
 obj-$(CONFIG_KEYBOARD_BFIN)		+= bf54x-keys.o
 obj-$(CONFIG_KEYBOARD_SH_KEYSC)		+= sh_keysc.o
+obj-$(CONFIG_KEYBOARD_A9TC)		+= a9tc_keypad.o
diff --git a/drivers/input/keyboard/a9tc_keypad.c b/drivers/input/keyboard/a9tc_keypad.c
new file mode 100644
index 0000000..fa004f1
--- /dev/null
+++ b/drivers/input/keyboard/a9tc_keypad.c
@@ -0,0 +1,285 @@
+/*
+ *  linux/drivers/input/touchscreen/a9tc-ts.c
+ *
+ *  Copyright (C) 2008 NEC Electronics Corporation 2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <mach/hardware.h>
+
+#define A9TC_KP_NAME	"a9tc_key"
+#define A9TC_KP_DEF_SCAN_TIME	100	// msec
+
+#define A9TC_KP_SCAN_LOOP_TIME	30	// msec
+
+#define	KP_BASE		A9TC_FPGA_LCD_KEY
+#define KP_START	(1 << 8)
+#define KP_KEY_MASK(x)	((x) & 0x7f)
+
+static struct input_dev *inpdev = NULL;
+
+static void a9tc_kp_timer(unsigned long data);
+static struct timer_list a9tc_kp_scan_timer = {
+	.function = a9tc_kp_timer,
+	.data = 0,
+};
+
+static u32 scan_interval = A9TC_KP_DEF_SCAN_TIME;
+static u32 debug = 0;
+
+static u8 a9tc_kp_keycode[] = {
+	KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_ENTER, KEY_F1, KEY_BACK,
+};
+
+static u8 *code_name[] = {
+	"DOWN", "LEFT", "RIGHT", "UP",  "ENTER", "F1", "F2",
+};
+
+static int dummy_code[] = {
+	KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_0,
+	KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, 
+	KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, 
+	KEY_Y, KEY_Z, 
+	KEY_EQUAL, KEY_MINUS, KEY_TAB, KEY_SLASH, KEY_SPACE, KEY_KPPLUS, KEY_F1, KEY_BACKSPACE,
+	KEY_DOT, KEY_VOLUMEDOWN, KEY_VOLUMEUP
+};
+
+static u32 a9tc_kp_get_data(void)
+{
+	return KP_KEY_MASK(readl(KP_BASE));
+}
+
+static void a9tc_kp_report(u32 report, u32 status)
+{
+	int i;
+
+	if (!status)
+		return;
+
+	for (i = 0; i<ARRAY_SIZE(a9tc_kp_keycode); i++) {
+		if (status & (1 << i)) {
+			if (debug) {
+				printk("%s: code=%d %s\n", report ? "Push":"Rel", a9tc_kp_keycode[i], code_name[i]);
+			}
+			input_report_key(inpdev, a9tc_kp_keycode[i], report);
+		}
+	}
+}
+
+
+static void a9tc_kp_timer(unsigned long data)
+{
+	u32 push;
+	u32 tmp, tmp2, tmp3;
+	static u32 push_sts = 0;
+
+	push = a9tc_kp_get_data();
+
+	if (push == 0) {
+		if (push_sts) {
+			a9tc_kp_report(0, push_sts);
+		}
+		mod_timer(&a9tc_kp_scan_timer, jiffies + ((scan_interval*HZ) / 1000));
+		push_sts = 0;
+	} else {
+		tmp  = push_sts ^ push;
+		if (tmp) {
+			tmp2 = tmp & push_sts;
+			tmp3 = tmp & ~push_sts;
+			if (tmp2) {
+				a9tc_kp_report(0, tmp2);
+				push_sts &= ~tmp2;
+			}
+			if (tmp3) {
+				a9tc_kp_report(1, tmp3);
+				push_sts |= tmp3;
+			}
+		}
+		mod_timer(&a9tc_kp_scan_timer, jiffies + ((A9TC_KP_SCAN_LOOP_TIME*HZ) / 1000));
+	}
+}
+
+#define MAX_BUF 255
+
+static void repo_dummy(int code)
+{
+	input_report_key(inpdev, code, 1);
+	schedule_timeout(1);
+	input_report_key(inpdev, code, 0);
+}
+
+static int key_read_proc( char *buf, char **start, off_t offset, int count, int *eof, void *data )
+{
+	return 0;
+}
+
+static int key_write_proc( struct file *file, const char *buf, u_long count, void *data )
+{
+	char mybuf[MAX_BUF];
+	int i, ret;
+
+	if (count >= MAX_BUF)
+		return -EINVAL;
+
+	ret = copy_from_user(mybuf, buf, count);
+
+	for (i=0; i<count; i++) {
+		if (mybuf[i] == '\n' || mybuf[i] == '\0') {
+			break;
+		}
+		switch (mybuf[i]) {
+		case '1':  repo_dummy(KEY_1); break;
+		case '2':  repo_dummy(KEY_2); break;
+		case '3':  repo_dummy(KEY_3); break;
+		case '4':  repo_dummy(KEY_4); break;
+		case '5':  repo_dummy(KEY_5); break;
+		case '6':  repo_dummy(KEY_6); break;
+		case '7':  repo_dummy(KEY_7); break;
+		case '8':  repo_dummy(KEY_8); break;
+		case '9':  repo_dummy(KEY_9); break;
+		case '0':  repo_dummy(KEY_0); break;
+		case 'a':  repo_dummy(KEY_A); break;
+		case 'b':  repo_dummy(KEY_B); break;
+		case 'c':  repo_dummy(KEY_C); break;
+		case 'd':  repo_dummy(KEY_D); break;
+		case 'e':  repo_dummy(KEY_E); break;
+		case 'f':  repo_dummy(KEY_F); break;
+		case 'g':  repo_dummy(KEY_G); break;
+		case 'h':  repo_dummy(KEY_H); break;
+		case 'i':  repo_dummy(KEY_I); break;
+		case 'j':  repo_dummy(KEY_J); break;
+		case 'k':  repo_dummy(KEY_K); break;
+		case 'l':  repo_dummy(KEY_L); break;
+		case 'm':  repo_dummy(KEY_M); break;
+		case 'n':  repo_dummy(KEY_N); break;
+		case 'o':  repo_dummy(KEY_O); break;
+		case 'p':  repo_dummy(KEY_P); break;
+		case 'q':  repo_dummy(KEY_Q); break;
+		case 'r':  repo_dummy(KEY_R); break;
+		case 's':  repo_dummy(KEY_S); break;
+		case 't':  repo_dummy(KEY_T); break;
+		case 'u':  repo_dummy(KEY_U); break;
+		case 'v':  repo_dummy(KEY_V); break;
+		case 'w':  repo_dummy(KEY_W); break;
+		case 'x':  repo_dummy(KEY_X); break;
+		case 'y':  repo_dummy(KEY_Y); break;
+		case 'z':  repo_dummy(KEY_Z); break;
+		case '=':  repo_dummy(KEY_EQUAL); break;
+		case '-':  repo_dummy(KEY_MINUS); break;
+		case '\t':  repo_dummy(KEY_TAB); break;
+		case '/':  repo_dummy(KEY_SLASH); break;
+		case ' ':  repo_dummy(KEY_SPACE); break;
+		case '+':  repo_dummy(KEY_F1); break;
+		case ',':  repo_dummy(KEY_BACKSPACE); break;
+		case '.':  repo_dummy(KEY_DOT); break;
+		case '%':  repo_dummy(KEY_VOLUMEUP); break;
+		case '&':  repo_dummy(KEY_VOLUMEDOWN); break;
+		default:
+			return count;
+		}
+	}
+
+	return count;
+}
+
+
+static int a9tc_kp_probe(struct platform_device *dev)
+{
+	int i, ret;
+	struct proc_dir_entry *key_proc;
+	unsigned int val;
+
+	inpdev = input_allocate_device();
+	if (!inpdev) {
+		printk("%s: error allocating memory for input structure\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	init_timer(&a9tc_kp_scan_timer);
+
+	inpdev->name = A9TC_KP_NAME;
+	inpdev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
+
+	for (i = 0; i < ARRAY_SIZE(a9tc_kp_keycode); i++)
+		set_bit(a9tc_kp_keycode[i], inpdev->keybit);
+
+	for (i = 0; i < ARRAY_SIZE(dummy_code); i++) {
+		set_bit(dummy_code[i], inpdev->keybit);
+	}
+
+	clear_bit(0, inpdev->keybit);
+
+	ret = input_register_device(inpdev);
+	if (ret != 0) {
+		printk("%s: error registering with input system\n", __FUNCTION__);
+		input_free_device(inpdev);
+		return ret;
+	}
+
+	key_proc = create_proc_read_entry("key", 0, NULL, key_read_proc, NULL );
+	key_proc->write_proc = key_write_proc;
+
+	// H/W init
+	val = readl(KP_BASE);
+	val |= KP_START;
+	writel(val, KP_BASE);
+
+	mod_timer(&a9tc_kp_scan_timer, jiffies + ((scan_interval*HZ) / 1000));
+
+	return 0;
+}
+
+static int a9tc_kp_remove(struct platform_device *pdev)
+{
+	del_timer(&a9tc_kp_scan_timer);
+	input_unregister_device(inpdev);
+
+	return 0;
+}
+
+static struct platform_driver a9tc_kp_driver = {
+	.probe 		= a9tc_kp_probe,
+	.remove 	= a9tc_kp_remove,
+	.driver = {
+		.name	= A9TC_KP_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init a9tc_kp_init(void)
+{
+	return platform_driver_register(&a9tc_kp_driver);
+}
+
+static void __exit a9tc_kp_exit(void)
+{
+	platform_driver_unregister(&a9tc_kp_driver);
+}
+
+module_init(a9tc_kp_init);
+module_exit(a9tc_kp_exit);
+
+module_param(scan_interval, uint, 0644);
+MODULE_PARM_DESC(scan_interval, "scan interval time [ms]");
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Enable(1)/Disable(0) debug message");
+
+MODULE_AUTHOR("NECEL");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 3d1ab8f..5f99dbc 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -376,4 +376,14 @@ config TOUCHSCREEN_TOUCHIT213
 	  To compile this driver as a module, choose M here: the
 	  module will be called touchit213.
 
+config TOUCHSCREEN_A9TC
+	tristate "A9TC board touchscreen"
+	depends on ARCH_A9TC
+	 help
+	  Say Y here if you have an A9TC board using a FPGA touchscreen controller.
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called a9tc_ts.
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 15cf290..23bcc73 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -31,3 +31,4 @@ wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9705)	+= wm9705.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9712)	+= wm9712.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9713)	+= wm9713.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
+obj-$(CONFIG_TOUCHSCREEN_A9TC)	+= a9tc_ts.o
diff --git a/drivers/input/touchscreen/a9tc_ts.c b/drivers/input/touchscreen/a9tc_ts.c
new file mode 100644
index 0000000..6a07cc3
--- /dev/null
+++ b/drivers/input/touchscreen/a9tc_ts.c
@@ -0,0 +1,213 @@
+/*
+ *  linux/drivers/input/touchscreen/ne1-ts.c
+ *
+ *  Copyright (C) 2008 NEC Electronics Corporation 2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <mach/hardware.h>
+
+#define A9TC_TS_NAME	"a9tc_touch"
+
+#define A9TC_TS_DEF_SCAN_TIME	20	// msec
+
+#define TSP_BASE	A9TC_FPGA_LCD_PAD
+#define TSP_nIRQ	(1 << 31)
+#define TSP_START	(1 << 24)
+#define TSP_DONE	(1 << 23)
+#define TSP_Y		(1 << 20)
+#define TSP_X		(5 << 20)
+#define TSP_MODE	(1 << 19)	// 12bit mode
+#define TSP_SER		(1 << 18)
+#define TSP_PD		(1 << 16)
+#define TSP_DATA(x)	((x) & 0xfff)
+
+#define	MAX_12BIT	((1 << 12) - 1)
+#define X_MIN	0
+#define X_MAX	MAX_12BIT
+#define Y_MIN	0
+#define Y_MAX	MAX_12BIT
+
+
+static struct input_dev *inpdev = NULL;
+
+static int a9tc_ts_irq = IRQ_PAD;
+
+static void a9tc_ts_timer(unsigned long data);
+static struct timer_list a9tc_ts_scan_timer = {
+	.function = a9tc_ts_timer,
+	.data = 0,
+};
+
+static u32 scan_interval = A9TC_TS_DEF_SCAN_TIME;
+static u32 debug = 0;
+
+static inline int is_pen_down(void)
+{
+	if (readl(TSP_BASE) & TSP_nIRQ) {
+		return 0;
+	} else {
+		return 1;
+	}
+}
+
+static void a9tc_ts_get_data(u16 *data, int x)
+{
+	unsigned int val = TSP_MODE;
+
+	val |= x ? TSP_X : TSP_Y;
+	writel(val, TSP_BASE);
+	val |= TSP_START;
+	writel(val, TSP_BASE);
+	while ((readl(TSP_BASE) & TSP_DONE) == 0);
+	*data = TSP_DATA(readl(TSP_BASE));
+	val &= ~TSP_START;
+	writel(val, TSP_BASE);
+}
+
+
+static void a9tc_ts_timer(unsigned long data)
+{
+	u16 x = 0;
+	u16 y = 0;
+	u8 pen_down = 0;
+	static u8 prev_pen_down = 0;
+
+	if (is_pen_down()) {
+		a9tc_ts_get_data(&x, 1);
+		a9tc_ts_get_data(&y, 0);
+
+		/* Re-check */
+		if (is_pen_down()) {
+			pen_down = 1;
+		}
+	}
+
+	if (pen_down) {
+		if (prev_pen_down == 0) {
+			input_report_key(inpdev, BTN_TOUCH, 1);
+		}
+		input_report_abs(inpdev, ABS_X, x);
+		input_report_abs(inpdev, ABS_Y, y);
+		input_report_abs(inpdev, ABS_PRESSURE, 50);
+		input_sync(inpdev);
+
+		mod_timer(&a9tc_ts_scan_timer, jiffies + msecs_to_jiffies(scan_interval));
+	} else {
+		if (prev_pen_down) {
+			input_report_key(inpdev, BTN_TOUCH, 0);
+			input_report_abs(inpdev, ABS_PRESSURE, 0);
+			input_sync(inpdev);
+		}
+		enable_irq(a9tc_ts_irq);
+	}
+
+	if (debug) {
+		printk("%s: (%d:%d), (%x:%x)\n", (pen_down == 0) ? "UP":"DOWN" ,x ,y, x, y);
+	}
+
+	prev_pen_down = pen_down;
+}
+
+static irqreturn_t a9tc_ts_handler(int irq, void *dev_id)
+{
+	if (debug) {
+		printk("%s: irq handler called\n", __FUNCTION__);
+	}
+
+	disable_irq_nosync(a9tc_ts_irq);
+	mod_timer(&a9tc_ts_scan_timer, jiffies + msecs_to_jiffies(scan_interval));
+
+	return IRQ_HANDLED;
+}
+
+static int a9tc_ts_probe(struct platform_device *dev)
+{
+	int ret;
+
+	inpdev = input_allocate_device();
+	if (!inpdev) {
+		printk("%s: error allocating memory for input structure\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	init_timer(&a9tc_ts_scan_timer);
+
+	/* request irq */
+	if (request_irq(a9tc_ts_irq, a9tc_ts_handler, IRQF_DISABLED, A9TC_TS_NAME, NULL) < 0) {
+		printk("%s: failed to request_irq\n", __FUNCTION__);
+		input_free_device(inpdev);
+		return -EINVAL;
+	}
+
+	inpdev->name = A9TC_TS_NAME;
+	inpdev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	inpdev->keybit[BIT_WORD(BTN_TOUCH)] |= BIT_MASK(BTN_TOUCH);
+
+	/* value based on board measurement */
+	input_set_abs_params(inpdev, ABS_X, X_MIN, X_MAX, 0, 0);
+	input_set_abs_params(inpdev, ABS_Y, Y_MIN, Y_MAX, 0, 0);
+	input_set_abs_params(inpdev, ABS_PRESSURE, 0, 100, 0, 0);
+
+	ret = input_register_device(inpdev);
+	if (ret != 0) {
+		printk("%s: error registering with input system\n", __FUNCTION__);
+		free_irq(a9tc_ts_irq, NULL);
+		input_free_device(inpdev);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int a9tc_ts_remove(struct platform_device *pdev)
+{
+	input_unregister_device(inpdev);
+	free_irq(a9tc_ts_irq, NULL);
+
+	return 0;
+}
+
+static struct platform_driver a9tc_ts_driver = {
+	.probe 		= a9tc_ts_probe,
+	.remove 	= a9tc_ts_remove,
+	.driver = {
+		.name	= A9TC_TS_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init a9tc_ts_init(void)
+{
+	return platform_driver_register(&a9tc_ts_driver);
+}
+
+static void __exit a9tc_ts_exit(void)
+{
+	platform_driver_unregister(&a9tc_ts_driver);
+}
+
+module_init(a9tc_ts_init);
+module_exit(a9tc_ts_exit);
+
+module_param(scan_interval, uint, 0644);
+MODULE_PARM_DESC(scan_interval, "scan interval time [ms]");
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Enable(1)/Disable(0) debug message");
+
+MODULE_AUTHOR("NECEL");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index dfa585f..1939945 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -192,3 +192,8 @@ config MMC_TMIO
 	help
 	  This provides support for the SD/MMC cell found in TC6393XB,
 	  T7L66XB and also ipaq ASIC3
+
+config MMC_A9TC
+	tristate "A9TC MMC/SD function support"
+	depends on ARCH_A9TC
+
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index c794cc5..4dc9a61 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -22,4 +22,5 @@ obj-$(CONFIG_MMC_SPI)		+= mmc_spi.o
 obj-$(CONFIG_MMC_S3C)   	+= s3cmci.o
 obj-$(CONFIG_MMC_SDRICOH_CS)	+= sdricoh_cs.o
 obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
+obj-$(CONFIG_MMC_A9TC)		+= a9tc_mmc.o
 
diff --git a/drivers/mmc/host/a9tc_mmc.c b/drivers/mmc/host/a9tc_mmc.c
new file mode 100644
index 0000000..8515f38
--- /dev/null
+++ b/drivers/mmc/host/a9tc_mmc.c
@@ -0,0 +1,760 @@
+/*
+ *  File Name		: linux/drivers/mmc/host/a9tc_mmc.c
+ *  Function		: MMC
+ *  Release Version : Ver 1.00
+ *  Release Date	: 2009/07/07
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it under the terms of
+ *  the GNU General Public License as published by Free Softwere Foundation; either version 2
+ *  of License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <mach/hardware.h>
+
+#ifdef CONFIG_PM
+#include <linux/notifier.h>
+#include <linux/pm.h>
+#endif
+
+#include "a9tc_mmc.h"
+
+
+inline u32 a9tc_mmc_int_read(struct a9tc_mmc_host *host)
+{
+	u32 val;
+
+	val = readl(host->base + A9TC_NRMINT_STS) & 0xffff;
+	val |= (readl(host->base + A9TC_ERRINT_STS) & 0xffff) << 16;
+
+	return val;
+}
+inline void a9tc_mmc_int_write(struct a9tc_mmc_host *host, u32 val)
+{
+	writel(val & 0xffff, host->base + A9TC_NRMINT_STS);
+	writel((val >> 16) & 0xffff, host->base + A9TC_ERRINT_STS);
+}
+
+
+inline u32 a9tc_mmc_state_read(struct a9tc_mmc_host *host)
+{
+	u32 val;
+
+	val = readl(host->base + A9TC_STATE0) & 0xffff;
+	val |= (readl(host->base + A9TC_STATE1) & 0xffff) << 16;
+
+	return val;
+}
+
+inline void a9tc_mmc_int_mask_write(struct a9tc_mmc_host *host, u32 val)
+{
+	writel(val & 0xffff, host->base + A9TC_NRMINT_STSEN);
+	writel((val >> 16) & 0xffff, host->base + A9TC_ERRINT_STSEN);
+	writel(val & 0xffff, host->base + A9TC_NRMINT_SIGEN);
+	writel((val >> 16) & 0xffff, host->base + A9TC_ERRINT_SIGEN);
+}
+
+static void a9tc_mmc_reset(struct a9tc_mmc_host *host, u32 mask)
+{
+	writel(mask, host->base + A9TC_SOFTRST_TIMEOUT);
+
+	while (readl(host->base + A9TC_SOFTRST_TIMEOUT) & mask) {
+		mdelay(1);
+	}
+	writel(MMC_TOUT_COUNT_MAX, host->base + A9TC_SOFTRST_TIMEOUT);
+}
+
+static void a9tc_mmc_cpu_datasend(struct a9tc_mmc_host *host)
+{
+	int i, j;
+	u32 val;
+	u32 *data = (u32 *)(host->data_address[0]);
+	u32 mask, len = 0, addr_num = 0;
+
+	if (host->data->flags & MMC_DATA_READ) {
+		mask = MMC_STATE_RDEN;
+	} else {
+		mask = MMC_STATE_WREN;
+	}
+
+	if (host->data_len == 0) return;
+
+	for (j = 0; j < host->data->blocks; j++) {
+		while ((a9tc_mmc_state_read(host) & mask) == 0) {
+			udelay(10);
+		}
+
+		for (i = 0; i < host->data->blksz / sizeof(u32); i++) {
+			if (host->data->flags & MMC_DATA_READ) {
+				val = readl(host->base + A9TC_BUF0) & 0xffff;
+				val |= (readl(host->base + A9TC_BUF1) & 0xffff) << 16;
+				*data = val;
+			} else {
+				writel(*data & 0xffff , host->base + A9TC_BUF0);
+				writel((*data >> 16) & 0xffff , host->base + A9TC_BUF1);
+			}
+			data++;
+		}
+		len += host->data->blksz;
+		if (host->dma_len[addr_num] == len) {
+			addr_num++;
+			len = 0;
+			data = (u32 *)(host->data_address[addr_num]);
+		}
+	}
+
+	host->data_len = 0;
+/*
+	printk("%s: 0x%x 0x%x %d\n", __FUNCTION__,
+		readl(host->base + A9TC_BLKSIZE), readl(host->base + A9TC_BLKCOUNT), 
+		addr_num);
+*/
+}
+
+/*
+ * Notify the core about command completion
+ */
+static void a9tc_mmc_data_done(struct a9tc_mmc_host *host, struct mmc_command *cmd)
+{
+	struct mmc_data *data = host->data;
+
+	dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_num, host->dma_dir);
+
+	if (host->data->error == 0) {
+		host->data->bytes_xfered = data->blksz * data->blocks;
+	}
+
+	a9tc_mmc_reset(host, MMC_SRST_CMD | MMC_SRST_DAT);
+	del_timer(&host->timer);
+
+	host->data_len = 0;
+
+	host->data = NULL;
+	host->cmd = NULL;
+	host->req = NULL;
+	host->stop = NULL;
+
+	mmc_request_done(host->mmc, cmd->mrq);
+}
+
+/*
+ * Notify the core about command completion
+ */
+static void a9tc_mmc_cmd_done(struct a9tc_mmc_host *host, struct mmc_command *cmd)
+{
+	u32 val;
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			/* response type 2 */
+			val = readl(host->base+ A9TC_RSP0) & 0xffff;
+			cmd->resp[3] = val << 8;
+			val = readl(host->base+ A9TC_RSP1) & 0xffff;
+			cmd->resp[3] |= (val & 0xff) << 24;
+			cmd->resp[2] = val >> 8;
+			val = readl(host->base+ A9TC_RSP2) & 0xffff;
+			cmd->resp[2] |= val << 8;
+			val = readl(host->base+ A9TC_RSP3) & 0xffff;
+			cmd->resp[2] |= (val & 0xff) << 24;
+			cmd->resp[1] = val >> 8;
+			val = readl(host->base+ A9TC_RSP4) & 0xffff;
+			cmd->resp[1] |= val << 8;
+			val = readl(host->base+ A9TC_RSP5) & 0xffff;
+			cmd->resp[1] |= (val & 0xff) << 24;
+			cmd->resp[0] = val >> 8;
+			val = readl(host->base+ A9TC_RSP6) & 0xffff;
+			cmd->resp[0] |= val << 8;
+			val = readl(host->base+ A9TC_RSP7) & 0xffff;
+			cmd->resp[0] |= (val & 0xff) << 24;
+			dev_dbg(mmc_dev(host->mmc), "%s: CMD=%d RSP %x %x %x %x\n", __FUNCTION__, cmd->opcode, cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
+		} else {
+			/* response types 1, 1b, 3, 4, 5, 6 */
+			cmd->resp[0] = readl(host->base + A9TC_RSP0) & 0xffff;
+			cmd->resp[0] |= (readl(host->base + A9TC_RSP1) & 0xffff)<< 16;
+			dev_dbg(mmc_dev(host->mmc), "%s: CMD=%d RSP %x\n", __FUNCTION__, cmd->opcode, cmd->resp[0]);
+		}
+	}
+
+	if (host->app_mode) {
+		host->app_mode = 0;
+	} else if (cmd->opcode == 55) {
+		host->app_mode = 1;
+	}
+
+	if (host->data == NULL) {
+		a9tc_mmc_reset(host, MMC_SRST_CMD | MMC_SRST_DAT);
+		del_timer(&host->timer);
+		host->req = NULL;
+		host->cmd = NULL;
+		mmc_request_done(host->mmc, cmd->mrq);
+	} else if (host->data->error) {
+		a9tc_mmc_data_done(host, host->cmd);
+	}
+}
+
+/*
+ * Configure the Responce type
+ */
+static void a9tc_mmc_start_cmd(struct a9tc_mmc_host *host, struct mmc_command *cmd, u32 cmddat)
+{
+	u32 resp = mmc_resp_type(cmd);
+	u32 val;
+
+	val = a9tc_mmc_state_read(host);
+	if (val & (MMC_STATE_CMD_INHIBIT | MMC_STATE_DAT_INHIBIT)) {
+		printk("state=%x\n", a9tc_mmc_state_read(host));
+	}
+
+	mod_timer(&host->timer, jiffies + msecs_to_jiffies(500));
+
+	host->cmd = cmd;
+
+	cmddat |= MMC_CMD_INDEX(cmd->opcode);
+
+	if (resp & MMC_RSP_CRC) {
+		cmddat |= MMC_CMD_CRC_CHK;
+	}
+	if (resp & MMC_RSP_OPCODE) {
+		cmddat |= MMC_CMD_INDEX_CHK;
+	}
+
+	if (resp & MMC_RSP_136) {
+		cmddat |= MMC_CMD_RSP_136;
+	} else if (resp & MMC_RSP_BUSY){
+		cmddat |= MMC_CMD_RSP_48B;
+	} else if (resp & MMC_RSP_PRESENT){
+		cmddat |= MMC_CMD_RSP_48;
+	}
+
+	writel(cmd->arg & 0xffff, host->base + A9TC_ARG0);
+	writel(cmd->arg >> 16,    host->base + A9TC_ARG1);
+
+//	dev_dbg(mmc_dev(host->mmc), "CMD %d %x %x %x %x\n",
+//			cmd->opcode, cmd->arg, cmd->flags, cmd->retries, cmddat);
+//	printk("CMD %d %x %x %x %x\n",
+//			cmd->opcode, cmd->arg, cmd->flags, cmd->retries, cmddat);
+
+	// Send command
+	writel(cmddat, host->base + A9TC_COMMAND);
+}
+
+/*
+ * MMC controller IRQ handler
+ */
+static irqreturn_t a9tc_mmc_irq(int irq, void *dev_id)
+{
+	struct a9tc_mmc_host *host = (struct a9tc_mmc_host *)dev_id;
+	u32 status, end_trans = 0;
+
+	status = a9tc_mmc_int_read(host);
+
+//	printk("%s: %x %x\n", __FUNCTION__, status, host->int_mask);
+
+	a9tc_mmc_int_write(host, status);
+
+	if (status & MMC_INT_CARD_INS) {
+		host->connect = 1;
+		mmc_detect_change(host->mmc, msecs_to_jiffies(50));
+	}
+	if (status & MMC_INT_CARD_REM) {
+		host->connect = 0;
+		mmc_detect_change(host->mmc, msecs_to_jiffies(50));
+	}
+
+	if (host->data == NULL) {
+		if (host->cmd == NULL) {
+			return IRQ_HANDLED;
+		}
+	}
+
+	if (status & MMC_INT_ALLERR) {
+		end_trans = 1;
+		if (status & MMC_INT_CMD_TOUT) {
+			dev_dbg(mmc_dev(host->mmc), "%s: CMD=%d CMD Timeout\n", __FUNCTION__, host->cmd->opcode);
+			host->cmd->error = -ETIMEDOUT;
+		} else if (status & MMC_INT_CMD_CRC) {
+			dev_dbg(mmc_dev(host->mmc), "%s: CMD=%d CRC error\n", __FUNCTION__, host->cmd->opcode);
+			host->cmd->error = -EILSEQ;
+		} else {
+			dev_dbg(mmc_dev(host->mmc), "%s: CMD=%d Other error.(0x%x)\n", __FUNCTION__, host->cmd->opcode, status);
+			host->cmd->error = -EILSEQ;
+		}
+		if (host->data) {
+			if (status & MMC_INT_DATA_TOUT) {
+				dev_dbg(mmc_dev(host->mmc), "%s: CMD=%d DATA Timeout\n", __FUNCTION__, host->cmd->opcode);
+				host->data->error = -ETIMEDOUT;
+			} else if (status & MMC_INT_CMD_CRC) {
+				dev_dbg(mmc_dev(host->mmc), "%s: CMD=%d CRC error\n", __FUNCTION__, host->cmd->opcode);
+				host->data->error = -EILSEQ;
+			} else {
+				dev_dbg(mmc_dev(host->mmc), "%s: CMD=%d Other error.(0x%x)\n", __FUNCTION__, host->cmd->opcode, status);
+				host->data->error = -EILSEQ;
+			}
+		}
+	}
+
+	if ((status & MMC_INT_CMDCOMP) || end_trans) {
+		a9tc_mmc_cmd_done(host, host->cmd);
+	}
+
+	if (end_trans == 1) {
+		return IRQ_HANDLED;
+	}
+	if (status & (MMC_INT_RREADY | MMC_INT_WREADY)) {
+		a9tc_mmc_cpu_datasend(host);
+	}
+	if (status & MMC_INT_TRANCOMP) {
+		a9tc_mmc_data_done(host, host->cmd);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void a9tc_timeout_timer(unsigned long data)
+{
+	struct a9tc_mmc_host *host = (struct a9tc_mmc_host*)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (host->req) {
+		printk(KERN_ERR "%s: Timeout waiting for hardware "
+			"interrupt. %d\n", mmc_hostname(host->mmc), smp_processor_id());
+
+		if (host->data) {
+			host->data->error = -ETIMEDOUT;
+			a9tc_mmc_data_done(host, host->cmd);
+		} else {
+			if (host->cmd)
+				host->cmd->error = -ETIMEDOUT;
+			else
+				host->req->cmd->error = -ETIMEDOUT;
+			a9tc_mmc_cmd_done(host, host->cmd);
+		}
+	}
+
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+/*
+ * Configure block leangth for MMC/SD cards and intiate the transfer.
+ */
+static void a9tc_mmc_setup_data(struct a9tc_mmc_host *host, struct mmc_data *data)
+{
+	int i;
+
+	host->data = data;
+
+	host->data_len = data->blksz * data->blocks;
+
+	dev_dbg(mmc_dev(host->mmc), "MMC: DATA: size=%d num=%d flags=0x%x\n", data->blksz, data->blocks, data->flags);
+
+	writel(data->blksz,  host->base + A9TC_BLKSIZE);
+	writel(data->blocks, host->base + A9TC_BLKCOUNT);
+
+	host->dma_dir = (data->flags & MMC_DATA_WRITE) ?
+				DMA_TO_DEVICE : DMA_FROM_DEVICE;
+	host->dma_num = dma_map_sg(mmc_dev(host->mmc), data->sg,
+				data->sg_len, host->dma_dir);
+
+	for (i = 0; i < host->dma_num; i++) {
+		host->data_address[i] = (unsigned int)phys_to_virt(sg_dma_address(&data->sg[0]));
+		host->dma_len[i] = sg_dma_len(&data->sg[i]);
+	}
+}
+
+/*
+ * Request function. for read/write operation
+ */
+static void a9tc_mmc_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct a9tc_mmc_host *host = mmc_priv(mmc);
+	u32 cmddat = 0;
+	u32 mode = 0;
+	unsigned long flag;
+
+	spin_lock_irqsave(&host->lock, flag);
+
+	if (host->connect == 0) {
+		req->cmd->error = -ENOMEDIUM;
+		spin_unlock_irqrestore(&host->lock, flag);
+		mmc_request_done(mmc, req);
+		return;
+	}
+
+	host->req = req;
+	host->stop = req->stop;
+
+	if (req->data) {
+		a9tc_mmc_setup_data(host, req->data);
+
+		cmddat |= MMC_CMD_DATA;
+		mode |= MMC_MODE_BLKCOUNT_EN;
+
+		if (host->data->flags & MMC_DATA_READ) {
+			mode |= MMC_MODE_READ;
+		}
+
+		if (host->data->blocks > 1) {
+			mode |= MMC_MODE_MULTI | MMC_MODE_BLKCOUNT_EN;
+		}
+	}
+	if (host->stop) {
+		mode |= MMC_MODE_AUTO_CMD12_EN;
+	}
+
+	writel(mode, host->base + A9TC_MODE);
+
+	a9tc_mmc_start_cmd(host, req->cmd, cmddat);
+
+	spin_unlock_irqrestore(&host->lock, flag);
+}
+
+static void a9tc_mmc_power(struct a9tc_mmc_host *host, u32 power)
+{
+	u32 val;
+
+	val = readl(host->base + A9TC_POWER_HOST);
+
+	switch (power) {
+	case 0:
+//		val &= ~(MMC_POWER_POWER | MMC_POWER_VOLT_33);
+		val = 0;
+		break;
+	default:
+		val |= (MMC_POWER_POWER | MMC_POWER_VOLT_33);
+	}
+	writel(val, host->base + A9TC_POWER_HOST);
+}
+
+/*
+ * Configuring clock values.
+ */
+static void a9tc_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct a9tc_mmc_host *host = mmc_priv(mmc);
+	u32 val, wDiv;
+
+//	printk("%s: %d %x %d %d %d\n", __FUNCTION__,
+//		ios->clock, ios->power_mode, ios->bus_width, ios->timing, ios->vdd);
+
+	spin_lock(&host->lock);
+
+	val = readl(host->base + A9TC_POWER_HOST);
+	if (ios->bus_width == MMC_BUS_WIDTH_4) {
+		host->bus_width = MMC_BUS_WIDTH_4;
+		val |= MMC_HOST_WIDTH;
+	} else {
+		host->bus_width = MMC_BUS_WIDTH_1;
+		val &= ~MMC_HOST_WIDTH;
+	}
+	if (ios->timing == MMC_TIMING_SD_HS) {
+		val |= MMC_HOST_HS;
+	} else {
+		val &= ~MMC_HOST_HS;
+	}
+	writel(val, host->base + A9TC_POWER_HOST);
+
+	if ((ios->clock != host->clock) && (host->power_mode != MMC_POWER_OFF)) {
+		/* Stop clock */
+		writel(0, host->base + A9TC_CLKCTRL);
+
+		if (ios->clock != 0) {
+			if (ios->clock > host->max_clk / 2) {
+				wDiv = MMC_CLK_CLKDIV1;
+			} else if (ios->clock >  host->max_clk / 4) {
+				wDiv = MMC_CLK_CLKDIV2;
+			} else if (ios->clock >  host->max_clk / 8) {
+				wDiv = MMC_CLK_CLKDIV4;
+			} else if (ios->clock >  host->max_clk / 16) {
+				wDiv = MMC_CLK_CLKDIV8;
+			} else if (ios->clock >  host->max_clk / 32) {
+				wDiv = MMC_CLK_CLKDIV16;
+			} else if (ios->clock >  host->max_clk / 64) {
+				wDiv = MMC_CLK_CLKDIV32;
+			} else if (ios->clock >  host->max_clk / 128) {
+				wDiv = MMC_CLK_CLKDIV64;
+			} else if (ios->clock >  host->max_clk / 256) {
+				wDiv = MMC_CLK_CLKDIV128;
+			} else {
+				wDiv = MMC_CLK_CLKDIV256;
+			}
+			wDiv |= MMC_CLK_CLKEN;
+			writel(wDiv, host->base + A9TC_CLKCTRL);
+
+			while (!((wDiv = readl(host->base + A9TC_CLKCTRL)) & MMC_CLK_CLKSTA)) {
+				mdelay(1);
+			}
+
+			wDiv |= MMC_CLK_SDCLKEN;
+			writel(wDiv, host->base + A9TC_CLKCTRL);
+		}
+		host->clock = ios->clock;
+	}
+
+	if (host->power_mode != ios->power_mode) {
+		switch (ios->power_mode) {
+		case MMC_POWER_OFF:
+			host->clock = 0;
+			a9tc_mmc_power(host, 0);
+			dev_dbg(mmc_dev(host->mmc), "power off\n");
+       		break;
+		case MMC_POWER_UP:
+			a9tc_mmc_power(host, ios->vdd);
+			dev_dbg(mmc_dev(host->mmc), "power up\n");
+       		break;
+		case MMC_POWER_ON:
+			dev_dbg(mmc_dev(host->mmc), "power on\n");
+       		break;
+		}
+		host->power_mode = ios->power_mode;
+	}
+
+	spin_unlock(&host->lock);
+}
+
+static int a9tc_mmc_card_readonly(struct mmc_host *mmc)
+{
+	struct a9tc_mmc_host *host = mmc_priv(mmc);
+	u32 val;
+
+	val = a9tc_mmc_state_read(host);
+	return !(val & MMC_STATE_WP);
+}
+
+static struct mmc_host_ops a9tc_mmc_ops = {
+	.request	= a9tc_mmc_request,
+	.set_ios	= a9tc_mmc_set_ios,
+	.get_ro		= a9tc_mmc_card_readonly,
+};
+
+static int a9tc_mmc_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = NULL;
+	struct a9tc_mmc_host *host = NULL;
+	struct resource *res;
+	int ret = 0;
+	int irq;
+	unsigned int caps, max_blen;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		ret = -ENXIO;
+		goto err;
+	}
+
+	mmc = mmc_alloc_host(sizeof(struct a9tc_mmc_host), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	host      = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->irq = irq;
+	host->power_mode = MMC_POWER_OFF;
+
+	host->base = ioremap(res->start, SZ_4K);
+	if (!host->base) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	caps = readl(host->base + A9TC_CONF0) & 0xffff;
+	caps |= (readl(host->base + A9TC_CONF1) & 0xffff) << 16;
+
+	host->max_clk = MMC_CONF_BCLK_FREQ(caps) * 1000000;
+
+	mmc->ops   = &a9tc_mmc_ops;
+	mmc->f_min = host->max_clk / 256;
+	mmc->f_max = host->max_clk;
+	mmc->caps = MMC_CAP_4_BIT_DATA;
+	if (caps & MMC_CONF_HS) {
+		mmc->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;
+	}
+	mmc->ocr_avail = 0;
+	if (caps & MMC_CONF_V33)
+		mmc->ocr_avail |= MMC_VDD_32_33|MMC_VDD_33_34;
+	if (caps & MMC_CONF_V30)
+		mmc->ocr_avail |= MMC_VDD_29_30|MMC_VDD_30_31;
+	if (caps & MMC_CONF_V18)
+		mmc->ocr_avail |= MMC_VDD_165_195;
+
+	/* MMC core transfer sizes tunable parameters */
+	max_blen = MMC_CONF_MAX_BLEN(caps);
+	mmc->max_blk_size = 512 << max_blen;
+	mmc->max_blk_count = 65535;
+#if 0
+	mmc->max_hw_segs   = A9TC_MAX_SEGS;
+	mmc->max_phys_segs = A9TC_MAX_SEGS;
+	mmc->max_seg_size  = A9TC_MAX_SEGS * mmc->max_blk_size;
+	mmc->max_req_size  = A9TC_MAX_SEGS * mmc->max_blk_size;
+#endif
+
+	spin_lock_init(&host->lock);
+
+	/* Init H/W  */
+	a9tc_mmc_reset(host, MMC_SRST_ALL);
+	a9tc_mmc_int_mask_write(host, MMC_INT_MASK);
+	host->int_mask = MMC_INT_MASK;
+
+	if (a9tc_mmc_state_read(host) & MMC_STATE_INSERT) {
+		host->connect = 1;
+	} else {
+		host->connect = 0;
+	}
+
+	/* Request IRQ for MMC operations */
+	ret = request_irq(host->irq, a9tc_mmc_irq, 0, pdev->name, host);
+	if (ret) {
+		dev_dbg(mmc_dev(host->mmc), "Unable to IRQ");
+		goto err_irq;
+	}
+
+	setup_timer(&host->timer, a9tc_timeout_timer, (unsigned long)host);
+
+	platform_set_drvdata(pdev, host);
+	mmc_add_host(mmc);
+
+	return 0;
+
+err_irq:
+	iounmap(host->base);
+err:
+	printk("%s: error!!(%d)\n", __FUNCTION__, ret);
+	if (mmc)
+		mmc_free_host(mmc);
+	return ret;
+
+}
+
+static int a9tc_mmc_remove(struct platform_device *pdev)
+{
+	struct a9tc_mmc_host *host = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	if (host) {
+		flush_scheduled_work();
+
+		del_timer_sync(&host->timer);
+
+		mmc_remove_host(host->mmc);
+
+		a9tc_mmc_power(host, 0);
+
+		free_irq(host->irq, host);
+
+		iounmap(host->base);
+
+		mmc_free_host(host->mmc);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int a9tc_mmc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct a9tc_mmc_host *host = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	if (host && host->suspended)
+		return 0;
+
+	if (host) {
+		ret = mmc_suspend_host(host->mmc, state);
+		if (ret == 0) {
+			host->suspended = 1;
+		}
+	}
+	return ret;
+}
+
+/* Routine to resume the MMC device */
+static int a9tc_mmc_resume(struct platform_device *pdev)
+{
+	struct a9tc_mmc_host *host = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	if (host && !host->suspended)
+		return 0;
+
+	if (host) {
+		ret = mmc_resume_host(host->mmc);
+		if (ret == 0) {
+			host->suspended = 0;
+		}
+	}
+	return ret;
+}
+#else
+#define a9tc_mmc_suspend	NULL
+#define a9tc_mmc_resume	NULL
+#endif
+
+static struct platform_driver a9tc_mmc_driver = {
+	.probe		= a9tc_mmc_probe,
+	.remove		= a9tc_mmc_remove,
+	.suspend	= a9tc_mmc_suspend,
+	.resume		= a9tc_mmc_resume,
+	.driver		= {
+		.name = DRIVER_NAME,
+	},
+};
+
+static int __init a9tc_mmc_init(void)
+{
+	/* Register the MMC driver */
+	if (platform_driver_register(&a9tc_mmc_driver)) {
+		printk(KERN_ERR ": Failed to register MMC driver\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit a9tc_mmc_cleanup(void)
+{
+	/* Unregister MMC driver */
+	platform_driver_unregister(&a9tc_mmc_driver);
+}
+
+module_init(a9tc_mmc_init);
+module_exit(a9tc_mmc_cleanup);
+
+MODULE_DESCRIPTION("A9TC Multimedia Card driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(DRIVER_NAME);
+MODULE_AUTHOR("NEC Electronics");
diff --git a/drivers/mmc/host/a9tc_mmc.h b/drivers/mmc/host/a9tc_mmc.h
new file mode 100644
index 0000000..87a9679
--- /dev/null
+++ b/drivers/mmc/host/a9tc_mmc.h
@@ -0,0 +1,221 @@
+/*
+ *  File Name		: linux/drivers/mmc/host/a9tc_mmc.h
+ *  Function		: MMC
+ *  Release Version : Ver 1.00
+ *  Release Date	: 2009/07/07
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it under the terms of
+ *  the GNU General Public License as published by Free Softwere Foundation; either version 2
+ *  of License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __DRIVERS_MMC_NE1_MMC_H
+#define __DRIVERS_MMC_NE1_MMC_H
+
+#define DRIVER_NAME	"a9tc_mmc"
+
+/* MMC Registers */
+#define A9TC_BLKSIZE		(0x008)
+#define A9TC_BLKCOUNT		(0x00C)
+#define A9TC_ARG0			(0x010)
+#define A9TC_ARG1			(0x014)
+#define A9TC_MODE			(0x018)
+#define A9TC_COMMAND		(0x01C)
+#define A9TC_RSP0			(0x020)
+#define A9TC_RSP1			(0x024)
+#define A9TC_RSP2			(0x028)
+#define A9TC_RSP3			(0x02C)
+#define A9TC_RSP4			(0x030)
+#define A9TC_RSP5			(0x034)
+#define A9TC_RSP6			(0x038)
+#define A9TC_RSP7			(0x03C)
+#define A9TC_BUF0			(0x040)
+#define A9TC_BUF1			(0x044)
+#define A9TC_STATE0			(0x048)
+#define A9TC_STATE1			(0x04C)
+#define A9TC_POWER_HOST		(0x050)
+#define A9TC_WAKEUP_BLKGAP	(0x054)
+#define A9TC_CLKCTRL		(0x058)
+#define A9TC_SOFTRST_TIMEOUT	(0x05C)
+#define A9TC_NRMINT_STS		(0x060)
+#define A9TC_ERRINT_STS		(0x064)
+#define A9TC_NRMINT_STSEN	(0x068)
+#define A9TC_ERRINT_STSEN	(0x06C)
+#define A9TC_NRMINT_SIGEN	(0x070)
+#define A9TC_ERRINT_SIGEN	(0x074)
+#define A9TC_CMD12_ERR		(0x078)
+#define A9TC_CONF0			(0x080)
+#define A9TC_CONF1			(0x084)
+#define A9TC_MAXREG0		(0x090)
+#define A9TC_MAXREG1		(0x094)
+#define A9TC_CMD12_ERR_FORCE	(0x0A0)
+#define A9TC_ERRINT_FORCE	(0x0A4)
+#define A9TC_HOSTVER		(0x1FC)
+
+
+/* Mode */
+#define MMC_MODE_BLKCOUNT_EN	(1 << 1)
+#define MMC_MODE_AUTO_CMD12_EN	(1 << 2)
+#define MMC_MODE_READ	(1 << 4)
+#define MMC_MODE_MULTI	(1 << 5)
+
+/* Command */
+#define MMC_CMD_RSP_NONE	(0 << 0)
+#define MMC_CMD_RSP_136		(1 << 0)
+#define MMC_CMD_RSP_48		(2 << 0)
+#define MMC_CMD_RSP_48B		(3 << 0)
+#define MMC_CMD_CRC_CHK		(1 << 3)
+#define MMC_CMD_INDEX_CHK	(1 << 4)
+#define MMC_CMD_DATA		(1 << 5)
+#define MMC_CMD_NORMAL		(0 << 6)
+#define MMC_CMD_SUSPEND		(1 << 6)
+#define MMC_CMD_RESUME		(2 << 6)
+#define MMC_CMD_ACMD		(3 << 6)
+#define MMC_CMD_INDEX(x)	((x & 0x3f) << 8)
+
+/* State */
+#define MMC_STATE_CMD_INHIBIT	(1 << 0)
+#define MMC_STATE_DAT_INHIBIT	(1 << 1)
+#define MMC_STATE_DAT_ACTIVE	(1 << 2)
+#define MMC_STATE_WR_ACTIVE		(1 << 8)
+#define MMC_STATE_RD_ACTIVE		(1 << 9)
+#define MMC_STATE_WREN			(1 << 10)
+#define MMC_STATE_RDEN			(1 << 11)
+#define MMC_STATE_INSERT		(1 << 16)
+#define MMC_STATE_STABLE		(1 << 17)
+#define MMC_STATE_CD			(1 << 18)
+#define MMC_STATE_WP			(1 << 19)
+
+/* Power & Host */
+#define MMC_HOST_LED	(1 << 0)
+#define MMC_HOST_WIDTH	(1 << 1)
+#define MMC_HOST_HS		(1 << 2)
+#define MMC_HOST_MMC8B	(1 << 5)
+#define MMC_HOST_CDTL	(1 << 6)
+#define MMC_HOST_CDSEL	(1 << 7)
+#define MMC_POWER_POWER		(1 << 8)
+#define MMC_POWER_VOLT_18	(5 << 9)
+#define MMC_POWER_VOLT_30	(6 << 9)
+#define MMC_POWER_VOLT_33	(7 << 9)
+
+/* Wakeup & Gap */
+#define MMC_GAP_STOP_AT_BG		(1 << 0)
+#define MMC_GAP_CONTINU_REQ		(1 << 1)
+#define MMC_GAP_READ_WAIT		(1 << 2)
+#define MMC_GAP_BLKGAP_INT_EN	(1 << 3)
+#define MMC_WAKEUP_WUEN0		(1 << 8)
+#define MMC_WAKEUP_WUEN1		(1 << 9)
+#define MMC_WAKEUP_WUEN2		(1 << 10)
+
+/* Clock */
+#define MMC_CLK_CLKEN		(1 << 0)
+#define MMC_CLK_CLKSTA		(1 << 1)
+#define MMC_CLK_SDCLKEN		(1 << 2)
+#define MMC_CLK_CLKDIV1		(0x00 << 8)
+#define MMC_CLK_CLKDIV2		(0x01 << 8)
+#define MMC_CLK_CLKDIV4		(0x02 << 8)
+#define MMC_CLK_CLKDIV8		(0x04 << 8)
+#define MMC_CLK_CLKDIV16	(0x08 << 8)
+#define MMC_CLK_CLKDIV32	(0x10 << 8)
+#define MMC_CLK_CLKDIV64	(0x20 << 8)
+#define MMC_CLK_CLKDIV128	(0x40 << 8)
+#define MMC_CLK_CLKDIV256	(0x80 << 8)
+
+/* SoftReset & Timeout */
+#define MMC_TOUT_COUNT_MIN		(0 << 0)
+#define MMC_TOUT_COUNT_MAX		(0xE << 0)
+#define MMC_SRST_ALL		(1 << 8)
+#define MMC_SRST_CMD		(1 << 9)
+#define MMC_SRST_DAT		(1 << 10)
+
+/* Interrupts */
+#define MMC_INT_CMDCOMP		(1 << 0)
+#define MMC_INT_TRANCOMP	(1 << 1)
+#define MMC_INT_BGE			(1 << 2)
+#define MMC_INT_DMA			(1 << 3)
+#define MMC_INT_WREADY		(1 << 4)
+#define MMC_INT_RREADY		(1 << 5)
+#define MMC_INT_CARD_INS	(1 << 6)
+#define MMC_INT_CARD_REM	(1 << 7)
+#define MMC_INT_SDIO_INT	(1 << 8)
+#define MMC_INT_ERR			(1 << 15)
+#define MMC_INT_CMD_TOUT	(1 << 16)
+#define MMC_INT_CMD_CRC		(1 << 17)
+#define MMC_INT_CMD_END		(1 << 18)
+#define MMC_INT_CMD_INDEX	(1 << 19)
+#define MMC_INT_DATA_TOUT	(1 << 20)
+#define MMC_INT_DATA_CRC	(1 << 21)
+#define MMC_INT_DATA_END	(1 << 22)
+#define MMC_INT_CMD12_ERR	(1 << 24)
+
+#define MMC_INT_ALLERR	(0x017f8000)
+#define MMC_INT_MASK	(MMC_INT_ALLERR | MMC_INT_CARD_INS | MMC_INT_CARD_REM | \
+	MMC_INT_CMDCOMP | MMC_INT_TRANCOMP | MMC_INT_WREADY | MMC_INT_RREADY)
+
+/* Conf */
+#define MMC_CONF_TCLK_FREQ(x)	((x) & 0x3F)
+#define MMC_CONF_BCLK_FREQ(x)	(((x) >> 8) & 0x3F)
+#define MMC_CONF_MAX_BLEN(x)	(((x) >> 16) & 0x02)
+#define MMC_CONF_MMC8	(1 << 18)
+#define MMC_CONF_ADMA2	(1 << 19)
+#define MMC_CONF_ADMA1	(1 << 20)
+#define MMC_CONF_HS		(1 << 21)
+#define MMC_CONF_DMA	(1 << 22)
+#define MMC_CONF_SUSREG	(1 << 23)
+#define MMC_CONF_V33	(1 << 24)
+#define MMC_CONF_V30	(1 << 25)
+#define MMC_CONF_V18	(1 << 26)
+#define MMC_CONF_B64	(1 << 28)
+
+
+#define A9TC_MAX_SEGS	128	// MAX 64KByte
+
+/* Private structure */
+struct a9tc_mmc_host {
+	struct	device		*dev;
+	struct	mmc_host	*mmc;
+	struct	mmc_request	*req;
+	struct	mmc_command	*cmd;
+	struct	mmc_data	*data;
+	struct	mmc_command	*stop;
+
+	void __iomem		*base;
+
+	u32 data_address[A9TC_MAX_SEGS];
+	u32 dma_len[A9TC_MAX_SEGS];
+	int dma_dir;
+	int dma_num;
+
+	struct	mutex		mutex;
+	spinlock_t		lock;
+
+	u8		bus_width;
+	u8		app_mode;
+	u32		power_mode;
+	u32		clock;
+	u32		max_clk;
+
+	u32		int_mask;
+
+	u32		data_len;
+
+	int 	connect;
+	int		suspended;
+	int		irq;
+
+	struct timer_list	timer;
+};
+
+#endif /* __DRIVERS_MMC_NE1_MMC_H */
diff --git a/drivers/net/smc911x.c b/drivers/net/smc911x.c
index 9a16a79..0575514 100644
--- a/drivers/net/smc911x.c
+++ b/drivers/net/smc911x.c
@@ -1908,6 +1908,18 @@ static int __devinit smc911x_probe(struct net_device *dev)
 
 	/* Get the MAC address */
 	SMC_GET_MAC_ADDR(lp, dev->dev_addr);
+#ifdef CONFIG_ARCH_A9TC
+	if ((dev->dev_addr[0] == 0xff && dev->dev_addr[1] == 0xff) ||
+		(dev->dev_addr[0] == 0x11)) {
+		printk("%s: Change mac address %x %x\n", CARDNAME, dev->dev_addr[0], dev->dev_addr[1]);
+		dev->dev_addr[0] = 0x00;
+		dev->dev_addr[1] = 0x11;
+		dev->dev_addr[2] = 0x22;
+		dev->dev_addr[3] = 0x33;
+		dev->dev_addr[4] = 0x44;
+		dev->dev_addr[5] = 0x55;
+	}
+#endif
 
 	/* now, reset the chip, and put it into a known state */
 	smc911x_reset(dev);
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 123092d..7f46f66 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -497,6 +497,12 @@ config RTC_DRV_WM8350
 	  This driver can also be built as a module. If so, the module
 	  will be called "rtc-wm8350".
 
+config RTC_DRV_A9TC
+	tristate "A9TC RTC"
+	depends on RTC_CLASS && ARCH_A9TC
+	help
+	  Include support for the A9TC RTC.
+
 comment "on-CPU RTC drivers"
 
 config RTC_DRV_OMAP
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 6e79c91..3897ed7 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -70,3 +70,4 @@ obj-$(CONFIG_RTC_DRV_V3020)	+= rtc-v3020.o
 obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41xx.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_A9TC)	+= rtc-a9tc.o
diff --git a/drivers/rtc/rtc-a9tc.c b/drivers/rtc/rtc-a9tc.c
new file mode 100644
index 0000000..51c37ff
--- /dev/null
+++ b/drivers/rtc/rtc-a9tc.c
@@ -0,0 +1,559 @@
+/*
+ * TI OMAP1 Real Time Clock interface for Linux
+ *
+ * Copyright (C) 2003 MontaVista Software, Inc.
+ * Author: George G. Davis <gdavis@mvista.com> or <source@mvista.com>
+ *
+ * Copyright (C) 2006 David Brownell (new RTC framework)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+
+#ifndef BCD2BIN
+#define BCD2BIN(val)	bcd2bin(val)
+#endif
+#ifndef BIN2BCD
+#define BIN2BCD(val)	bin2bcd(val)
+#endif
+
+#define RTC_TIMEOUT		1000
+#define RTC_DELAY_TIME	100	// 100usec
+
+static DEFINE_SPINLOCK(a9tc_rtc_lock);
+
+#define RTC_BASE	IO_ADDRESS(A9TC_FPGA_BASE + 0x24)
+#define RTC_START	(1 << 23)
+#define RTC_BUSY	(1 << 22)
+#define RTC_DONE	(1 << 21)
+#define RTC_RW		(1 << 20)
+#define RTC_A(x)	((x & 0xf) << 16)
+#define RTC_WD(x)	((x & 0xff) << 8)
+#define RTC_RD(x)	(x & 0xff)
+
+/* register offset address define */
+#define RTC_SEC		0x00
+#define RTC_MIN		0x01
+#define RTC_HOUR	0x02
+#define RTC_WEEK	0x03
+#define RTC_DAY		0x04
+#define RTC_MONTH	0x05
+#define RTC_YEAR	0x06
+#define RTC_TRIM	0x07
+#define RTC_ALM_WM	0x08
+#define RTC_ALM_WH	0x09
+#define RTC_ALM_WW	0x0A
+#define RTC_ALM_DM	0x0B
+#define RTC_ALM_DH	0x0C
+#define RTC_RTC1	0x0E
+#define RTC_RTC2	0x0F
+
+/* RTC1 register bit define */
+#define RTC1_WALE		0x80
+#define RTC1_DALE		0x40
+#define RTC1_1224		0x20
+#define RTC1_CLEN2		0x10
+#define RTC1_TEST		0x08
+#define RTC1_CT_SEC		0x04
+#define RTC1_CT_MIN		0x05
+#define RTC1_CT_HOUR	0x06
+#define RTC1_CT_MONTH	0x07
+#define RTC1_CT_MASK	0x07
+
+/* RTC2 register bit define */
+#define RTC2_VDSL		0x80
+#define RTC2_VDET		0x40
+#define RTC2_SCRATCH	0x20
+#define RTC2_XSTP		0x10
+#define RTC1_CLEN1		0x08
+#define RTC2_CTFG		0x04
+#define RTC2_WAFG		0x02
+#define RTC2_DAFG		0x01
+
+#define RTC_READ(addr, val) rtc_read((addr), (unsigned char *)(&(val)));
+#define RTC_WRITE(val, addr) rtc_write((addr), (unsigned char)(val));
+
+#define A9TC_EPOCH	1900
+
+static const unsigned char days_in_mo[] =
+    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+
+static int rtc_irq = 0;
+static int p_freq = 1;
+static unsigned int aie_irqen;
+static unsigned int pie_irqen;
+
+
+static void rtc_read(unsigned char offset, unsigned char *val)
+{
+	unsigned int reg_val;
+	unsigned int timeout = RTC_TIMEOUT;
+
+read_retry:
+	reg_val = RTC_RW | RTC_A(offset);
+	writel(reg_val, RTC_BASE);
+	reg_val |= RTC_START;
+	writel(reg_val, RTC_BASE);
+	reg_val = readl(RTC_BASE);
+	while ((reg_val & RTC_DONE) == 0 && timeout-- > 0) {
+		reg_val = readl(RTC_BASE);
+	}
+	writel(0, RTC_BASE);
+	udelay(RTC_DELAY_TIME);
+	if (timeout == 0) {
+		printk("%s: retry\n", __FUNCTION__);
+		goto read_retry;
+	}
+	*val = RTC_RD(reg_val);
+}
+
+static void rtc_write(unsigned char offset, unsigned char val)
+{
+	unsigned int reg_val;
+	unsigned int timeout = RTC_TIMEOUT;
+
+write_retry:
+	reg_val = RTC_A(offset) | RTC_WD(val);
+	writel(reg_val, RTC_BASE);
+	reg_val |= RTC_START;
+	writel(reg_val, RTC_BASE);
+	reg_val = readl(RTC_BASE);
+	while ((reg_val & RTC_DONE) == 0 && timeout-- > 0) {
+		reg_val = readl(RTC_BASE);
+	}
+	if (timeout == 0) {
+		writel(0, RTC_BASE);
+		udelay(RTC_DELAY_TIME);
+		printk("%s: retry\n", __FUNCTION__);
+		goto write_retry;
+	}
+	while (reg_val & RTC_BUSY) {
+		reg_val = readl(RTC_BASE);
+	}
+	writel(0, RTC_BASE);
+	udelay(RTC_DELAY_TIME);
+}
+
+static int a9tc_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&a9tc_rtc_lock, flags);
+	RTC_READ(RTC_SEC,   rtc_tm->tm_sec);
+	RTC_READ(RTC_MIN,   rtc_tm->tm_min);
+	RTC_READ(RTC_HOUR,  rtc_tm->tm_hour);
+	RTC_READ(RTC_WEEK,  rtc_tm->tm_wday);
+	RTC_READ(RTC_DAY,   rtc_tm->tm_mday);
+	RTC_READ(RTC_MONTH, rtc_tm->tm_mon);
+	RTC_READ(RTC_YEAR,  rtc_tm->tm_year);
+	spin_unlock_irqrestore(&a9tc_rtc_lock, flags);
+
+	rtc_tm->tm_mon &= 0x1f;	/* Mask of D7(19/20) */
+
+	rtc_tm->tm_sec  = BCD2BIN(rtc_tm->tm_sec);
+	rtc_tm->tm_min  = BCD2BIN(rtc_tm->tm_min);
+	rtc_tm->tm_hour = BCD2BIN(rtc_tm->tm_hour);
+	rtc_tm->tm_mday = BCD2BIN(rtc_tm->tm_mday);
+	rtc_tm->tm_mon  = BCD2BIN(rtc_tm->tm_mon);
+	rtc_tm->tm_year = BCD2BIN(rtc_tm->tm_year);
+
+	if (rtc_tm->tm_year <= 69) {
+		rtc_tm->tm_year += 100;
+	}
+	rtc_tm->tm_mon--;
+
+	return 0;
+}
+
+static int a9tc_rtc_settime(struct device *dev, struct rtc_time *rtc_tm)
+{
+	unsigned char mon, day, hrs, min, sec, leap_yr, wday;
+	unsigned int yrs;
+	unsigned long flags;
+
+	yrs = rtc_tm->tm_year + A9TC_EPOCH;
+	mon = rtc_tm->tm_mon + 1;	/* tm_mon starts at zero */
+	day = rtc_tm->tm_mday;
+	hrs = rtc_tm->tm_hour;
+	min = rtc_tm->tm_min;
+	sec = rtc_tm->tm_sec;
+
+	if (yrs < 1970) {
+		return -EINVAL;
+	}
+
+	/* setting day of week */
+	if (mon < 3) {
+		wday = ((yrs-1) + (yrs-1)/4 - (yrs-1)/100 + (yrs-1)/400 + (13*(mon+12)+8)/5 + day) % 7;
+	} else {
+		wday = (yrs + yrs/4 - yrs/100 + yrs/400 + (13*mon+8)/5 + day) % 7;
+	}
+
+	leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+
+	if (wday >= 7) {
+		return -EINVAL;
+	}
+	if ((mon > 12) || (day == 0)) {
+		return -EINVAL;
+	}
+	if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr))) {
+		return -EINVAL;
+	}
+	if ((hrs >= 24) || (min >= 60) || (sec >= 60)) {
+		return -EINVAL;
+	}
+	if ((yrs -= A9TC_EPOCH) > 255) {
+		return -EINVAL;
+	}
+	if (yrs > 169) {
+		return -EINVAL;
+	}
+	if (yrs >= 100) {
+		yrs -= 100;
+	}
+
+	sec = BIN2BCD(sec);
+	min = BIN2BCD(min);
+	hrs = BIN2BCD(hrs);
+	day = BIN2BCD(day);
+	mon = BIN2BCD(mon);
+	yrs = BIN2BCD(yrs);
+
+	spin_lock_irqsave(&a9tc_rtc_lock, flags);
+	RTC_WRITE(yrs,  RTC_YEAR);
+	RTC_WRITE(mon,  RTC_MONTH);
+	RTC_WRITE(day,  RTC_DAY);
+	RTC_WRITE(wday, RTC_WEEK);
+	RTC_WRITE(hrs,  RTC_HOUR);
+	RTC_WRITE(min,  RTC_MIN);
+	RTC_WRITE(sec,  RTC_SEC);
+	spin_unlock_irqrestore(&a9tc_rtc_lock, flags);
+
+	return 0;
+}
+
+static inline void a9tc_rtc_setaie(unsigned int enable)
+{
+	unsigned char rtc1_val, rtc2_val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&a9tc_rtc_lock, flags);
+	RTC_READ(RTC_RTC1, rtc1_val);
+	RTC_READ(RTC_RTC2, rtc2_val);
+	rtc1_val &= ~RTC1_WALE;
+	rtc2_val &= ~RTC2_WAFG;
+	if (enable) {
+		rtc1_val |= RTC1_WALE;
+	}
+	RTC_WRITE(rtc2_val, RTC_RTC2);
+	RTC_WRITE(rtc1_val, RTC_RTC1);
+
+	if (enable && (aie_irqen == 0) && (pie_irqen == 0)) {
+		enable_irq(rtc_irq);
+	}
+
+	if ((enable == 0) && (aie_irqen == 1) && (pie_irqen == 0)) {
+		disable_irq(rtc_irq);
+	}
+
+	aie_irqen = enable;
+	spin_unlock_irqrestore(&a9tc_rtc_lock, flags);
+}
+
+static inline void a9tc_rtc_setpie(unsigned int enable)
+{
+	unsigned char rtc1_val, rtc2_val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&a9tc_rtc_lock, flags);
+	RTC_READ(RTC_RTC1, rtc1_val);
+	RTC_READ(RTC_RTC2, rtc2_val);
+	rtc1_val &= ~RTC1_CT_MASK;
+	if (enable) {
+		switch (p_freq) {
+		case 1:
+			rtc1_val |= RTC1_CT_SEC;
+			break;
+		case 60:
+			rtc1_val |= RTC1_CT_MIN;
+			break;
+		case 60*60:
+			rtc1_val |= RTC1_CT_HOUR;
+			break;
+		case 60*60*24*30:
+			rtc1_val |= RTC1_CT_MONTH;
+			break;
+		}
+	}
+
+	rtc2_val &= ~RTC2_CTFG;
+	RTC_WRITE(rtc2_val, RTC_RTC2);
+	RTC_WRITE(rtc1_val, RTC_RTC1);
+	if (enable && (aie_irqen == 0) && (pie_irqen == 0)) {
+		enable_irq(rtc_irq);
+	}
+
+	if ((enable == 0) && (aie_irqen == 0) && (pie_irqen == 1)) {
+		disable_irq(rtc_irq);
+	}
+
+	pie_irqen = enable;
+	spin_unlock_irqrestore(&a9tc_rtc_lock, flags);
+}
+
+
+static inline int a9tc_rtc_setfreq(int freq)
+{
+	switch (freq) {
+	case 1:
+	case 60:
+	case 60*60:
+	case 60*60*24*30:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	p_freq = freq;
+
+	return 0;
+}
+
+static int a9tc_rtc_getalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *alm_tm = &alrm->time;
+	unsigned long flags;
+
+	spin_lock_irqsave(&a9tc_rtc_lock, flags);
+	RTC_READ(RTC_ALM_WM, alm_tm->tm_min);
+	RTC_READ(RTC_ALM_WH, alm_tm->tm_hour);
+	RTC_READ(RTC_ALM_WW, alm_tm->tm_wday);
+	spin_unlock_irqrestore(&a9tc_rtc_lock, flags);
+
+	alm_tm->tm_min  = BCD2BIN(alm_tm->tm_min);
+	alm_tm->tm_hour = BCD2BIN(alm_tm->tm_hour);
+
+	alm_tm->tm_wday &= 0x7F;
+	if(alm_tm->tm_wday) {
+		if(alm_tm->tm_wday == 0x7F)
+			alm_tm->tm_wday = -1;
+		else
+			alm_tm->tm_wday = ilog2(alm_tm->tm_wday);
+	}
+
+	return 0;
+}
+
+static int a9tc_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *alm_tm = &alrm->time;
+	unsigned char hrs, min, wday;
+	unsigned long flags;
+
+	hrs = alm_tm->tm_hour;
+	min = alm_tm->tm_min;
+	if (alm_tm->tm_wday == -1) {
+		wday = 0x7f;	/* All */
+	} else {
+		if (alm_tm->tm_wday > 6)
+			return -EINVAL;
+		wday = 1 << alm_tm->tm_wday;
+	}
+
+	if (hrs >= 24)
+		return -EINVAL;
+	if (min >= 60)
+		return -EINVAL;
+
+	min = BIN2BCD(min);
+	hrs = BIN2BCD(hrs);
+
+	spin_lock_irqsave(&a9tc_rtc_lock, flags);
+	RTC_WRITE(wday, RTC_ALM_WW);
+	RTC_WRITE(hrs,  RTC_ALM_WH);
+	RTC_WRITE(min,  RTC_ALM_WM);
+	spin_unlock_irqrestore(&a9tc_rtc_lock, flags);
+
+	if (alrm->enabled) {
+		a9tc_rtc_setaie(1);
+	} else {
+		a9tc_rtc_setaie(0);
+	}
+
+	return 0;
+}
+
+static int a9tc_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case RTC_AIE_ON:
+	case RTC_AIE_OFF:
+		a9tc_rtc_setaie((cmd == RTC_AIE_ON) ? 1 : 0);
+		break;
+
+	case RTC_PIE_ON:
+	case RTC_PIE_OFF:
+		a9tc_rtc_setpie((cmd == RTC_PIE_ON) ? 1 : 0);
+		break;
+
+	case RTC_IRQP_SET:
+		return a9tc_rtc_setfreq(arg);
+
+	case RTC_IRQP_READ:
+		return  put_user(p_freq, (unsigned long __user *)arg);
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+static irqreturn_t a9tc_rtc_interrupt(int irq, void *dev_id)
+{
+	struct rtc_device *rtc = dev_id;
+	unsigned long events = RTC_IRQF;
+	unsigned char rtc2_val = 0;
+
+
+	spin_lock(&a9tc_rtc_lock);
+	RTC_READ(RTC_RTC2, rtc2_val);
+
+	if (!(rtc2_val & (RTC2_CTFG | RTC2_WAFG))) {
+		spin_unlock(&a9tc_rtc_lock);
+		return IRQ_NONE;
+	}
+
+	if (rtc2_val & RTC2_CTFG) {
+		rtc2_val &= ~RTC2_CTFG;
+		events |= RTC_PF;
+	}
+	if (rtc2_val & RTC2_WAFG) {
+		rtc2_val &= ~RTC2_WAFG;
+		events |= RTC_AF;
+	}
+
+	RTC_WRITE(rtc2_val, RTC_RTC2);
+	spin_unlock(&a9tc_rtc_lock);
+
+	rtc_update_irq(rtc, 1, events);
+
+	return IRQ_HANDLED;
+}
+
+static int a9tc_rtc_open(struct device *dev)
+{
+	int ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	ret = request_irq(rtc_irq, a9tc_rtc_interrupt, IRQF_DISABLED, "rtc", rtc);
+	if (ret < 0) {
+		printk(KERN_ERR "rtc: request_irq error! (%d)\n", rtc_irq);
+		return ret;
+	}
+	disable_irq(rtc_irq);
+
+	return 0;
+}
+
+static void a9tc_rtc_release(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	a9tc_rtc_setpie(0);
+
+	free_irq(rtc_irq, rtc);
+}
+
+
+static struct rtc_class_ops a9tc_rtcops = {
+	.open         = a9tc_rtc_open,
+	.release      = a9tc_rtc_release,
+	.ioctl        = a9tc_rtc_ioctl,
+	.read_time    = a9tc_rtc_gettime,
+	.set_time     = a9tc_rtc_settime,
+	.read_alarm   = a9tc_rtc_getalarm,
+	.set_alarm    = a9tc_rtc_setalarm,
+};
+
+static int a9tc_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device	*rtc;
+
+	rtc_irq = platform_get_irq(pdev, 0);
+	if (rtc_irq < 0) {
+		return -ENODEV;
+	}
+
+	rtc = rtc_device_register(pdev->name, &pdev->dev,
+			&a9tc_rtcops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		pr_debug("%s: can't register RTC device, err %ld\n",
+			pdev->name, PTR_ERR(rtc));
+		goto fail;
+	}
+	platform_set_drvdata(pdev, rtc);
+
+	aie_irqen = 0;
+	pie_irqen = 0;
+
+	RTC_WRITE(0x00, RTC_TRIM);
+	RTC_WRITE(RTC1_1224, RTC_RTC1);
+	RTC_WRITE(0, RTC_RTC2);
+
+	return 0;
+
+fail:
+	return -EIO;
+}
+
+static int a9tc_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device	*rtc = platform_get_drvdata(pdev);
+
+	rtc_device_unregister(rtc);
+
+	return 0;
+}
+
+static struct platform_driver a9tc_rtcdrv = {
+	.probe		= a9tc_rtc_probe,
+	.remove		= a9tc_rtc_remove,
+	.driver		= {
+		.name	= "a9tc-rtc",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rtc_init(void)
+{
+	return platform_driver_register(&a9tc_rtcdrv);
+}
+module_init(rtc_init);
+
+static void __exit rtc_exit(void)
+{
+	platform_driver_unregister(&a9tc_rtcdrv);
+}
+module_exit(rtc_exit);
+
+MODULE_DESCRIPTION("A9TC board RTC Driver");
+MODULE_LICENSE("GPL");
diff --git a/fs/Kconfig b/fs/Kconfig
index 522469a..0472be0 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -931,6 +931,39 @@ config CRAMFS
 
 	  If unsure, say N.
 
+config CRAMFS_LINEAR
+	bool "Use linear addressing for CramFs"
+	depends on CRAMFS
+	help
+	  This option tells the CramFs driver to load data directly from
+	  a linear adressed memory range (usually non volatile memory
+	  like flash) instead of going through the block device layer.
+	  This saves some memory since no intermediate buffering is
+	  necessary.
+
+	  This is also a prerequisite for XIP of binaries stored on the
+	  filesystem.
+
+	  The location of the CramFs image in memory is board
+	  dependent. Therefore, if you say Y, you must know the proper
+	  physical address where to store the CramFs image and specify
+	  it using the physaddr=0x******** mount option (for example:
+	  "mount -t cramfs -o physaddr=0x100000 none /mnt").
+
+	  If unsure, say N.
+
+config ROOT_CRAMFS_LINEAR
+	bool "Root file system on linear CramFs"
+	depends on CRAMFS_LINEAR
+	help
+	  Say Y if you have enabled linear CramFs, and you want to be
+	  able to use the linear CramFs image as a root file system.  To
+	  actually have the kernel mount this CramFs image as a root
+	  file system, you must also pass the command line parameter
+	  "root=/dev/null rootflags=physaddr=0x********" to the kernel
+	  (replace 0x******** with the physical address location of the
+	  linear CramFs image to boot with).
+
 config VXFS_FS
 	tristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"
 	depends on BLOCK
diff --git a/fs/cramfs/inode.c b/fs/cramfs/inode.c
index f40423e..ed4ce98 100644
--- a/fs/cramfs/inode.c
+++ b/fs/cramfs/inode.c
@@ -101,6 +101,25 @@ static void cramfs_drop_inode(struct inode *inode)
 		generic_drop_inode(inode);
 }
 
+#ifdef CONFIG_CRAMFS_LINEAR
+/*
+ * Return a pointer to the block in the linearly addressed cramfs image.
+ */
+static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)
+{
+	struct cramfs_sb_info *sbi = CRAMFS_SB(sb);
+
+	if (!len)
+		return NULL;
+
+	if ((offset + len > sbi->size) || (offset > sbi->size) || (len > sbi->size))
+		return NULL;
+
+	return (void*)(sbi->linear_virt_addr + offset);
+}
+
+#else /* Not linear addressing - aka regular block mode. */
+
 /*
  * We have our own block cache: don't fill up the buffer cache
  * with the rom-image, because the way the filesystem is set
@@ -209,6 +228,8 @@ static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned i
 	return read_buffers[buffer] + offset;
 }
 
+#endif /* CONFIG_CRAMFS_LINEAR */
+
 static void cramfs_put_super(struct super_block *sb)
 {
 	kfree(sb->s_fs_info);
@@ -223,7 +244,11 @@ static int cramfs_remount(struct super_block *sb, int *flags, char *data)
 
 static int cramfs_fill_super(struct super_block *sb, void *data, int silent)
 {
+#ifndef CONFIG_CRAMFS_LINEAR
 	int i;
+#else
+	char *p;
+#endif
 	struct cramfs_super super;
 	unsigned long root_offset;
 	struct cramfs_sb_info *sbi;
@@ -236,10 +261,47 @@ static int cramfs_fill_super(struct super_block *sb, void *data, int silent)
 		return -ENOMEM;
 	sb->s_fs_info = sbi;
 
+#ifndef CONFIG_CRAMFS_LINEAR
 	/* Invalidate the read buffers on mount: think disk change.. */
 	mutex_lock(&read_mutex);
 	for (i = 0; i < READ_BUFFERS; i++)
 		buffer_blocknr[i] = -1;
+#else /* CONFIG_CRAMFS_LINEAR */
+	/*
+	 * The physical location of the cramfs image is specified as
+	 * a mount parameter.  This parameter is mandatory for obvious
+	 * reasons.  Some validation is made on the phys address but this
+	 * is not exhaustive and we count on the fact that someone using
+	 * this feature is supposed to know what he/she's doing.
+	 */
+	if (!data || !(p = strstr((char *)data, "physaddr="))) {
+		printk(KERN_ERR "cramfs: unknown physical address for linear cramfs image\n");
+		goto out;
+	}
+	sbi->linear_phys_addr = simple_strtoul(p + 9, NULL, 0);
+	if (sbi->linear_phys_addr & (PAGE_SIZE-1)) {
+		printk(KERN_ERR "cramfs: physical address 0x%lx for linear cramfs isn't aligned to a page boundary\n",
+		       sbi->linear_phys_addr);
+		goto out;
+	}
+	if (sbi->linear_phys_addr == 0) {
+		printk(KERN_ERR "cramfs: physical address for linear cramfs image can't be 0\n");
+		goto out;
+	}
+	printk(KERN_INFO "cramfs: checking physical address 0x%lx for linear cramfs image\n",
+	       sbi->linear_phys_addr);
+
+	/* Map only one page for now.  Will remap it when fs size is known. */
+	sbi->size = PAGE_SIZE;
+	sbi->linear_virt_addr =
+		ioremap(sbi->linear_phys_addr, sbi->size);
+	if (!sbi->linear_virt_addr) {
+		printk(KERN_ERR "cramfs: ioremap of the linear cramfs image failed\n");
+		goto out;
+	}
+
+	mutex_lock(&read_mutex);
+#endif /* CONFIG_CRAMFS_LINEAR */
 
 	/* Read the first block and get the superblock from it */
 	memcpy(&super, cramfs_read(sb, 0, sizeof(super)), sizeof(super));
@@ -310,8 +372,30 @@ static int cramfs_fill_super(struct super_block *sb, void *data, int silent)
 		iput(root);
 		goto out;
 	}
+#ifdef CONFIG_CRAMFS_LINEAR
+	/* Remap the whole filesystem now */
+	iounmap(sbi->linear_virt_addr);
+	printk(KERN_INFO "cramfs: linear cramfs image appears to be %lu KB in size\n",
+	       sbi->size/1024);
+#ifdef CONFIG_ARM
+	sbi->linear_virt_addr =
+		ioremap_cached(sbi->linear_phys_addr, sbi->size);
+//		__ioremap(sbi->linear_phys_addr, sbi->size, L_PTE_CACHEABLE);
+#else /* CONFIG_ARM */
+	sbi->linear_virt_addr =
+		ioremap(sbi->linear_phys_addr, sbi->size);
+#endif /* CONFIG_ARM */
+	if (!sbi->linear_virt_addr) {
+		printk(KERN_ERR "cramfs: ioremap of the linear cramfs image failed\n");
+		goto out;
+	}
+#endif /* CONFIG_CRAMFS_LINEAR */
 	return 0;
 out:
+#ifdef CONFIG_CRAMFS_LINEAR
+	if (sbi->linear_virt_addr)
+		iounmap(sbi->linear_virt_addr);
+#endif /* CONFIG_CRAMFS_LINEAR */
 	kfree(sbi);
 	sb->s_fs_info = NULL;
 	return -EINVAL;
@@ -531,15 +615,23 @@ static const struct super_operations cramfs_ops = {
 static int cramfs_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
+#ifdef CONFIG_CRAMFS_LINEAR
+	return get_sb_nodev(fs_type, flags, data, cramfs_fill_super, mnt);
+#else
 	return get_sb_bdev(fs_type, flags, dev_name, data, cramfs_fill_super,
 			   mnt);
+#endif
 }
 
 static struct file_system_type cramfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "cramfs",
 	.get_sb		= cramfs_get_sb,
+#ifdef CONFIG_CRAMFS_LINEAR
+	.kill_sb	= kill_anon_super,
+#else
 	.kill_sb	= kill_block_super,
+#endif
 	.fs_flags	= FS_REQUIRES_DEV,
 };
 
diff --git a/include/linux/amba/clcd.h b/include/linux/amba/clcd.h
index 29c0448..5b6e6ba 100644
--- a/include/linux/amba/clcd.h
+++ b/include/linux/amba/clcd.h
@@ -21,7 +21,7 @@
 #define CLCD_UBAS 		0x00000010
 #define CLCD_LBAS 		0x00000014
 
-#if !defined(CONFIG_ARCH_VERSATILE) && !defined(CONFIG_ARCH_REALVIEW)
+#if !defined(CONFIG_ARCH_VERSATILE) && !defined(CONFIG_ARCH_REALVIEW) && !defined(CONFIG_ARCH_A9TC)
 #define CLCD_IENB 		0x00000018
 #define CLCD_CNTL 		0x0000001c
 #else
diff --git a/include/linux/cramfs_fs_sb.h b/include/linux/cramfs_fs_sb.h
index 8390693..2e561bd 100644
--- a/include/linux/cramfs_fs_sb.h
+++ b/include/linux/cramfs_fs_sb.h
@@ -10,6 +10,10 @@ struct cramfs_sb_info {
 			unsigned long blocks;
 			unsigned long files;
 			unsigned long flags;
+#ifdef CONFIG_CRAMFS_LINEAR
+			unsigned long linear_phys_addr;
+			char *        linear_virt_addr;
+#endif
 };
 
 static inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)
diff --git a/init/do_mounts.c b/init/do_mounts.c
index d055b19..7197100 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -297,6 +297,16 @@ static int __init mount_nfs_root(void)
 }
 #endif
 
+#ifdef CONFIG_ROOT_CRAMFS_LINEAR
+static int __init mount_cramfs_linear_root(void)
+{
+	create_dev("/dev/root", ROOT_DEV);
+	if (do_mount_root("/dev/root","cramfs",root_mountflags,root_mount_data) == 0)
+		return 1;
+	return 0;
+}
+#endif
+
 #if defined(CONFIG_BLK_DEV_RAM) || defined(CONFIG_BLK_DEV_FD)
 void __init change_floppy(char *fmt, ...)
 {
@@ -329,6 +339,13 @@ void __init change_floppy(char *fmt, ...)
 
 void __init mount_root(void)
 {
+#ifdef CONFIG_ROOT_CRAMFS_LINEAR
+        if (ROOT_DEV == MKDEV(0, 0)) {
+	        if (mount_cramfs_linear_root())
+		        return;
+		printk (KERN_ERR "VFS: Unable to mount linear cramfs root.\n");
+	}
+#endif
 #ifdef CONFIG_ROOT_NFS
 	if (MAJOR(ROOT_DEV) == UNNAMED_MAJOR) {
 		if (mount_nfs_root())
-- 
1.6.3.3

