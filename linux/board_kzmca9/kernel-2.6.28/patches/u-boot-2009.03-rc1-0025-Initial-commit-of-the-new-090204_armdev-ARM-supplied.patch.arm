From dd375dad53a0700c7c5e50c078432e0405ead047 Mon Sep 17 00:00:00 2001
From: Peter Pearse <peter.pearse@arm.com>
Date: Wed, 4 Feb 2009 18:02:05 +0000
Subject: [PATCH 25/46] Initial commit of the new 090204_armdev ARM supplied developments board patch.
 Not yet built.

---
 MAKEALL                                       |   11 +-
 Makefile                                      |   14 +
 board/armltd/integratorap/integratorap.c      |    5 +
 board/armltd/integratorap/split_by_variant.sh |   45 +-
 board/armltd/integratorcp/integratorcp.c      |  215 ++-
 board/armltd/integratorcp/split_by_variant.sh |   61 +-
 board/armltd/realview_eb/Makefile             |   47 +
 board/armltd/realview_eb/config.mk            |    5 +
 board/armltd/realview_eb/lowlevel_init.S      |   34 +
 board/armltd/realview_eb/realview_eb.c        |  221 +++
 board/armltd/realview_eb/split_by_variant.sh  |   37 +
 board/armltd/realview_eb/u-boot.lds.template  |   53 +
 board/armltd/realview_pb/Makefile             |   47 +
 board/armltd/realview_pb/config.mk            |    5 +
 board/armltd/realview_pb/lowlevel_init.S      |   34 +
 board/armltd/realview_pb/realview_pb.c        |  235 +++
 board/armltd/realview_pb/split_by_variant.sh  |   49 +
 board/armltd/realview_pb/u-boot.lds.template  |   53 +
 board/armltd/versatile/Makefile               |    2 +-
 board/armltd/versatile/split_by_variant.sh    |   31 +-
 board/armltd/versatile/versatile.c            |  149 ++-
 cpu/arm1136/config.mk                         |    1 +
 cpu/arm720t/config.mk                         |    1 +
 cpu/arm920t/config.mk                         |    1 +
 cpu/arm926ejs/interrupts.c                    |    6 +-
 cpu/arm926ejs/versatile/Makefile              |    2 +-
 cpu/arm926ejs/versatile/timer.c               |    4 +-
 cpu/arm946es/config.mk                        |    1 +
 cpu/armct_rv/Makefile                         |   43 +
 cpu/armct_rv/config.mk                        |   35 +
 cpu/armct_rv/cpu.c                            |   91 +
 cpu/armct_rv/interrupts.c                     |  203 ++
 cpu/armct_rv/start.S                          |  372 ++++
 doc/README-integrator                         |   37 +-
 doc/README-realview_eb                        |   44 +
 doc/README-versatile                          |   44 +
 drivers/net/Makefile                          |    1 +
 drivers/net/smc9118.c                         |  983 ++++++++++
 drivers/net/smc9118.h                         |  524 +++++
 drivers/net/smc_rv.c                          | 2596 +++++++++++++++++++++++++
 drivers/net/smc_rv.h                          | 1198 ++++++++++++
 examples/Makefile                             |    9 +
 include/armcoremodule.h                       |    3 +-
 include/armsupplied.h                         |   41 +
 include/asm-arm/mach-types.h                  |    1 -
 include/configs/integratorap.h                |   13 +-
 include/configs/integratorcp.h                |  105 +-
 include/configs/realview_eb.h                 |  273 +++
 include/configs/realview_pb.h                 |  286 +++
 include/configs/versatile.h                   |  190 ++-
 lib_arm/Makefile                              |    1 +
 lib_arm/board.c                               |    5 +
 lib_arm/bootm.c                               |   12 +-
 lib_arm/div64.S                               |  201 ++
 lib_generic/vsprintf.c                        |    3 +-
 net/bootp.c                                   |   21 +
 56 files changed, 8480 insertions(+), 224 deletions(-)
 create mode 100644 board/armltd/realview_eb/Makefile
 create mode 100644 board/armltd/realview_eb/config.mk
 create mode 100644 board/armltd/realview_eb/lowlevel_init.S
 create mode 100644 board/armltd/realview_eb/realview_eb.c
 create mode 100644 board/armltd/realview_eb/split_by_variant.sh
 create mode 100644 board/armltd/realview_eb/u-boot.lds.template
 create mode 100644 board/armltd/realview_pb/Makefile
 create mode 100644 board/armltd/realview_pb/config.mk
 create mode 100644 board/armltd/realview_pb/lowlevel_init.S
 create mode 100644 board/armltd/realview_pb/realview_pb.c
 create mode 100644 board/armltd/realview_pb/split_by_variant.sh
 create mode 100644 board/armltd/realview_pb/u-boot.lds.template
 create mode 100644 cpu/armct_rv/Makefile
 create mode 100644 cpu/armct_rv/config.mk
 create mode 100644 cpu/armct_rv/cpu.c
 create mode 100644 cpu/armct_rv/interrupts.c
 create mode 100644 cpu/armct_rv/start.S
 create mode 100644 doc/README-realview_eb
 create mode 100644 doc/README-versatile
 create mode 100644 drivers/net/smc9118.c
 create mode 100644 drivers/net/smc9118.h
 create mode 100644 drivers/net/smc_rv.c
 create mode 100644 drivers/net/smc_rv.h
 create mode 100644 include/armsupplied.h
 mode change 100644 => 100755 include/asm-arm/mach-types.h
 create mode 100644 include/configs/realview_eb.h
 create mode 100644 include/configs/realview_pb.h
 mode change 100644 => 100755 include/configs/versatile.h
 create mode 100644 lib_arm/div64.S

diff --git a/MAKEALL b/MAKEALL
index f8c912b..b48f751 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -520,6 +520,9 @@ LIST_ARM9="			\
 	versatileab		\
 	versatilepb		\
 	voiceblue		\
+	realview_eb		\
+	realview_pb1176		\
+	realview_pb11mp		\
 	davinci_dvevm		\
 	davinci_schmoogie	\
 	davinci_sffsdr		\
@@ -551,12 +554,14 @@ LIST_ARM11="		\
 #########################################################################
 ## ARM Cortex-A8 Systems
 #########################################################################
-LIST_ARM_CORTEX_A8="		\
+LIST_ARM_CORTEX="		\
 	omap3_beagle		\
 	omap3_overo		\
 	omap3_evm		\
 	omap3_pandora		\
 	omap3_zoom1		\
+	realview_pba8		\
+	realview_pbx    	\
 "
 
 #########################################################################
@@ -619,7 +624,7 @@ LIST_arm="			\
 	${LIST_ARM9}		\
 	${LIST_ARM10}		\
 	${LIST_ARM11}		\
-	${LIST_ARM_CORTEX_A8}	\
+	${LIST_ARM_CORTEX}	\
 	${LIST_at91}		\
 	${LIST_pxa}		\
 	${LIST_ixp}		\
@@ -850,7 +855,7 @@ build_target() {
 for arg in $@
 do
 	case "$arg" in
-	arm|SA|ARM7|ARM9|ARM10|ARM11|ARM_CORTEX_A8|at91|ixp|pxa \
+	arm|SA|ARM7|ARM9|ARM10|ARM11|ARM_CORTEX|at91|ixp|pxa \
 	|avr32 \
 	|blackfin \
 	|coldfire \
diff --git a/Makefile b/Makefile
index e8b4c13..96e3c4d 100644
--- a/Makefile
+++ b/Makefile
@@ -2815,6 +2815,20 @@ omap730p2_cs3boot_config :	unconfig
 	fi;
 	@$(MKCONFIG) -a $(call xtract_omap730p2,$@) arm arm926ejs omap730p2 NULL omap
 
+#========================================================================
+# ARM supplied RealView Emulation Baseboard
+realview_eb_config :	unconfig
+	@chmod a+x board/realview_eb/split_by_variant.sh 
+	@board/realview_eb/split_by_variant.sh $@ $(CC)
+
+# ARM supplied RealView Platform Baseboard
+realview_pbx_config	\
+realview_pba8_config	\
+realview_pb1176_config	\
+realview_pb11mp_config	:	unconfig
+	@chmod a+x board/realview_pb/split_by_variant.sh 
+	@board/realview_pb/split_by_variant.sh $@ $(CC)
+
 sbc2410x_config: unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t sbc2410x NULL s3c24x0
 
diff --git a/board/armltd/integratorap/integratorap.c b/board/armltd/integratorap/integratorap.c
index 9631967..dfa92f3 100644
--- a/board/armltd/integratorap/integratorap.c
+++ b/board/armltd/integratorap/integratorap.c
@@ -654,3 +654,8 @@ int board_eth_init(bd_t *bis)
 {
 	return pci_eth_init(bis);
 }
+
+/*
+ *  u32 get_board_rev() for ARM supplied development boards
+ */
+ARM_SUPPLIED_GET_BOARD_REV
diff --git a/board/armltd/integratorap/split_by_variant.sh b/board/armltd/integratorap/split_by_variant.sh
index 51dc53f..6f7608c 100755
--- a/board/armltd/integratorap/split_by_variant.sh
+++ b/board/armltd/integratorap/split_by_variant.sh
@@ -12,77 +12,80 @@ echo	" 1 /* Integrator/AP	 */"		>> tmp.fil
 #	Set the core module defines according to Core Module
 # ---------------------------------------------------------
 cpu="arm_intcm"
-variant="unknown core module"
+variant="integratorap"
 
 if [ "$1" = "" ]
 then
 	echo "$0:: No parameters - using arm_intcm"
 else
+	variant=`echo $1 | sed -r s/_config//`
+
 	case "$1" in
-	ap7_config)
+	ap7t_config)
 	cpu="arm_intcm"
-	variant="unported core module CM7TDMI"
 	;;
 
-	ap966)
+	ap966_config)
 	cpu="arm_intcm"
-	variant="unported core module CM966E-S"
 	;;
 
 	ap922_config)
 	cpu="arm_intcm"
-	variant="unported core module CM922T"
 	;;
 
-	integratorap_config	|	\
-	ap_config)
+	integratorap_config)
 	cpu="arm_intcm"
-	variant="unspecified core module"
 	;;
 
 	ap720t_config)
 	cpu="arm720t"
-	echo -n	"#define CONFIG_CM720T"			>> tmp.fil
-	echo	" 1 /* CPU core is ARM720T */ "		>> tmp.fil
-	variant="Core module CM720T"
+	echo -n	"#define CONFIG_CM720T"		>> tmp.fil
+	echo	" 1 /* CPU core is ARM720T */ "	>> tmp.fil
 	;;
 
 	ap922_XA10_config)
 	cpu="arm_intcm"
-	variant="unported core module CM922T_XA10"
-	echo -n	"#define CONFIG_CM922T_XA10"		>> tmp.fil
-	echo	" 1 /* CPU core is ARM922T_XA10 */"	>> tmp.fil
+	echo -n	"#define CONFIG_CM922T_XA10" 		>> tmp.fil
+	echo	" 1 /* CPU core is ARM922T_XA10 */" 	>> tmp.fil
 	;;
 
 	ap920t_config)
 	cpu="arm920t"
-	variant="Core module CM920T"
-	echo -n	"#define CONFIG_CM920T"			>> tmp.fil
+	echo -n	"#define CONFIG_CM920T" 		>> tmp.fil
 	echo	" 1 /* CPU core is ARM920T */"		>> tmp.fil
 	;;
 
 	ap926ejs_config)
 	cpu="arm926ejs"
-	variant="Core module CM926EJ-S"
 	echo -n	"#define CONFIG_CM926EJ_S"		>> tmp.fil
 	echo	" 1 /* CPU core is ARM926EJ-S */ "	>> tmp.fil
 	;;
 
 	ap946es_config)
 	cpu="arm946es"
-	variant="Core module CM946E-S"
 	echo -n	"#define CONFIG_CM946E_S"		>> tmp.fil
 	echo	" 1 /* CPU core is ARM946E-S */ "	>> tmp.fil
 	;;
 
 	*)
 	echo "$0:: Unknown core module"
-	variant="unknown core module"
+	variant="integratorap"
 	cpu="arm_intcm"
 	;;
 
 	esac
 fi
+# ---------------------------------------------------------
+# Link variant header to integratorap.h
+# ---------------------------------------------------------
+if [ "$variant" != "integratorap" ] 
+then
+	if [ -h ./include/configs/$variant.h ] 
+	then
+		rm ./include/configs/$variant.h
+	fi
+	ln -s ./integratorap.h ./include/configs/$variant.h
+fi
 
 if [ "$cpu" = "arm_intcm" ]
 then
@@ -114,6 +117,6 @@ sed -r 's/CPU_FILE/cpu\/'$cpu'\/start.o/; s/#.*//' ${src}board/armltd/integrator
 # ---------------------------------------------------------
 # Complete the configuration
 # ---------------------------------------------------------
-$MKCONFIG -a integratorap arm $cpu integratorap armltd;
+$MKCONFIG -a $variant arm $cpu integratorap armltd;
 echo "Variant:: $variant with core $cpu"
 
diff --git a/board/armltd/integratorcp/integratorcp.c b/board/armltd/integratorcp/integratorcp.c
index 72629ce..6767f71 100644
--- a/board/armltd/integratorcp/integratorcp.c
+++ b/board/armltd/integratorcp/integratorcp.c
@@ -36,6 +36,8 @@
 #include <common.h>
 #include <div64.h>
 
+
+
 DECLARE_GLOBAL_DATA_PTR;
 
 void flash__init (void);
@@ -86,15 +88,59 @@ int misc_init_r (void)
 
 /******************************
  Routine:
- Description:
+ Description: The Integrator/CP uses CFI flash.
+ In order for the CFI commands to work we must ensure that
+ the flash is accessible.
+ Also sets up the number of banks for a later check against
+ include/configs/integratorcp.h
 ******************************/
+int nbanks	= 0xDEADBABE;
+int sizeIndex	= 0xCAFEBABE;
 void flash__init (void)
 {
+	vu_long *cpcr = (vu_long *)CPCR_BASE;
+
+	/* Check if there is an extra bank of flash */
+	if (cpcr[1] & CPMASK_EXTRABANK)
+		nbanks = 2;
+	else
+		nbanks = 1;
+
+	/* Check if there is an extra bank of flash */
+	if (cpcr[1] & CPMASK_FLASHSIZE)
+		sizeIndex = 1;
+	else
+		sizeIndex = 0;
+
+	/* Enable flash write */
+	cpcr[1] |= 3;
+}
+/******************************
+ Routine:
+ Description: Check Integrator/CP control
+							register settings against
+				configs header.
+******************************/
+void flash_check(void) {
+	unsigned int sizes[] =	{0x01000000, 0x02000000};
+	if(nbanks != CONFIG_SYS_MAX_FLASH_BANKS){
+		printf(	"The board control register indicates %d flash banks, "
+			"<U-Boot root>/include/configs/integratorcp.h::"
+			"CONFIG_SYS_MAX_FLASH_BANKS is set to %d\n" \
+			,nbanks, CONFIG_SYS_MAX_FLASH_BANKS);
+	}
+
+	if(PHYS_FLASH_SIZE != sizes[sizeIndex]){
+		printf(	"The board control register indicates 0x%08x bytes of "
+			"flash, <U-Boot root>/include/configs/integratorcp.h"
+			"::PHYS_FLASH_SIZE is set to 0x%08x\n" \
+			,sizes[sizeIndex], PHYS_FLASH_SIZE);
+	}
 }
 /*************************************************************
  Routine:ether__init
  Description: take the Ethernet controller out of reset and wait
-	      for the EEPROM load to complete.
+				for the EEPROM load to complete.
 *************************************************************/
 void ether__init (void)
 {
@@ -110,78 +156,86 @@ int dram_init (void)
 	gd->bd->bi_dram[0].size	 = PHYS_SDRAM_1_SIZE;
 
 #ifdef CONFIG_CM_SPD_DETECT
-    {
+		{
 extern void dram_query(void);
 	unsigned long cm_reg_sdram;
 	unsigned long sdram_shift;
 
 	dram_query();	/* Assembler accesses to CM registers */
-			/* Queries the SPD values	      */
+			/* Queries the SPD values */
 
 	/* Obtain the SDRAM size from the CM SDRAM register */
 
 	cm_reg_sdram = *(volatile ulong *)(CM_BASE + OS_SDRAM);
-	/*   Register	      SDRAM size
+	/*	 Register				SDRAM size
 	 *
-	 *   0xXXXXXXbbb000bb	 16 MB
-	 *   0xXXXXXXbbb001bb	 32 MB
-	 *   0xXXXXXXbbb010bb	 64 MB
-	 *   0xXXXXXXbbb011bb	128 MB
-	 *   0xXXXXXXbbb100bb	256 MB
+	 *	 0xXXXXXXbbb000bb	 16 MB
+	 *	 0xXXXXXXbbb001bb	 32 MB
+	 *	 0xXXXXXXbbb010bb	 64 MB
+	 *	 0xXXXXXXbbb011bb	128 MB
+	 *	 0xXXXXXXbbb100bb	256 MB
 	 *
 	 */
 	sdram_shift		 = ((cm_reg_sdram & 0x0000001C)/4)%4;
 	gd->bd->bi_dram[0].size	 = 0x01000000 << sdram_shift;
 
-    }
+		}
 #endif /* CM_SPD_DETECT */
 
 	return 0;
 }
 
 /* The Integrator/CP timer1 is clocked at 1MHz
- * can be divided by 16 or 256
- * and can be set up as a 32-bit timer
+ * that clock can be divided by 16 or 256
+ * Timer 1 can be set up as a 32-bit down counter
  */
-/* U-Boot expects a 32 bit timer, running at CONFIG_SYS_HZ */
-/* Keep total timer count to avoid losing decrements < div_timer */
+/* U-Boot expects a 32 bit timer, running at CFG_HZ (which is NOT configurable but constant 1000 Hz) */
+/* Although all these functions return ulong == 64 bit */
 static unsigned long long total_count = 0;
-static unsigned long long lastdec;	 /* Timer reading at last call	   */
+static unsigned long long last_count;	 /* Timer reading at last call	   */
 static unsigned long long div_clock = 1; /* Divisor applied to timer clock */
 static unsigned long long div_timer = 1; /* Divisor to convert timer reading
 					  * change to U-Boot ticks
 					  */
-/* CONFIG_SYS_HZ = CONFIG_SYS_HZ_CLOCK/(div_clock * div_timer) */
-static ulong timestamp;		/* U-Boot ticks since startup	      */
+/* CFG_HZ = CONFIG_SYS_HZ_CLOCK/(div_clock * div_timer) */
+static ulong timestamp;		/* U-Boot ticks since startup */
 
-#define TIMER_LOAD_VAL ((ulong)0xFFFFFFFF)
-#define READ_TIMER (*(volatile ulong *)(CONFIG_SYS_TIMERBASE+4))
+#define TIMER_LOAD_VAL ((u32)0xFFFFFFFF)
+#define READ_TIMER     (*(volatile u32 *)(CONFIG_SYS_TIMERBASE+4))
 
-/* all function return values in U-Boot ticks i.e. (1/CONFIG_SYS_HZ) sec
- *  - unless otherwise stated
+/* 
+ * All functions return values in U-Boot ticks i.e. (1/CFG_HZ) sec
+ * - unless otherwise stated
  */
 
 /* starts up a counter
- * - the Integrator/CP timer can be set up to issue an interrupt */
+ * - the Integrator/CP timer can be set up to issue an interrupt 
+ * - but it isn't here
+ */
 int interrupt_init (void)
 {
 	/* Load timer with initial value */
-	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 0) = TIMER_LOAD_VAL;
+	*(volatile u32 *)(CONFIG_SYS_TIMERBASE + 0) = TIMER_LOAD_VAL;
 	/* Set timer to be
-	 *	enabled		  1
-	 *	periodic	  1
-	 *	no interrupts	  0
-	 *	X		  0
-	 *	divider 1	 00 == less rounding error
-	 *	32 bit		  1
-	 *	wrapping	  0
+	 *	enabled			1
+	 *	periodic		1
+	 *	no interrupts		0
+	 *	X			0
+	 *	clock divisor 1	 	00
+	 *      (if this is changed then 
+	 *       div_clock must be changed 
+	 *       accordingly) 
+	 *	32 bit			1
+	 *	wrapping		0
 	 */
-	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 8) = 0x000000C2;
+	*(volatile u32 *)(CONFIG_SYS_TIMERBASE + 8) = 0x000000C2;
+	div_clock = 1;
+	
 	/* init the timestamp */
-	total_count = 0ULL;
+	total_count = 0UL;
 	reset_timer_masked();
 
-	div_timer  = (unsigned long long)(CONFIG_SYS_HZ_CLOCK / CONFIG_SYS_HZ);
+	div_timer  = (CONFIG_SYS_HZ_CLOCK / CFG_HZ);
 	div_timer /= div_clock;
 
 	return (0);
@@ -195,6 +249,10 @@ void reset_timer (void)
 	reset_timer_masked ();
 }
 
+/*
+ * This function must return milliseconds
+ * For Integrator/CP 1 tick == 1 millisecond
+ */
 ulong get_timer (ulong base_ticks)
 {
 	return get_timer_masked () - base_ticks;
@@ -203,48 +261,80 @@ ulong get_timer (ulong base_ticks)
 void set_timer (ulong ticks)
 {
 	timestamp   = ticks;
-	total_count = (unsigned long long)ticks * div_timer;
+	total_count = ticks * div_timer;
+}
+
+/* Return raw timer count for timing intervals
+ * less than 1 tick e.g. usecs
+ * Caller must test for wrap.....
+ */
+u32 get_timer_raw(void)
+{
+	return READ_TIMER;
 }
 
 /* delay usec useconds */
+/* IntegratorCP uses a down counter */
+/* The counter may wrap */
 void udelay (unsigned long usec)
 {
-	ulong tmo, tmp;
-
-	/* Convert to U-Boot ticks */
-	tmo  = usec * CONFIG_SYS_HZ;
-	tmo /= (1000000L);
-
-	tmp  = get_timer_masked();	/* get current timestamp */
-	tmo += tmp;			/* form target timestamp */
-
-	while (get_timer_masked () < tmo) {/* loop till event */
-		/*NOP*/;
-	}
+	u64 target, elapsed;
+	u32 last_count = get_timer_raw();	/* get current timestamp */
+	u32 now;
+	u32 remainder;
+
+	/* Convert usecs to timer frequency */
+	target   = (u64)usec * (u64)CONFIG_SYS_HZ_CLOCK;
+
+	// Use the kernel macro to avoid errors
+	// __udivdi3 is NOT available
+	// target /= (1000000L);
+	// target /= div_clock;
+
+	remainder = do_div(target, (u32)1000000);
+     	remainder = do_div(target, div_clock);
+
+	if(target){
+
+		elapsed = 0;
+		now = last_count = get_timer_raw();
+
+		while (elapsed < target){
+			if(now > last_count) {
+				/* Must have wrapped */
+				elapsed += last_count + TIMER_LOAD_VAL + 1 - now;
+			} else {
+				elapsed += last_count - now;
+			}
+			last_count = now;
+			now = get_timer_raw();
+		}
+	} /* else usec too small.... */
 }
 
 void reset_timer_masked (void)
 {
-	/* capure current decrementer value    */
-	lastdec	  = (unsigned long long)READ_TIMER;
+	/* capture current decrementer value */
+	last_count		= (unsigned long long)READ_TIMER;
 	/* start "advancing" time stamp from 0 */
 	timestamp = 0L;
 }
 
-/* converts the timer reading to U-Boot ticks	       */
-/* the timestamp is the number of ticks since reset    */
+/* converts the timer reading to U-Boot ticks */
+/* the timestamp is the number of ticks since reset */
+/* returns ticks */
 ulong get_timer_masked (void)
 {
 	/* get current count */
 	unsigned long long now = (unsigned long long)READ_TIMER;
 
-	if(now > lastdec) {
+	if(now > last_count) {
 		/* Must have wrapped */
-		total_count += lastdec + TIMER_LOAD_VAL + 1 - now;
+		total_count += last_count + TIMER_LOAD_VAL + 1 - now;
 	} else {
-		total_count += lastdec - now;
+		total_count += last_count - now;
 	}
-	lastdec	  = now;
+	last_count	  = now;
 
 	/* Reuse "now" */
 	now = total_count;
@@ -254,15 +344,16 @@ ulong get_timer_masked (void)
 	return timestamp;
 }
 
-/* waits specified delay value and resets timestamp */
+/* Waits specified delay value and resets timestamp */
 void udelay_masked (unsigned long usec)
 {
 	udelay(usec);
+	reset_timer_masked();
 }
 
 /*
  * This function is derived from PowerPC code (read timebase as long long).
- * On ARM it just returns the timer value.
+ * On ARM it just returns the timer value since the timer decrements at CFG_HZ.
  */
 unsigned long long get_ticks(void)
 {
@@ -271,9 +362,15 @@ unsigned long long get_ticks(void)
 
 /*
  * Return the timebase clock frequency
- * i.e. how often the timer decrements
+ * i.e. how often the timer count decrements
  */
 ulong get_tbclk (void)
 {
-	return (ulong)(((unsigned long long)CONFIG_SYS_HZ_CLOCK)/div_clock);
+	return CONFIG_SYS_HZ_CLOCK/div_clock;
 }
+
+/*
+ *  u32 get_board_rev() for ARM supplied development boards
+ */
+ARM_SUPPLIED_GET_BOARD_REV
+
diff --git a/board/armltd/integratorcp/split_by_variant.sh b/board/armltd/integratorcp/split_by_variant.sh
index 34422fd..3ba4318 100755
--- a/board/armltd/integratorcp/split_by_variant.sh
+++ b/board/armltd/integratorcp/split_by_variant.sh
@@ -7,49 +7,46 @@ echo    " by Makefile target */"		>> tmp.fil
 echo -n "#define CONFIG_INTEGRATOR"		>> tmp.fil
 echo	 " /* Integrator board */"		>> tmp.fil
 echo -n "#define CONFIG_ARCH_CINTEGRATOR"	>> tmp.fil
-echo     " 1 /* Integrator/CP   */"		>> tmp.fil
-
+echo     " 1 /* Integrator/CP   */"  		>> tmp.fil
+# ---------------------------------------------------------
+#	Set the core module defines according to Core Module
+# ---------------------------------------------------------
 cpu="arm_intcm"
-variant="unknown core module"
+variant="integratorcp"
 
 if [ "$1" = "" ]
 then
 	echo "$0:: No parameters - using arm_intcm"
 else
+	variant=`echo $1 | sed -r s/_config//`
+	
 	case "$1" in
-	ap966)
+	cp966_config)
 	cpu="arm_intcm"
-	variant="unported core module CM966E-S"
 	;;
 
-	ap922_config)
+	cp922_config)
 	cpu="arm_intcm"
-	variant="unported core module CM922T"
 	;;
 
-	integratorcp_config	|	\
-	cp_config)
+	integratorcp_config)
 	cpu="arm_intcm"
-	variant="unspecified core module"
 	;;
 
 	cp922_XA10_config)
 	cpu="arm_intcm"
-	variant="unported core module CM922T_XA10"
-	echo -n "#define CONFIG_CM922T_XA10"		>> tmp.fil
-	echo    " 1 /* CPU core is ARM922T_XA10 */"	>> tmp.fil
+	echo -n "#define CONFIG_CM922T_XA10" 		>> tmp.fil
+	echo    " 1 /* CPU core is ARM922T_XA10 */" 	>> tmp.fil
 	;;
 
 	cp920t_config)
 	cpu="arm920t"
-	variant="Core module CM920T"
-	echo -n "#define CONFIG_CM920T"			>> tmp.fil
+	echo -n "#define CONFIG_CM920T" 		>> tmp.fil
 	echo    " 1 /* CPU core is ARM920T */"		>> tmp.fil
 	;;
 
 	cp926ejs_config)
 	cpu="arm926ejs"
-	variant="Core module CM926EJ-S"
 	echo -n "#define CONFIG_CM926EJ_S"		>> tmp.fil
 	echo    " 1 /* CPU core is ARM926EJ-S */ "	>> tmp.fil
 	;;
@@ -57,21 +54,33 @@ else
 
 	cp946es_config)
 	cpu="arm946es"
-	variant="Core module CM946E-S"
 	echo -n "#define CONFIG_CM946E_S"		>> tmp.fil
 	echo    " 1 /* CPU core is ARM946E-S */ "	>> tmp.fil
 	;;
 
+	cp1026_config)
+	cpu="arm_intcm"
+	echo -n "#define CONFIG_CM1026EJ_S"		>> tmp.fil
+	echo    " 1 /* CPU core is ARM1026J-S */ "	>> tmp.fil
+	;;
+
 	cp1136_config)
 	cpu="arm1136"
-	variant="Core module CM1136EJF-S"
 	echo -n "#define CONFIG_CM1136EJF_S"		>> tmp.fil
 	echo    " 1 /* CPU core is ARM1136JF-S */ "	>> tmp.fil
 	;;
 
+	cp1176_rt_config)
+	cpu="arm_intcm"
+	echo -n "#define CONFIG_CM1176JFZ_S"		>> tmp.fil
+	echo    " 1 /* CPU core is ARM1136JF-S */ "	>> tmp.fil
+	echo -n "#define ARM_1176_CP_RT"		>> tmp.fil
+	echo    " 1 /* FastSIM model */ "	>> tmp.fil
+	;;
+
+	
 	*)
 	echo "$0:: Unknown core module"
-	variant="unknown core module"
 	cpu="arm_intcm"
 	;;
 
@@ -79,6 +88,18 @@ else
 
 fi
 
+# ---------------------------------------------------------
+# Link variant header to integratorcp.h
+# ---------------------------------------------------------
+if [ "$variant" != "integratorcp" ] 
+then
+	if [ -h ./include/configs/$variant.h ] 
+	then
+		rm ./include/configs/$variant.h
+	fi
+	ln -s ./integratorcp.h ./include/configs/$variant.h
+fi
+
 if [ "$cpu" = "arm_intcm" ]
 then
 	echo "/* Core module undefined/not ported */"	>> tmp.fil
@@ -109,6 +130,6 @@ sed -r 's/CPU_FILE/cpu\/'$cpu'\/start.o/; s/#.*//' ${src}board/armltd/integrator
 # ---------------------------------------------------------
 # Complete the configuration
 # ---------------------------------------------------------
-$MKCONFIG -a integratorcp arm $cpu integratorcp armltd;
+$MKCONFIG -a $variant arm $cpu integratorcp armltd;
 echo "Variant:: $variant with core $cpu"
 
diff --git a/board/armltd/realview_eb/Makefile b/board/armltd/realview_eb/Makefile
new file mode 100644
index 0000000..210e2e2
--- /dev/null
+++ b/board/armltd/realview_eb/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= realview_eb.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/armltd/realview_eb/config.mk b/board/armltd/realview_eb/config.mk
new file mode 100644
index 0000000..29221b5
--- /dev/null
+++ b/board/armltd/realview_eb/config.mk
@@ -0,0 +1,5 @@
+#
+# 
+#
+
+TEXT_BASE = 0x01000000
diff --git a/board/armltd/realview_eb/lowlevel_init.S b/board/armltd/realview_eb/lowlevel_init.S
new file mode 100644
index 0000000..cfc8a97
--- /dev/null
+++ b/board/armltd/realview_eb/lowlevel_init.S
@@ -0,0 +1,34 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003, ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+/* Set up the platform, once the cpu has been initialized */
+.globl lowlevel_init
+lowlevel_init:
+
+	/* RTFM later */
+	mov pc, lr
diff --git a/board/armltd/realview_eb/realview_eb.c b/board/armltd/realview_eb/realview_eb.c
new file mode 100644
index 0000000..d38ad47
--- /dev/null
+++ b/board/armltd/realview_eb/realview_eb.c
@@ -0,0 +1,221 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * (C) Copyright 2004
+ * ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * The RealView Emulation BaseBoard provides timers and soft reset
+ * - the cpu code does not need to provide these.
+ */
+#include <common.h>
+
+static ulong timestamp;
+static ulong lastdec;
+
+#define READ_TIMER (*(volatile ulong *)(CONFIG_SYS_TIMERBASE+4))
+
+static void flash__init (void);
+static void ether__init (void);
+static void timer_init(void);
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+    printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+#define COMP_MODE_ENABLE ((unsigned int)0x0000EAEF)
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+		"subs %0, %1, #1\n"
+		"bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_arch_number = MACH_TYPE_REALVIEW_EB;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+
+	gd->flags = 0;
+
+	icache_enable ();
+	flash__init ();
+	ether__init ();
+	timer_init();
+
+	return 0;
+}
+
+
+int misc_init_r (void)
+{
+	setenv("verify", "n");
+	return (0);
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+static void flash__init (void)
+{
+	/* Use the sytem control register to allow writing to flash */
+	unsigned int tmp = *(unsigned int *)(REALVIEW_EB_FLASHCTRL);
+	tmp |= REALVIEW_EB_FLASHPROG_FLVPPEN;
+	*(unsigned int *)(REALVIEW_EB_FLASHCTRL) = tmp;
+}
+/*************************************************************
+ Routine:ether__init
+ Description: take the Ethernet controller out of reset and wait
+	  		   for the EEPROM load to complete.
+*************************************************************/
+static void ether__init (void)
+{
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+int dram_init (void)
+{
+	return 0;
+}
+
+/*
+ * Start the timer
+ * U-Boot expects a 32 bit timer, running at CFG_HZ == 1000
+ * RealView Emulation BaseBoard provides 1 MHz timer
+ */
+static void timer_init(void)
+{
+	/*
+	 * Set clock frequency in system controller:
+	 *	REALVIEW_EB_REFCLK is 32KHz
+	 *	REALVIEW_EB_TIMCLK is 1MHz
+	 */
+	*(volatile unsigned int *)(REALVIEW_EB_SCTL_BASE) |=
+	  ((SP804_TIMCLK << SP804_TIMER0_EnSel) | (SP804_TIMCLK << SP804_TIMER1_EnSel) |
+	   (SP804_TIMCLK << SP804_TIMER2_EnSel) | (SP804_TIMCLK << SP804_TIMER3_EnSel));
+	/*
+	 * Now setup timer0
+	 */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 0) = CONFIG_SYS_TIMER_RELOAD;	/* TimerLoad */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 4) = CONFIG_SYS_TIMER_RELOAD;	/* TimerValue */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 8) |= 0x82;			/* Enabled,
+									 * free running,
+									 * no interrupt,
+									 * 32-bit,
+									 * wrapping
+									 */
+	reset_timer_masked();
+}
+
+int interrupt_init (void){
+	return 0;
+}
+
+/*
+ * Write the system control status register to cause reset
+ */
+void reset_cpu(ulong addr){
+	*(volatile unsigned int *)(REALVIEW_EB_SCTL_BASE + SP810_OS_SCSYSSTAT) = 0x00000000;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+/* ASSUMES timer is ticking at 1 msec			*/
+void udelay (unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	tmo = usec/1000;
+
+	tmp = get_timer (0);		/* get current timestamp */
+
+	if( (tmo + tmp + 1) < tmp )	/* if setting this forward will roll time stamp */
+		reset_timer_masked ();	/* reset "advancing" timestamp to 0, set lastdec value */
+	else
+		tmo += tmp;		/* else, set advancing stamp wake up time */
+
+	while (get_timer_masked () < tmo)/* loop till event */
+		/*NOP*/;
+}
+
+ulong get_timer (ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER/1000;  /* capure current decrementer value time */
+	timestamp = 0;	       	    /* start "advancing" time stamp from 0 */
+}
+
+/* ASSUMES 1MHz timer */
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER/1000;	/* current tick value @ 1 tick per msec */
+
+	if (lastdec >= now) {		/* normal mode (non roll) */
+		/* normal mode */
+		timestamp += lastdec - now; /* move stamp forward with absolute diff ticks */
+	} else {			/* we have overflow of the count down timer */
+		/* nts = ts + ld + (TLV - now)
+		 * ts=old stamp, ld=time that passed before passing through -1
+		 * (TLV-now) amount of time after passing though -1
+		 * nts = new "advancing time stamp"...it could also roll and cause problems.
+		 */
+		timestamp += lastdec + TIMER_LOAD_VAL - now;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+/*
+ *  u32 get_board_rev() for ARM supplied development boards
+ */
+ARM_SUPPLIED_GET_BOARD_REV
+
diff --git a/board/armltd/realview_eb/split_by_variant.sh b/board/armltd/realview_eb/split_by_variant.sh
new file mode 100644
index 0000000..1f2ccb0
--- /dev/null
+++ b/board/armltd/realview_eb/split_by_variant.sh
@@ -0,0 +1,37 @@
+#!/bin/sh
+# ---------------------------------------------------------
+#  Set the core module defines according to Core Module
+# ---------------------------------------------------------
+config="$1"
+# ---------------------------------------------------------
+# Set up the Realview type define
+# ---------------------------------------------------------
+# Use this until later versions provide distinct core tiles
+# ---------------------------------------------------------
+cpu=armct_rv
+if [ "$1" = "" ]
+then
+	echo "$0:: No parameters - using arm-linux-gcc realview_eb_config"
+
+else
+	case "$config" in
+	realview_eb_config)
+	echo "#define CONFIG_REALVIEW_EB" > ./include/config.h
+	;;
+
+	*)
+	echo "$0:: Unrecognised config - using realview_eb_config"
+	echo "#define CONFIG_REALVIEW_EB" > ./include/config.h
+	;;
+
+	esac
+
+fi
+# ---------------------------------------------------------
+#	Ensure correct core object loaded first in U-Boot image
+# ---------------------------------------------------------
+sed -r 's/CPU_FILE/cpu\/'$cpu'\/start.o/; s/#.*//' board/realview_eb/u-boot.lds.template > board/realview_eb/u-boot.lds
+# ---------------------------------------------------------
+# Complete the configuration
+# ---------------------------------------------------------
+./mkconfig -a realview_eb arm $cpu realview_eb
diff --git a/board/armltd/realview_eb/u-boot.lds.template b/board/armltd/realview_eb/u-boot.lds.template
new file mode 100644
index 0000000..0ec8087
--- /dev/null
+++ b/board/armltd/realview_eb/u-boot.lds.template
@@ -0,0 +1,53 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+# Template used during configuration to emsure the core module processor code,
+# from CPU_FILE, is placed at the start of the image */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		CPU_FILE (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/armltd/realview_pb/Makefile b/board/armltd/realview_pb/Makefile
new file mode 100644
index 0000000..6489c61
--- /dev/null
+++ b/board/armltd/realview_pb/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= realview_pb.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/armltd/realview_pb/config.mk b/board/armltd/realview_pb/config.mk
new file mode 100644
index 0000000..29221b5
--- /dev/null
+++ b/board/armltd/realview_pb/config.mk
@@ -0,0 +1,5 @@
+#
+# 
+#
+
+TEXT_BASE = 0x01000000
diff --git a/board/armltd/realview_pb/lowlevel_init.S b/board/armltd/realview_pb/lowlevel_init.S
new file mode 100644
index 0000000..cfc8a97
--- /dev/null
+++ b/board/armltd/realview_pb/lowlevel_init.S
@@ -0,0 +1,34 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003, ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+/* Set up the platform, once the cpu has been initialized */
+.globl lowlevel_init
+lowlevel_init:
+
+	/* RTFM later */
+	mov pc, lr
diff --git a/board/armltd/realview_pb/realview_pb.c b/board/armltd/realview_pb/realview_pb.c
new file mode 100644
index 0000000..c2f5f00
--- /dev/null
+++ b/board/armltd/realview_pb/realview_pb.c
@@ -0,0 +1,235 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * (C) Copyright 2004
+ * ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * The RealView Emulation BaseBoard provides timers and soft reset
+ * - the cpu code does not need to provide these.
+ */
+#include <common.h>
+
+static ulong timestamp;
+static ulong lastdec;
+
+#define READ_TIMER (*(volatile ulong *)(CONFIG_SYS_TIMERBASE+4))
+
+static void flash__init (void);
+static void ether__init (void);
+static void timer_init(void);
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+    printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+#define COMP_MODE_ENABLE ((unsigned int)0x0000EAEF)
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+		"subs %0, %1, #1\n"
+		"bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_REALVIEW_PB1176
+	gd->bd->bi_arch_number = MACH_TYPE_REALVIEW_PB1176;
+#endif
+
+#ifdef CONFIG_REALVIEW_PB11MP
+	gd->bd->bi_arch_number = MACH_TYPE_REALVIEW_PB11MP;
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBA8
+	gd->bd->bi_arch_number = MACH_TYPE_REALVIEW_PBA8;
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBX
+	gd->bd->bi_arch_number = MACH_TYPE_REALVIEW_PBX;
+#endif
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+
+	gd->flags = 0;
+
+	icache_enable ();
+	flash__init ();
+	ether__init ();
+	timer_init();
+
+	return 0;
+}
+
+
+int misc_init_r (void)
+{
+	setenv("verify", "n");
+	return (0);
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+static void flash__init (void)
+{
+	/* Use the sytem control register to allow writing to flash */
+	unsigned int tmp = *(unsigned int *)(REALVIEW_PB_FLASHCTRL);
+	tmp |= REALVIEW_PB_FLASHPROG_FLVPPEN;
+	*(unsigned int *)(REALVIEW_PB_FLASHCTRL) = tmp;
+}
+/*************************************************************
+ Routine:ether__init
+ Description: take the Ethernet controller out of reset and wait
+	  		   for the EEPROM load to complete.
+*************************************************************/
+static void ether__init (void)
+{
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+int dram_init (void)
+{
+	return 0;
+}
+
+/*
+ * Start the timer
+ * U-Boot expects a 32 bit timer, running at CFG_HZ == 1000
+ * RealView Emulation BaseBoard provides 1 MHz timer
+ */
+static void timer_init(void)
+{
+	/*
+	 * Set clock frequency in system controller:
+	 *	REALVIEW_PB_REFCLK is 32KHz
+	 *	REALVIEW_PB_TIMCLK is 1MHz
+	 */
+	*(volatile unsigned int *)(REALVIEW_PB_SCTL_BASE) |=
+	  ((SP804_TIMCLK << SP804_TIMER0_EnSel) | (SP804_TIMCLK << SP804_TIMER1_EnSel) |
+	   (SP804_TIMCLK << SP804_TIMER2_EnSel) | (SP804_TIMCLK << SP804_TIMER3_EnSel));
+	/*
+	 * Now setup timer0
+	 */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 0) = CONFIG_SYS_TIMER_RELOAD;	/* TimerLoad */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 4) = CONFIG_SYS_TIMER_RELOAD;	/* TimerValue */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 8) |= 0x82;			/* Enabled,
+									 * free running,
+									 * no interrupt,
+									 * 32-bit,
+									 * wrapping
+									 */
+	reset_timer_masked();
+}
+
+int interrupt_init (void){
+	return 0;
+}
+
+/*
+ * Write the system control status register to cause reset
+ */
+void reset_cpu(ulong addr){
+	*(volatile unsigned int *)(REALVIEW_PB_SCTL_BASE + SP810_OS_SCSYSSTAT) = 0x00000000;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+/* ASSUMES timer is ticking at 1 msec			*/
+void udelay (unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	tmo = usec/1000;
+
+	tmp = get_timer (0);		/* get current timestamp */
+
+	if( (tmo + tmp + 1) < tmp )	/* if setting this forward will roll time stamp */
+		reset_timer_masked ();	/* reset "advancing" timestamp to 0, set lastdec value */
+	else
+		tmo += tmp;		/* else, set advancing stamp wake up time */
+
+	while (get_timer_masked () < tmo)/* loop till event */
+		/*NOP*/;
+}
+
+ulong get_timer (ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER/1000;  /* capure current decrementer value time */
+	timestamp = 0;	       	    /* start "advancing" time stamp from 0 */
+}
+
+/* ASSUMES 1MHz timer */
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER/1000;	/* current tick value @ 1 tick per msec */
+
+	if (lastdec >= now) {		/* normal mode (non roll) */
+		/* normal mode */
+		timestamp += lastdec - now; /* move stamp forward with absolute diff ticks */
+	} else {			/* we have overflow of the count down timer */
+		/* nts = ts + ld + (TLV - now)
+		 * ts=old stamp, ld=time that passed before passing through -1
+		 * (TLV-now) amount of time after passing though -1
+		 * nts = new "advancing time stamp"...it could also roll and cause problems.
+		 */
+		timestamp += lastdec + TIMER_LOAD_VAL - now;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+/*
+ *  u32 get_board_rev() for ARM supplied development boards
+ */
+ARM_SUPPLIED_GET_BOARD_REV
+
diff --git a/board/armltd/realview_pb/split_by_variant.sh b/board/armltd/realview_pb/split_by_variant.sh
new file mode 100644
index 0000000..76134e3
--- /dev/null
+++ b/board/armltd/realview_pb/split_by_variant.sh
@@ -0,0 +1,49 @@
+#!/bin/sh
+# ---------------------------------------------------------
+#  Set the core module defines according to Core Module
+# ---------------------------------------------------------
+config="$1"
+# ---------------------------------------------------------
+# Set up the Realview type define
+# ---------------------------------------------------------
+# Use this until later versions provide distinct core tiles
+# ---------------------------------------------------------
+cpu=armct_rv
+if [ "$1" = "" ]
+then
+	echo "$0:: No parameters - using arm-linux-gcc realview_pb1176_config"
+else
+	case "$config" in
+
+	realview_pb1176_config)
+	echo "#define CONFIG_REALVIEW_PB1176" > ./include/config.h
+	;;
+
+	realview_pb11mp_config)
+	echo "#define CONFIG_REALVIEW_PB11MP" > ./include/config.h
+	;;
+
+	realview_pba8_config)
+	echo "#define CONFIG_MACH_REALVIEW_PBA8" > ./include/config.h
+	;;
+
+	realview_pbx_config)
+	echo "#define CONFIG_MACH_REALVIEW_PBX" > ./include/config.h
+	;;
+
+	*)
+	echo "$0:: Unrecognised config - using realview_pb1176_config"
+	echo "#define CONFIG_REALVIEW_PB1176" > ./include/config.h
+	;;
+
+	esac
+
+fi
+# ---------------------------------------------------------
+#	Ensure correct core object loaded first in U-Boot image
+# ---------------------------------------------------------
+sed -r 's/CPU_FILE/cpu\/'$cpu'\/start.o/; s/#.*//' board/realview_pb/u-boot.lds.template > board/realview_pb/u-boot.lds
+# ---------------------------------------------------------
+# Complete the configuration
+# ---------------------------------------------------------
+./mkconfig -a realview_pb arm $cpu realview_pb
diff --git a/board/armltd/realview_pb/u-boot.lds.template b/board/armltd/realview_pb/u-boot.lds.template
new file mode 100644
index 0000000..0ec8087
--- /dev/null
+++ b/board/armltd/realview_pb/u-boot.lds.template
@@ -0,0 +1,53 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+# Template used during configuration to emsure the core module processor code,
+# from CPU_FILE, is placed at the start of the image */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		CPU_FILE (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/armltd/versatile/Makefile b/board/armltd/versatile/Makefile
index 044a429..80a2c7e 100644
--- a/board/armltd/versatile/Makefile
+++ b/board/armltd/versatile/Makefile
@@ -25,7 +25,7 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)lib$(BOARD).a
 
-COBJS	:= versatile.o flash.o
+COBJS	:= versatile.o
 SOBJS	:= lowlevel_init.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
diff --git a/board/armltd/versatile/split_by_variant.sh b/board/armltd/versatile/split_by_variant.sh
index 475e5a3..79cf329 100755
--- a/board/armltd/versatile/split_by_variant.sh
+++ b/board/armltd/versatile/split_by_variant.sh
@@ -5,36 +5,53 @@
 # ---------------------------------------------------------
 # Set up the Versatile type define
 # ---------------------------------------------------------
-
 mkdir -p ${obj}include
-variant=PB926EJ-S
-if [ "$1" = "" ]
+variant=versatilepb
+
+if [ "$1" == "" ]
 then
 	echo "$0:: No parameters - using versatilepb_config"
 	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
-	variant=PB926EJ-S
+	variant=versatilepb
 else
 	case "$1" in
-	versatilepb_config	|	\
 	versatile_config)
 	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
 	;;
 
+	versatilepb_config)
+	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
+	;;
+
 	versatileab_config)
 	echo "#define CONFIG_ARCH_VERSATILE_AB" > ${obj}include/config.h
-	variant=AB926EJ-S
+	variant=versatileab
 	;;
 
 
 	*)
 	echo "$0:: Unrecognised config - using versatilepb_config"
 	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
-	variant=PB926EJ-S
+	variant=versatilepb
 	;;
 
 	esac
 
 fi
+
+
+# ---------------------------------------------------------
+# Link variant header to versatile.h
+# ---------------------------------------------------------
+if [ "$variant" != "versatile" ] 
+then
+	if [ -h ./include/configs/$variant.h ] 
+	then
+		rm ./include/configs/$variant.h
+	fi
+	ln -s ./versatile.h ./include/configs/$variant.h
+fi
+
 # ---------------------------------------------------------
 # Complete the configuration
 # ---------------------------------------------------------
diff --git a/board/armltd/versatile/versatile.c b/board/armltd/versatile/versatile.c
index 0f35caa..7f404e3 100644
--- a/board/armltd/versatile/versatile.c
+++ b/board/armltd/versatile/versatile.c
@@ -34,9 +34,13 @@
  */
 
 #include <common.h>
+#include <command.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
+static ulong timestamp;
+static ulong lastdec;
+
 #if defined(CONFIG_SHOW_BOOT_PROGRESS)
 void show_boot_progress(int progress)
 {
@@ -68,8 +72,11 @@ int board_init (void)
 	  ((VERSATILE_TIMCLK << VERSATILE_TIMER1_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER2_EnSel) |
 	   (VERSATILE_TIMCLK << VERSATILE_TIMER3_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER4_EnSel));
 
-	/* arch number of Versatile Board */
-	gd->bd->bi_arch_number = MACH_TYPE_VERSATILE_PB;
+#ifdef CONFIG_ARCH_VERSATILE_AB
+	gd->bd->bi_arch_number = MACH_TYPE_VERSATILE_AB;
+#else
+ 	gd->bd->bi_arch_number = MACH_TYPE_VERSATILE_PB;
+#endif
 
 	/* adress of boot parameters */
 	gd->bd->bi_boot_params = 0x00000100;
@@ -96,3 +103,141 @@ int dram_init (void)
 {
 	return 0;
 }
+
+void timer_init(void){
+	/*
+	 * Set clock frequency in the system controller:
+	 *	VERSATILE_REFCLK is 32KHz
+	 *	VERSATILE_TIMCLK is 1MHz
+	 */
+	*(volatile unsigned int *)(VERSATILE_SCTL_BASE) |=
+		((VERSATILE_TIMCLK << VERSATILE_TIMER1_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER2_EnSel) |
+		 (VERSATILE_TIMCLK << VERSATILE_TIMER3_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER4_EnSel));
+	/*
+	 * Now setup timer0
+	 */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 0) = CONFIG_SYS_TIMER_RELOAD;	/* TimerLoad */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 4) = CONFIG_SYS_TIMER_RELOAD;	/* TimerValue */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 8) |= 0x82;			/* Enabled,
+									 * free running,
+									 * no interrupt,
+									 * 32-bit,
+									 * wrapping
+									 */
+	reset_timer_masked();
+}
+int interrupt_init (void){
+	return 0;
+}
+
+/*
+ * Write the system control status register to cause reset
+ */
+void reset_cpu(ulong addr){
+	*(volatile unsigned int *)(VERSATILE_SCTL_BASE + SP810_OS_SCSYSSTAT) = 0x00000000;
+}
+/* delay x useconds AND perserve advance timstamp value */
+/* ASSUMES timer is ticking at 1 msec			*/
+void udelay (unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	tmo = usec/1000;
+
+	tmp = get_timer (0);		/* get current timestamp */
+
+	if( (tmo + tmp + 1) < tmp )	/* if setting this forward will roll time stamp */
+		reset_timer_masked ();	/* reset "advancing" timestamp to 0, set lastdec value */
+	else
+		tmo += tmp;		/* else, set advancing stamp wake up time */
+
+	while (get_timer_masked () < tmo)/* loop till event */
+		/*NOP*/;
+}
+
+ulong get_timer (ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER/1000;	/* capure current decrementer value time */
+	timestamp = 0;			/* start "advancing" time stamp from 0 */
+}
+
+/* ASSUMES 1MHz timer */
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER/1000;	/* current tick value @ 1 tick per msec */
+
+	if (lastdec >= now) {		/* normal mode (non roll) */
+		/* normal mode */
+		timestamp += lastdec - now; /* move stamp forward with absolute diff ticks */
+	} else {
+		/* we have overflow of the count down timer */
+		/* nts = ts + ld + (TLV - now)
+		 * ts=old stamp, ld=time that passed before passing through -1
+		 * (TLV-now) amount of time after passing though -1
+		 * nts = new "advancing time stamp"...it could also roll and cause problems.
+		 */
+		timestamp += lastdec + TIMER_LOAD_VAL - now;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+/*
+ *  u32 get_board_rev() for ARM supplied development boards
+ */
+ARM_SUPPLIED_GET_BOARD_REV
+
+#ifdef CONFIG_REVISION_TAG
+#if (CONFIG_COMMANDS & CFG_CMD_REV)
+
+
+int do_show_rev(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	u32 * rev_reg = (u32*)ARM_SUPPLIED_REVISION_REGISTER; 
+	u32 info = *rev_reg;				
+
+
+
+	/* Versatile specific 
+	 * perhaps we can generalize
+	 *	[31:24] Read MAN , manufacturer 		: 0x41 = ARM
+	 *	[23:16] Read ARCH, architecture		: 0x00 = ARM926
+	 *	[15:12] Read FPGA type			: 0x7 = XC2V2000
+	 *	[11:04] Read Build value (ARM internal use)
+	 *	[03:00] Read REV , Major revision 	: 0x4 = multilayer AHB
+	 */
+	 printf("===================================================\n");
+	 printf("Versatile board info register indicates:-          \n");
+	 printf("Manufacturer   0x%08x (0x00000041 == ARM)   \n"		, ((info & 0xFF000000)/0x1000000));
+	 printf("Architecture   0x%08x (0x00000000 == ARM926)\n"		, ((info & 0x00FF0000)/0x10000));
+#ifdef CONFIG_ARCH_VERSATILE_AB	/* Versatile AB */
+	 printf("FPGA type      0x%04x     (0x0008 == XC2S300E)\n"     		, ((info & 0x0000F000)/0x1000));
+#else
+	 printf("FPGA type      0x%04x     (0x0007 == XC2V2000)\n"     		, ((info & 0x0000F000)/0x1000));
+#endif	 
+	 printf("Build number   0x%08x\n"					, ((info & 0x00000FF0)/0x10));
+	 printf("Major Revision 0x%04x     (0x0004 == Multi-layer AHB) \n"	,  (info & 0x0000000F));
+	 printf("===================================================\n");
+	 return 1;
+}
+/***************************************************/
+
+U_BOOT_CMD(
+	show_rev,	1,	1,	do_show_rev,
+	"show_rev - Parse the board revision info\n",
+	NULL
+);
+
+#endif	/* CFG_CMD_REV */
+#endif /* CONFIG_REVISION_TAG */
+
+
+
+
diff --git a/cpu/arm1136/config.mk b/cpu/arm1136/config.mk
index 6ab0dd3..d685062 100644
--- a/cpu/arm1136/config.mk
+++ b/cpu/arm1136/config.mk
@@ -25,6 +25,7 @@ PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
 
 # Make ARMv5 to allow more compilers to work, even though its v6.
 PLATFORM_CPPFLAGS += -march=armv5
+PLATFORM_CPPFLAGS += -mno-thumb-interwork
 # =========================================================================
 #
 # Supply options according to compiler version
diff --git a/cpu/arm720t/config.mk b/cpu/arm720t/config.mk
index 3cae1dc..4cf66c7 100644
--- a/cpu/arm720t/config.mk
+++ b/cpu/arm720t/config.mk
@@ -26,6 +26,7 @@ PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
 	-msoft-float
 
 PLATFORM_CPPFLAGS += -march=armv4 -mtune=arm7tdmi
+PLATFORM_CPPFLAGS += -mno-thumb-interwork
 # =========================================================================
 #
 # Supply options according to compiler version
diff --git a/cpu/arm920t/config.mk b/cpu/arm920t/config.mk
index 38718a3..a380564 100644
--- a/cpu/arm920t/config.mk
+++ b/cpu/arm920t/config.mk
@@ -25,6 +25,7 @@ PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
 	-msoft-float
 
 PLATFORM_CPPFLAGS += -march=armv4
+PLATFORM_CPPFLAGS += -mno-thumb-interwork
 # =========================================================================
 #
 # Supply options according to compiler version
diff --git a/cpu/arm926ejs/interrupts.c b/cpu/arm926ejs/interrupts.c
index 7a41f0b..1e2d9e2 100644
--- a/cpu/arm926ejs/interrupts.c
+++ b/cpu/arm926ejs/interrupts.c
@@ -38,7 +38,8 @@
 #include <common.h>
 #include <arm926ejs.h>
 
-#ifdef CONFIG_INTEGRATOR
+#if defined(CONFIG_INTEGRATOR) || defined(CONFIG_AT91CAP9ADK)	\
+	|| defined(CONFIG_VERSATILE)
 
 	/* Timer functionality supplied by Integrator board (AP or CP) */
 
@@ -54,4 +55,5 @@ int interrupt_init (void)
 	return 0;
 }
 
-#endif /* CONFIG_INTEGRATOR */
+#endif 
+/* CONFIG_INTEGRATOR || defined(CONFIG_AT91CAP9ADK) || CONFIG_VERSATILE */
diff --git a/cpu/arm926ejs/versatile/Makefile b/cpu/arm926ejs/versatile/Makefile
index c335d5c..4beb972 100644
--- a/cpu/arm926ejs/versatile/Makefile
+++ b/cpu/arm926ejs/versatile/Makefile
@@ -26,7 +26,7 @@ include $(TOPDIR)/config.mk
 LIB	= $(obj)lib$(SOC).a
 
 COBJS	= timer.o
-SOBJS	= reset.o
+# SOBJS	= reset.o
 
 SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
diff --git a/cpu/arm926ejs/versatile/timer.c b/cpu/arm926ejs/versatile/timer.c
index 9ac867e..8dfe7c0 100755
--- a/cpu/arm926ejs/versatile/timer.c
+++ b/cpu/arm926ejs/versatile/timer.c
@@ -38,7 +38,9 @@
 #include <common.h>
 #include <arm926ejs.h>
 
-#define TIMER_LOAD_VAL 0xffffffff
+#ifndef TIMER_LOAD_VAL
+# define TIMER_LOAD_VAL 0xffffffff
+#endif
 
 /* macro to read the 32 bit timer */
 #define READ_TIMER (*(volatile ulong *)(CONFIG_SYS_TIMERBASE+4))
diff --git a/cpu/arm946es/config.mk b/cpu/arm946es/config.mk
index 6190e16..1da7f40 100644
--- a/cpu/arm946es/config.mk
+++ b/cpu/arm946es/config.mk
@@ -25,6 +25,7 @@ PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
 	 -msoft-float
 
 PLATFORM_CPPFLAGS +=  -march=armv4
+PLATFORM_CPPFLAGS += -mno-thumb-interwork
 # =========================================================================
 #
 # Supply options according to compiler version
diff --git a/cpu/armct_rv/Makefile b/cpu/armct_rv/Makefile
new file mode 100644
index 0000000..203278e
--- /dev/null
+++ b/cpu/armct_rv/Makefile
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(CPU).a
+
+START	= start.o
+OBJS	= interrupts.o cpu.o
+
+all:	.depend $(START) $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/armct_rv/config.mk b/cpu/armct_rv/config.mk
new file mode 100644
index 0000000..4caa0ab
--- /dev/null
+++ b/cpu/armct_rv/config.mk
@@ -0,0 +1,35 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8
+
+PLATFORM_CPPFLAGS += -march=armv4
+PLATFORM_CPPFLAGS += -mno-thumb-interwork
+# =========================================================================
+#
+# Supply options according to compiler version
+#
+# =========================================================================
+PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
+
diff --git a/cpu/armct_rv/cpu.c b/cpu/armct_rv/cpu.c
new file mode 100644
index 0000000..5954e44
--- /dev/null
+++ b/cpu/armct_rv/cpu.c
@@ -0,0 +1,91 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * CPU specific code for a core tile with an unknown cpu
+ * - hence fairly empty......
+ */
+
+#include <common.h>
+#include <command.h>
+
+int cpu_init (void)
+{
+	/*
+	 * setup up stacks if necessary
+	 */
+#ifdef CONFIG_USE_IRQ
+	DECLARE_GLOBAL_DATA_PTR;
+
+	IRQ_STACK_START = _armboot_start - CONFIG_SYS_MALLOC_LEN - CONFIG_SYS_GBL_DATA_SIZE - 4;
+	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
+#endif
+	return 0;
+}
+
+int cleanup_before_linux (void)
+{
+	/*
+	 * this function is called just before we call linux
+	 * it prepares the processor for linux
+	 *
+	 * we turn off caches etc ...
+	 */
+
+	disable_interrupts ();
+
+	/* Since the CT has unknown processor we do not support
+	 * cache operations
+	 */
+
+	return (0);
+}
+
+int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	extern void reset_cpu (ulong addr);
+
+	disable_interrupts ();
+	reset_cpu (0);
+	/*NOTREACHED*/
+	return (0);
+}
+
+/* May not be cached processor on the CT - do nothing */
+void icache_enable (void)
+{
+}
+
+void icache_disable (void)
+{
+}
+
+/* return "disabled" */
+int icache_status (void)
+{
+	return 0;
+}
diff --git a/cpu/armct_rv/interrupts.c b/cpu/armct_rv/interrupts.c
new file mode 100644
index 0000000..ddbdb11
--- /dev/null
+++ b/cpu/armct_rv/interrupts.c
@@ -0,0 +1,203 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments <www.ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002-2004
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2004
+ * Philippe Robin, ARM Ltd. <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/proc-armv/ptrace.h>
+
+#if (	!defined(CONFIG_REALVIEW_EB)		&&	\
+	!defined(CONFIG_REALVIEW_PB1176)	&& 	\
+	!defined(CONFIG_REALVIEW_PB11MP)	&&	\
+	!defined(CONFIG_MACH_REALVIEW_PBA8)	&&	\
+	!defined(CONFIG_MACH_REALVIEW_PBX))
+/* Only to be used with the RealView Boards */
+ * Allows U-Boot to be used with any ARM supplied core tile (CT),
+ * provided the ARM boot monitor, or similar software,
+ * runs first to set up the platform e.g. map writeable memory to 0x00000000
+ * - see RealView Board User Guides
+ *
+#endif
+extern void reset_cpu(ulong addr);
+
+#ifdef CONFIG_USE_IRQ
+/* enable IRQ interrupts */
+void enable_interrupts (void)
+{
+	unsigned long temp;
+	__asm__ __volatile__("mrs %0, cpsr\n"
+			     "bic %0, %0, #0x80\n"
+			     "msr cpsr_c, %0"
+			     : "=r" (temp)
+			     :
+			     : "memory");
+}
+
+
+/*
+ * disable IRQ/FIQ interrupts
+ * returns true if interrupts had been enabled before we disabled them
+ */
+int disable_interrupts (void)
+{
+	unsigned long old,temp;
+	__asm__ __volatile__("mrs %0, cpsr\n"
+			     "orr %1, %0, #0xc0\n"
+			     "msr cpsr_c, %1"
+			     : "=r" (old), "=r" (temp)
+			     :
+			     : "memory");
+	return (old & 0x80) == 0;
+}
+#else
+void enable_interrupts (void)
+{
+	return;
+}
+int disable_interrupts (void)
+{
+	return 0;
+}
+#endif
+
+
+void bad_mode (void)
+{
+#ifdef DEBUG
+	panic ("U-Boot:: Bad mode - halting in a loop\n");
+	while(1){
+		;
+	}
+#else
+	panic ("U-Boot::Resetting CPU ...\n");
+	reset_cpu (0);
+#endif
+}
+
+void show_regs (struct pt_regs *regs)
+{
+	unsigned long flags;
+	const char *processor_modes[] = {
+	"USER_26",	"FIQ_26",	"IRQ_26",	"SVC_26",
+	"UK4_26",	"UK5_26",	"UK6_26",	"UK7_26",
+	"UK8_26",	"UK9_26",	"UK10_26",	"UK11_26",
+	"UK12_26",	"UK13_26",	"UK14_26",	"UK15_26",
+	"USER_32",	"FIQ_32",	"IRQ_32",	"SVC_32",
+	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
+	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
+	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
+	};
+
+	flags = condition_codes (regs);
+
+	printf ("pc : [<%08lx>]    lr : [<%08lx>]\n"
+		"sp : %08lx  ip : %08lx  fp : %08lx\n",
+		instruction_pointer (regs),
+		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
+	printf ("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
+		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
+	printf ("r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\n",
+		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
+	printf ("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
+		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
+	printf ("Flags: %c%c%c%c",
+		flags & CC_N_BIT ? 'N' : 'n',
+		flags & CC_Z_BIT ? 'Z' : 'z',
+		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
+	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
+		interrupts_enabled (regs) ? "on" : "off",
+		fast_interrupts_enabled (regs) ? "on" : "off",
+		processor_modes[processor_mode (regs)],
+		thumb_mode (regs) ? " (T)" : "");
+}
+
+void do_undefined_instruction (struct pt_regs *pt_regs)
+{
+	printf ("undefined instruction handler\n");
+	printf ("Originally installed by U-Boot\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_software_interrupt (struct pt_regs *pt_regs)
+{
+	printf ("software interrupt handler\n");
+	printf ("Originally installed by U-Boot\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_prefetch_abort (struct pt_regs *pt_regs)
+{
+	printf ("prefetch abort handler\n");
+	printf ("Originally installed by U-Boot\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_data_abort (struct pt_regs *pt_regs)
+{
+	printf ("data abort handler\n");
+	printf ("Originally installed by U-Boot\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_not_used (struct pt_regs *pt_regs)
+{
+	printf ("not used\n");
+	printf ("Originally installed by U-Boot\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_fiq (struct pt_regs *pt_regs)
+{
+	printf ("fast interrupt request handler\n");
+	printf ("Originally installed by U-Boot\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_irq (struct pt_regs *pt_regs)
+{
+	printf ("interrupt request handler\n");
+	printf ("Originally installed by U-Boot\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+/* The timer functionality is supplied by the board */
+/* - see board/realview<>.c */
diff --git a/cpu/armct_rv/start.S b/cpu/armct_rv/start.S
new file mode 100644
index 0000000..18baec8
--- /dev/null
+++ b/cpu/armct_rv/start.S
@@ -0,0 +1,372 @@
+/*
+ *  armboot - Startup Code for unknown CPU-core
+ *
+ *  Copyright (c) 2003  Texas Instruments
+ *
+ *  ----- Adapted for OMAP1610 OMAP730 from ARM925t code ------
+ *
+ *  Copyright (c) 2001	Marius Grger <mag@sysgo.de>
+ *  Copyright (c) 2002	Alex Zpke <azu@sysgo.de>
+ *  Copyright (c) 2002	Gary Jennejohn <gj@denx.de>
+ *  Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
+ *  Copyright (c) 2003	Kshitij <kshitij@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+/*
+ *************************************************************************
+ *
+ * Jump vector table
+ *
+ *************************************************************************
+ */
+
+.globl _start
+_start:
+	b	start_code
+	ldr	pc, _undefined_instruction
+	ldr	pc, _software_interrupt
+	ldr	pc, _prefetch_abort
+	ldr	pc, _data_abort
+	ldr	pc, _not_used
+	ldr	pc, _irq
+	ldr	pc, _fiq
+
+_undefined_instruction:
+	.word undefined_instruction
+_software_interrupt:
+	.word software_interrupt
+_prefetch_abort:
+	.word prefetch_abort
+_data_abort:
+	.word data_abort
+_not_used:
+	.word not_used
+_irq:
+	.word irq
+_fiq:
+	.word fiq
+
+	.balignl 16,0xdeadbeef
+
+/*
+ *************************************************************************
+ *
+ * Startup Code (called from the ARM reset exception vector)
+ *
+ * do important init only if we don't start from memory!
+ * setup memory and board specific bits prior to relocation.
+ * relocate armboot to ram
+ * setup stack
+ *
+ *************************************************************************
+ */
+
+_TEXT_BASE:
+	.word	TEXT_BASE /* address of _start in the linked image */
+
+.globl _armboot_start
+_armboot_start:
+	.word _start
+
+/*
+ * These are defined in the board-specific linker script.
+ */
+.globl _bss_start
+_bss_start:
+	.word __bss_start
+
+.globl _bss_end
+_bss_end:
+	.word _end
+
+#ifdef CONFIG_USE_IRQ
+/* IRQ stack memory (calculated at run-time) */
+.globl IRQ_STACK_START
+IRQ_STACK_START:
+	.word	0x0badc0de
+
+/* IRQ stack memory (calculated at run-time) */
+.globl FIQ_STACK_START
+FIQ_STACK_START:
+	.word 0x0badc0de
+#endif
+
+
+/*
+ * the actual start code
+ */
+.globl start_code
+start_code:
+	/*
+	 * set the cpu to SVC32 mode
+	 */
+	mrs	r0,cpsr
+	bic	r0,r0,#0x1f
+	orr	r0,r0,#0xd3
+	msr	cpsr,r0
+
+	/*
+	 * we do sys-critical inits only at reboot,
+	 * not when booting from ram!
+	 */
+#ifdef CONFIG_INIT_CRITICAL
+	bl	cpu_init_crit
+#endif
+
+relocate:				/* relocate U-Boot to RAM	    */
+	adr	r0, _start		/* pc relative  address of label    */
+	ldr	r1, _TEXT_BASE		/* linked image address of label    */
+	cmp	r0, r1                  /* test if we run from flash or RAM */
+	beq	stack_setup             /* ifeq we are in the RAM copy      */
+
+	ldr	r2, _armboot_start
+	ldr	r3, _bss_start
+	sub	r2, r3, r2		/* r2 <- size of armboot            */
+	add	r2, r0, r2		/* r2 <- source end address         */
+
+copy_loop:
+	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
+	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
+	cmp	r0, r2			/* until source end addreee [r2]    */
+	ble	copy_loop
+
+	/* Set up the stack						    */
+stack_setup:
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CONFIG_SYS_MALLOC_LEN	/* malloc area                      */
+	sub	r0, r0, #CONFIG_SYS_GBL_DATA_SIZE /* bdinfo                        */
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+
+clear_bss:
+	ldr	r0, _bss_start		/* find start of bss segment        */
+	ldr	r1, _bss_end		/* stop here                        */
+	mov 	r2, #0x00000000		/* clear                            */
+
+clbss_l:str	r2, [r0]		/* clear loop...                    */
+	add	r0, r0, #4
+	cmp	r0, r1
+	ble	clbss_l
+
+	ldr	pc, _start_armboot
+
+_start_armboot:
+	.word start_armboot
+
+/*
+ *************************************************************************
+ *
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************
+ */
+
+cpu_init_crit:
+	/* Assumes the ARM boot monitor, or user software,
+	 * has initialized the platform
+	 * To run direct from reset any such 
+	 * initialisation code must be added here
+	 */
+	mov	pc, lr		/* back to my caller */
+/*
+ *************************************************************************
+ *
+ * Interrupt handling
+ *
+ *************************************************************************
+ */
+
+@
+@ IRQ stack frame.
+@
+#define S_FRAME_SIZE	72
+
+#define S_OLD_R0	68
+#define S_PSR		64
+#define S_PC		60
+#define S_LR		56
+#define S_SP		52
+
+#define S_IP		48
+#define S_FP		44
+#define S_R10		40
+#define S_R9		36
+#define S_R8		32
+#define S_R7		28
+#define S_R6		24
+#define S_R5		20
+#define S_R4		16
+#define S_R3		12
+#define S_R2		8
+#define S_R1		4
+#define S_R0		0
+
+#define MODE_SVC 0x13
+#define I_BIT	 0x80
+
+/*
+ * use bad_save_user_regs for abort/prefetch/undef/swi ...
+ * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
+ */
+
+	.macro	bad_save_user_regs
+	@ carve out a frame on current user stack
+	sub	sp, sp, #S_FRAME_SIZE
+	stmia	sp, {r0 - r12}	@ Save user registers (now in svc mode) r0-r12
+
+	ldr	r2, _armboot_start
+	sub	r2, r2, #(CONFIG_STACKSIZE+CONFIG_SYS_MALLOC_LEN)
+	sub	r2, r2, #(CONFIG_SYS_GBL_DATA_SIZE+8)  @ set base 2 words into abort stack
+	@ get values for "aborted" pc and cpsr (into parm regs)
+	ldmia	r2, {r2 - r3}
+	add	r0, sp, #S_FRAME_SIZE		@ grab pointer to old stack
+	add	r5, sp, #S_SP
+	mov	r1, lr
+	stmia	r5, {r0 - r3}	@ save sp_SVC, lr_SVC, pc, cpsr
+	mov	r0, sp		@ save current stack into r0 (param register)
+	.endm
+
+	.macro	irq_save_user_regs
+	sub	sp, sp, #S_FRAME_SIZE
+	stmia	sp, {r0 - r12}			@ Calling r0-r12
+	@ !!!! R8 NEEDS to be saved !!!! a reserved stack spot would be good.
+	add	r8, sp, #S_PC
+	stmdb	r8, {sp, lr}^		@ Calling SP, LR
+	str	lr, [r8, #0]		@ Save calling PC
+	mrs	r6, spsr
+	str	r6, [r8, #4]		@ Save CPSR
+	str	r0, [r8, #8]		@ Save OLD_R0
+	mov	r0, sp
+	.endm
+
+	.macro	irq_restore_user_regs
+	ldmia	sp, {r0 - lr}^			@ Calling r0 - lr
+	mov	r0, r0
+	ldr	lr, [sp, #S_PC]			@ Get PC
+	add	sp, sp, #S_FRAME_SIZE
+	subs	pc, lr, #4		@ return & move spsr_svc into cpsr
+	.endm
+
+	.macro get_bad_stack
+	ldr	r13, _armboot_start		@ setup our mode stack
+	sub	r13, r13, #(CONFIG_STACKSIZE+CONFIG_SYS_MALLOC_LEN)
+	sub	r13, r13, #(CONFIG_SYS_GBL_DATA_SIZE+8) @ reserved a couple spots in abort stack
+
+	str	lr, [r13]	@ save caller lr in position 0 of saved stack
+	mrs	lr, spsr	@ get the spsr
+	str	lr, [r13, #4]	@ save spsr in position 1 of saved stack
+	mov	r13, #MODE_SVC	@ prepare SVC-Mode
+	@ msr	spsr_c, r13
+	msr	spsr, r13	@ switch modes, make sure moves will execute
+	mov	lr, pc		@ capture return pc
+	movs	pc, lr		@ jump to next instruction & switch modes.
+	.endm
+
+	.macro get_irq_stack			@ setup IRQ stack
+	ldr	sp, IRQ_STACK_START
+	.endm
+
+	.macro get_fiq_stack			@ setup FIQ stack
+	ldr	sp, FIQ_STACK_START
+	.endm
+
+/*
+ * exception handlers
+ */
+	.align  5
+.globl undefined_instruction
+undefined_instruction:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_undefined_instruction
+
+	.align	5
+.globl software_interrupt
+software_interrupt:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_software_interrupt
+
+	.align	5
+.globl prefetch_abort
+prefetch_abort:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_prefetch_abort
+
+	.align	5
+.globl data_abort
+data_abort:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_data_abort
+
+	.align	5
+.globl not_used
+not_used:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_not_used
+
+#ifdef CONFIG_USE_IRQ
+	.align	5
+.globl irq
+irq:
+	get_irq_stack
+	irq_save_user_regs
+	bl 	do_irq
+	irq_restore_user_regs
+
+	.align	5
+.globl fiq
+fiq:
+	get_fiq_stack
+	/* someone ought to write a more effiction fiq_save_user_regs */
+	irq_save_user_regs
+	bl 	do_fiq
+	irq_restore_user_regs
+
+#else
+
+	.align	5
+.globl irq
+irq:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_irq
+
+	.align	5
+.globl fiq
+fiq:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_fiq
+
+#endif
diff --git a/doc/README-integrator b/doc/README-integrator
index 4daf341..df4d5b2 100644
--- a/doc/README-integrator
+++ b/doc/README-integrator
@@ -1,12 +1,12 @@
 
 		U-Boot for ARM Integrator Development Platforms
 
-			Peter Pearse, ARM Ltd.
-			peter.pearse@arm.com
-			     www.arm.com
+		Peter Pearse, ARM Ltd.
+		peter.pearse@arm.com
+		www.arm.com
 
-Manuals available from :-
-http://www.arm.com/products/DevTools/Hardware_Platforms.html
+Manuals may be available from :-
+http://www.arm.com/documentation/Boards_and_Firmware/index.html
 
 Overview :
 --------
@@ -54,7 +54,7 @@ for ARM Integrator CMs has been added
 
 	cpu/arm_intcm
 
-Otherwise. for example,  the standard CM reset via the CM control register would
+Otherwise, for example, the standard CM reset via the CM control register would
 need placing in each CM processor file......
 
 Code specific to the initialization of the CM, rather than the cpu, and initialization
@@ -64,20 +64,20 @@ of the Integrator board itself, has been placed in
 	board/integrator<>/integrator<>.c
 
 Targets
-=======
+--------
 The U-Boot make targets map to the available core modules as below.
 
 Integrator/AP is no longer available from ARM.
 Core modules marked ** are also no longer available.
 
-ap720t_config		** CM720T
-ap920t_config		** CM920T
+ap720t_config	** CM720T
+ap920t_config	** CM920T
 ap926ejs_config	Integrator Core Module for ARM926EJ-STM
-ap946es_config		Integrator Core Module for ARM946E-STM
-cp920t_config		** CM920T
+ap946es_config	Integrator Core Module for ARM946E-STM
+cp920t_config	** CM920T
 cp926ejs_config	Integrator Core Module for ARM926EJ-STM
-cp946es_config		Integrator Core Module for ARM946E-STM
-cp1136_config		Integrator Core Module ARM1136JF-S  TM
+cp946es_config	Integrator Core Module for ARM946E-STM
+cp1136_config	Integrator Core Module ARM1136JF-STM
 
 The final groups of targets are for core modules where no explicit cpu
 code has yet been added to U-Boot i.e. they all use the same U-Boot binary
@@ -88,15 +88,12 @@ ap922_config			Integrator Core Module for ARM922T TM with ETM
 ap922_XA10_config		Integrator Core Module for ARM922T using Altera Excalibur
 ap7_config			** CM7TDMI
 integratorap_config
-ap_config
-
 
 cp966_config			Integrator Core Module for ARM966E-S TM
 cp922_config			Integrator Core Module for ARM922T TM with ETM
 cp922_XA10_config		Integrator Core Module for ARM922T using Altera Excalibur
 cp1026_config			Integrator Core Module ARM1026EJ-S TM
 integratorcp_config
-cp_config
 
 The Makefile targets call board/integrator<>/split_by_variant.sh
 to configure various defines in include/configs/integrator<>.h
@@ -108,3 +105,11 @@ Because of this mechanism
 > make clean
 must be run before each change in configuration
 *********************************
+
+Board Revision Info
+------------------
+U-Boot extracts the following values into the Revision field
+of /proc/cpuinfo:-
+Integrator/AP :	 SC_ID 		@ 0x11000000
+Integrator/CP :	 CP_IDFIELD	@ 0xCB000000
+See the board User Guide for details of the fields values.
diff --git a/doc/README-realview_eb b/doc/README-realview_eb
new file mode 100644
index 0000000..a3b5c0e
--- /dev/null
+++ b/doc/README-realview_eb
@@ -0,0 +1,44 @@
+
+		U-Boot for ARM RealView Development Platforms
+
+		Peter Pearse, ARM Ltd.
+		peter.pearse@arm.com
+		www.arm.com
+
+Manuals may be available from :-
+http://www.arm.com/documentation/Boards_and_Firmware/index.html
+
+Overview :
+--------
+The RealView Emulation Baseboard can be fitted with one or two
+Core Tiles (CTs). One of the CTs fitted will emulate a particular
+ARM core.
+
+As at 2006/09/07, these include:-
+	ARM7TDMI
+	ARM926EJ-S
+	ARM1136JF-S
+	ARM11 MPCore 
+
+
+Boot Methods :
+------------
+RealView boards may be configured to boot in various ways as described in the User Guide.
+As at 2006/09/07, U-Boot assumes that the board will have been reset to have 
+RAM mapped at 0x00000000 i.e. that the ARM Boot Monitor will have been run.
+For configurations where this is not the case the existing U-Boot code must be modified
+to reset the board state correctly.
+See the RealView EB User Guide and the ARM PrimeCell System Controller (SP810) TRM
+sipplied with the product.
+
+Configuring U-Boot :
+------------------
+The makefile contains one target for the REalView EB, realview_eb_config.
+The U-Boot built to this configuration can be used with any CT.
+
+Board Revision Info
+------------------
+U-Boot extracts the following values into the Revision field
+of /proc/cpuinfo:-
+	SYS_ID  @ 0x10000000
+See the board User Guide for details of the fields values.
diff --git a/doc/README-versatile b/doc/README-versatile
new file mode 100644
index 0000000..630eb50
--- /dev/null
+++ b/doc/README-versatile
@@ -0,0 +1,44 @@
+
+		U-Boot for ARM Versatile Development Platforms
+
+		Peter Pearse, ARM Ltd.
+		peter.pearse@arm.com
+		www.arm.com
+
+Manuals may be available from :-
+http://www.arm.com/documentation/Boards_and_Firmware/index.html
+
+Overview :
+--------
+There are two Versatile variants:-
+	The Versatile Application Baseboard for ARM926EJ-S (Versatile AB926-EJS)
+	The Versatile Platform    Baseboard for ARM926EJ-S (Versatile PB926-EJS)
+Both are fitted with an ARM926-EJS Development Chip.
+
+Boot Methods :
+------------
+Versatile boards may be configured to boot in various ways as described in the User Guide.
+As at 2006/09/07, U-Boot assumes that the board will have been reset to have 
+RAM mapped at 0x00000000 i.e. that the ARM Boot Monitor will have been run.
+For configurations where this is not the case the existing U-Boot code must be modified
+to reset the board state correctly.
+See section "Removing boot remapping and enabling SDRAM at 0x0" in the User Guide.
+
+Configuring U-Boot :
+------------------
+The makefile contains targets for Versatile platforms of both types.
+	versatileab_config
+	versatilepb_config
+	versatile_config
+
+Note that versatile_config is the original target.
+It has been retained for backward compatibility and is identical to
+versatilepb_config. 
+
+Board Revision Info
+------------------
+U-Boot extracts the following values into the Revision field
+of /proc/cpuinfo:-
+Versatile/AB :	 SYS_ID  @ 0x10000000
+Versatile/PB :	 SYS_ID  @ 0x10000000       
+See the board User Guide for details of the fields values.
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index a360a50..f83d212 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -63,6 +63,7 @@ COBJS-$(CONFIG_DRIVER_S3C4510_ETH) += s3c4510b_eth.o
 COBJS-$(CONFIG_SH_ETHER) += sh_eth.o
 COBJS-$(CONFIG_DRIVER_SMC91111) += smc91111.o
 COBJS-$(CONFIG_DRIVER_SMC911X) += smc911x.o
+COBJS-$(CONFIG_DRIVER_SMC_RV) += smc_rv.o
 COBJS-$(CONFIG_TIGON3) += tigon3.o bcm570x_autoneg.o 5701rls.o
 COBJS-$(CONFIG_TSEC_ENET) += tsec.o
 COBJS-$(CONFIG_TSI108_ETH) += tsi108_eth.o
diff --git a/drivers/net/smc9118.c b/drivers/net/smc9118.c
new file mode 100644
index 0000000..6ac1018
--- /dev/null
+++ b/drivers/net/smc9118.c
@@ -0,0 +1,983 @@
+/*------------------------------------------------------------------------
+ . smc9118.c
+ . This is a driver for SMSC's LAN9118 single-chip Ethernet device.
+ .
+ . (C) Copyright 2006 ARM Ltd. <www.arm.com>
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ .
+ . Device information contained in this file was obtained from the LAN9118
+ . manual from SMC <www.smsc.com>.
+ .
+ . author:
+ .	Peter Pearse				( peter.pearse@arm.com)
+ .
+ . Sources:
+ .    o	  SMSC LAN9118 databook (www.smsc.com)
+ .    o	  drivers/smc91111.c
+ .
+ . History:
+ .	2006.10.24	Peter Pearse	Initial version based on drivers/smc91111.c	
+ .                                      - Dropped board specific code
+ .                                      - Dropped #if 0 code, 
+ .                                        it's in smc91111.c if you want it 
+ .                                      - Made all but interface functions static
+ .                                      - Add in ARM smc9118 code
+ ----------------------------------------------------------------------------*/
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include "smc9118.h"
+#include <net.h>
+
+#ifdef CONFIG_DRIVER_SMC9118
+
+#define SMC9118_DEV_NAME "SMC9118"
+
+#ifndef CONFIG_SMC9118_BASE
+	include/configs/<board>.h must define the base address of the device registers
+#endif
+
+#define SMC9118_DBG 0
+
+#if SMC9118_DBG > 1
+static const char version[] =
+	"smc9118.c:v1.0 06/10/24 by Peter Pearse <peter.pearse@arm.com>\n";
+#endif
+
+#if (SMC9118_DBG > 2 )
+# define PRINTK3(args...) printf(args)
+#else
+# define PRINTK3(args...)
+#endif
+
+#if SMC9118_DBG > 1
+# define PRINTK2(args...) printf(args)
+#else
+# define PRINTK2(args...)
+#endif
+
+#ifdef SMC9118_DBG
+# define PRINTK(args...) printf(args)
+#else
+# define PRINTK(args...)
+#endif
+
+#if SMC9118_DBG > 0
+
+static void smsc9118_print_mac_registers(void)
+{
+    unsigned int read;
+    int i;
+
+    i = 0;
+    read = 0;
+
+    for(i = 1; i <= 0xC; i++) {
+        smsc9118_mac_regread(i, &read);
+        debug("MAC Register %02d: 0x%08x\n",i,read);
+    }
+
+    debug("\n");
+    return;
+}
+static void smsc9118_print_registers(void){
+    volatile unsigned int *i;
+
+    for  (i = (volatile unsigned int *)CONFIG_SMC9118_BASE; (int)i < (int)SMSC9118_RESERVED3; i++){
+        debug("Register @%p 0x%08x\n",i, *i);
+    }
+
+} 
+static void smsc9118_print_phy_registers(void)
+{
+    unsigned short read;
+    unsigned int i;
+
+    i = 0;
+    read = 0;
+    for(i = 0; i <= 6; i++) {
+        smsc9118_phy_regread(i, &read);
+        debug("PHY Register %02d: 0x%08x\n",i,read);
+    }
+    smsc9118_phy_regread(i = 17, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 18, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 27, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 29, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 30, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 31, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    debug("\n");
+    return;
+}
+#endif /* SMC9118_DBG > 0 */
+
+/*-----------------------------------------------------------------
+ .
+ .  The driver can be entered at any of the following entry points.
+ .
+ .------------------------------------------------------------------  */
+int  eth_init(bd_t *bd);
+void eth_halt(void);
+int  eth_rx(void);
+int  eth_send(volatile void *packet, int length);
+
+#ifdef SHARED_RESOURCES
+/*
+ * Resource swapper
+ */
+void swap_to(int device_id);
+#endif
+
+/*
+ * ----------------------------------------------------------
+ *
+ * Chip register access routines
+ *
+ * ----------------------------------------------------------
+ */
+static int smsc9118_mac_regread(unsigned char regoffset, unsigned int *data)
+{
+    unsigned int val, maccmd;
+    int timedout;
+    int error;
+    ulong start;
+
+    error = 0;
+    val = *SMSC9118_MAC_CSR_CMD;
+    if(!(val & ((unsigned int)1 << 31))) {    // Make sure there's no pending operation
+        maccmd = 0;
+        maccmd |= regoffset;
+        maccmd |= ((unsigned int)1 << 30);     // Indicates read
+        maccmd |= ((unsigned int)1 << 31);     // Start bit
+        *SMSC9118_MAC_CSR_CMD = maccmd; // Start operation
+
+	start = get_timer (0);
+        do {
+	    timedout = get_timer(start) > MS50 ? 1 : 0;
+            val = *SMSC9118_BYTE_TEST;  // A no-op read.
+        } while(!timedout && (*SMSC9118_MAC_CSR_CMD & ((unsigned int)1 << 31)));
+
+        if(timedout) {
+            printf("Error: SMSC9118 MAC CSR read operation timed out.\n");
+            error = 1;
+            return error;
+        }
+        *data = *SMSC9118_MAC_CSR_DATA;
+    } else {
+        printf("Warning: SMSC9118 MAC CSR is busy. No data read.\n");
+        *data = 0;
+    }
+    return 0;
+}
+
+static int smsc9118_mac_regwrite(unsigned char regoffset, unsigned int val)
+{
+    unsigned int read, maccmd;
+    int timedout;
+    int error;
+    ulong start;
+
+    debug("MAC[%02d] write 0x%08x \n", regoffset, val);
+
+    error = 0;
+    read = *SMSC9118_MAC_CSR_CMD;
+    if(!(read & ((unsigned int)1 << 31))) { // Make sure there's no pending operation
+        *SMSC9118_MAC_CSR_DATA = val;       // Load data.
+        maccmd = 0;
+        maccmd |= regoffset;
+        maccmd &= ~((unsigned int)1 << 30); // Clear indicates write
+        maccmd |= ((unsigned int)1 << 31);  // Indicate start of operation
+        *SMSC9118_MAC_CSR_CMD = maccmd;
+
+	start = get_timer (0);
+        do {
+	    timedout = get_timer(start) > MS50 ? 1 : 0;
+            read = *SMSC9118_BYTE_TEST;     // A no-op read.
+        } while(!timedout && (*SMSC9118_MAC_CSR_CMD & ((unsigned int)1 << 31)));
+
+        if(timedout) {
+            printf("Error: SMSC9118 MAC CSR write operation timed out.\n");
+            error = 1;
+            return error;
+        }
+    } else {
+        printf("Warning: SMSC9118 MAC CSR is busy. No data written.\n");
+    }
+    return 0;
+}
+
+static int smsc9118_phy_regread(unsigned char regoffset, unsigned short *data)
+{
+    unsigned int val, phycmd; int error;
+    int timedout;
+    ulong start;
+
+    error = 0;
+
+    smsc9118_mac_regread(SMSC9118_MAC_MII_ACC, &val);
+
+    if(!(val & 1)) {				// Not busy
+        phycmd = 0;
+        phycmd |= (1 << 11);			// 1 to [15:11]
+        phycmd |= ((regoffset & 0x1F) << 6);	// Put regoffset to [10:6]
+        phycmd &= ~(1 << 1);			// Clear [1] indicates read.
+        phycmd |= (1 << 0);			// Set [0] indicates operation start
+
+        smsc9118_mac_regwrite(SMSC9118_MAC_MII_ACC, phycmd);
+
+	        val = 0;
+        timedout = 0;
+	start = get_timer (0);
+        do {
+	    timedout = get_timer(start) > MS50 ? 1 : 0;
+            smsc9118_mac_regread(SMSC9118_MAC_MII_ACC,&val);
+        } while(!timedout && (val & ((unsigned int)1 << 0)));
+
+        if(timedout) {
+            printf("Error: SMSC9118 MAC MII read operation timed out.\n");
+            error = 1;
+            return error;
+        }
+        smsc9118_mac_regread(SMSC9118_MAC_MII_DATA, &val);
+
+    } else {
+        printf("Warning: SMSC9118 MAC MII is busy. No data read.\n");
+        val = 0;
+    }
+    *data = (unsigned short)(val & 0xFFFF);
+    return 0;
+}
+
+static int smsc9118_phy_regwrite(unsigned char regoffset, unsigned short data)
+{
+    unsigned int val, phycmd, u32data; int error;
+    int timedout;
+    ulong start;
+
+    u32data = (unsigned int)data;
+
+    debug("PHY[%02d] write 0x%08x \n", regoffset, u32data);
+    smsc9118_mac_regread(SMSC9118_MAC_MII_ACC, &val);
+
+    if(!(val & 1)) {    // Not busy
+        smsc9118_mac_regwrite(SMSC9118_MAC_MII_DATA, u32data); // Load the data
+        phycmd = 0;
+        phycmd |= (1 << 11);                    // 1 to [15:11]
+        phycmd |= ((regoffset & 0x1F) << 6);     // Put regoffset to [10:6]
+        phycmd |= (1 << 1);                     // Set [1] indicates write.
+        phycmd |= (1 << 0);                     // Set [0] indicates operation start
+        smsc9118_mac_regwrite(SMSC9118_MAC_MII_ACC, phycmd);   // Start operation
+
+        phycmd = 0;
+        timedout = 0;
+
+	start = get_timer (0);
+        do {
+	    timedout = get_timer(start) > MS50 ? 1 : 0;
+            smsc9118_mac_regread(SMSC9118_MAC_MII_ACC, &phycmd);
+        } while(!timedout && (phycmd & (1 << 0)));
+
+        if(timedout) {
+            printf("Error: SMSC9118 MAC MII write operation timed out.\n");
+            error = 1;
+            return error;
+        }
+
+    } else {
+        printf("Warning: SMSC9118 MAC MII is busy. No data written.\n");
+    }
+    return 0;
+}
+
+/*
+ ------------------------------------------------------------
+ .
+ . Internal routines
+ .
+ ------------------------------------------------------------
+*/
+/*
+ * Functions left as in/outu16, even for ARM where ARM WORD == 32 bits == (2* Other Architecture Word)
+ * until we decide we can't use the common functions.....
+ */
+#ifdef CONFIG_SMC_USE_IOFUNCS
+/*
+ * input and output functions
+ * - the access macros defined in smc9118.h may not 
+ *   work for other boards - they have only been tested on 
+ *   ARM RealViewEB Revision D boards 
+ *
+ *   This code is copied from smc91111.c (functions & types renamed),
+ *   however 16 bit access may be different for SMC9118 
+ *   - see the datasheet & test well before use
+ *
+ */
+# if defined(CONFIG_SMC_USE_32_BIT)
+	32 bit access functions not yet provided
+# else
+static inline u16 SMC9118_inu16(u32 offset);
+static inline void SMC9118_outu16(u16 value, u32 offset);
+static inline u8 SMC9118_inu8(u32 offset);
+static inline void SMC9118_outu8(u8 value, u32 offset);
+static inline void SMC9118_ins16(u32 offset, volatile uchar* buf, u32 len);
+static inline void SMC9118_outs16(u32 offset, uchar* buf, u32 len);
+
+#define barrier() __asm__ __volatile__("": : :"memory")
+
+#define SMC9118_BASE_ADDRESS CONFIG_SMC9118_BASE
+
+static inline u16 SMC9118_inu16(u32 offset)
+{
+	u16 v;
+	v = *((volatile u16*)(SMC9118_BASE_ADDRESS+offset));
+	barrier(); *(volatile u32*)(0xc0000000);
+	return v;
+}
+
+static inline void SMC9118_outu16(u16 value, u32 offset)
+{
+	*((volatile u16*)(SMC9118_BASE_ADDRESS+offset)) = value;
+	barrier(); *(volatile u32*)(0xc0000000);
+}
+
+static inline u8 SMC9118_inu8(u32 offset)
+{
+	u16  _w;
+
+	_w = SMC9118_inu16(offset & ~((u32)1));
+	return (offset & 1) ? (u8)(_w >> 8) : (u8)(_w);
+}
+
+static inline void SMC9118_outu8(u8 value, u32 offset)
+{
+	u16  _w;
+
+	_w = SMC9118_inu16(offset & ~((u32)1));
+	if (offset & 1)
+			*((volatile u16*)(SMC9118_BASE_ADDRESS+(offset & ~((u32)1)))) = (value<<8) | (_w & 0x00ff);
+	else
+			*((volatile u16*)(SMC9118_BASE_ADDRESS+offset)) = value | (_w & 0xff00);
+}
+
+static inline void SMC9118_ins16(u32 offset, volatile uchar* buf, u32 len)
+{
+	volatile u16 *p = (volatile u16 *)buf;
+
+	while (len-- > 0) {
+		*p++ = SMC9118_inu16(offset);
+		barrier();
+		*((volatile u32*)(0xc0000000));
+	}
+}
+
+static inline void SMC9118_outs16(u32 offset, uchar* buf, u32 len)
+{
+	volatile u16 *p = (volatile u16 *)buf;
+
+	while (len-- > 0) {
+		SMC9118_outu16(*p++, offset);
+		barrier();
+		*(volatile u32*)(0xc0000000);
+	}
+}
+# endif
+#endif  /* CONFIG_SMC_USE_IOFUNCS */
+
+// Returns smsc9118 id.
+static unsigned int smsc9118_read_id(void)
+{
+    return *SMSC9118_ID_REV;
+}
+
+static int smsc9118_check_id(void)
+{
+    int error;
+    unsigned int id;
+    error = 0;
+
+    id = smsc9118_read_id();
+
+    switch(((id >> 16) & 0xFFFF)) {
+        case 0x118:
+            // If bottom and top halves of the words are the same
+            if(((id >> 16) & 0xFFFF) == (id & 0xFFFF)) {
+                printf("Error: The SMSC9118 bus is in 16-bit mode. 32-bit mode was expected.\n");
+                error = 1;
+                return error;
+            } else {
+                printf("SMSC9118 is identified successfully.\n");
+                break;
+            }
+
+        default:
+            printf("Error: SMSC9118 id reads: 0x%08x, either an unknown chip, or error.\n",id);
+            error = 1;
+            break;
+    }
+
+    if((id & 0xFFFF) == 0) {
+        printf("Error: This test is not intended for this chip revision.\n");
+        error = 1;
+    }
+
+    return error;
+}
+
+// Initiates a soft reset, returns failure or success.
+static __inline int smsc9118_soft_reset(void)
+{
+    int timedout = 0;
+    ulong start;
+
+    // Soft reset
+    *SMSC9118_HW_CFG |= 1;
+
+    // Wait
+    start = get_timer(0);
+    while (!timedout && (*SMSC9118_HW_CFG & 1)){
+    	timedout = get_timer(start) < MS10 ? 0 : 1;
+    }
+
+    return timedout;
+}
+
+
+static 
+__inline 
+void smsc9118_set_txfifo(unsigned int val)
+{
+    // 2kb minimum, 14kb maximum
+    if(val < 2 || val > 14)
+        return;
+
+    *SMSC9118_HW_CFG = val << 16;
+}
+
+static int smsc9118_wait_eeprom(void)
+{
+    int timedout = 0;
+    // Wait
+    ulong start = get_timer(0);
+    while (!timedout && (*SMSC9118_E2P_CMD & ((unsigned int) 1 << 31))){
+    	timedout = get_timer(start) < MS50 ? 0 : 1;
+    }
+
+    return timedout;
+}
+
+static 
+__inline 
+void smsc9118_init_irqs(void)
+{
+	*SMSC9118_INT_EN    = 0;
+	*SMSC9118_INT_STS   = 0xFFFFFFFF;
+	*SMSC9118_IRQ_CFG   = 0x22000100;   //irq deassertion at 220 usecs.
+}
+
+/* 
+ * If ethaddr environment variable has a valid values, set the MAC address to it,
+ * otherwise check that the MAC address loaded in the smc9118 is valid
+ * Note that we do not change the value of the MAC address stored in the smc9118 EEPROM (the auto-loaded MAC)
+ *
+ * Datasheet has 12:34:56:78:9A:BC stored as ADDRH 0xBC9A
+ *		 ADDRH 0x....BC9A
+ *		 ADDRL 0x12345678
+ *		 0x12 transmitted first
+ * This code gets them in the same order in the TX buffer as the smc91111
+ *
+ * Returns 1 on success
+ */
+int smc9118_set_valid_ethaddr(void){
+	unsigned int mac_low;
+	unsigned int mac_high;
+	uchar mac[6];
+	int env_size = 0, env_present = 0, reg;
+	char *s = NULL, *endp, dummy_mac[] = "11:22:33:44:55:66";
+	char s_env_mac[0x18];
+
+	/* Try for ethadd from environment */
+	env_size = getenv_r ("ethaddr", s_env_mac, sizeof (s_env_mac));
+	if ((env_size > 0) && (env_size != sizeof (dummy_mac))) {	/* exit if env is bad */
+		printf ("\n*** ERROR: ethaddr is not set properly!!\n");
+	} else {
+		env_present = 1;
+	}
+
+	if (env_present) {
+		s = s_env_mac;
+
+		/* Environment string to mac numbers */
+		for (reg = 0; reg < 6; ++reg) { 
+			mac[reg] = s ? simple_strtoul (s, &endp, 16) : 0;
+			if (s)
+				s = (*endp) ? endp + 1 : endp;
+		}
+		mac_high =                                             (mac[5] * 0x100) + mac[4];
+		mac_low =  (mac[3] * 0x1000000) + (mac[2] * 0x10000) + (mac[1] * 0x100) + mac[0];
+	} else {
+		/* read from smc9118 */
+		if(*SMSC9118_E2P_CMD & 1) {
+        		// Read current auto-loaded mac address.
+    			smsc9118_mac_regread(SMSC9118_MAC_ADDRH, &mac_high);
+    			smsc9118_mac_regread(SMSC9118_MAC_ADDRL, &mac_low);
+			env_present = 1;
+		}
+	}
+	if(env_present){
+		/* Set the MAC address int the smc9118 registers */
+		debug("MAC address is about to be set to high 0x%08x low 0x%08x\n", mac_high, mac_low);
+		smsc9118_mac_regwrite(SMSC9118_MAC_ADDRH, mac_high);
+		smsc9118_mac_regwrite(SMSC9118_MAC_ADDRL, mac_low);
+	}
+	return env_present; 
+}
+
+static __inline int smsc9118_check_phy(void)
+{
+    unsigned short phyid1, phyid2;
+
+    smsc9118_phy_regread(SMSC9118_PHY_ID1,&phyid1);
+    smsc9118_phy_regread(SMSC9118_PHY_ID2,&phyid2);
+    debug("PHY ID1: 0x%08x, PHY ID2: 0x%08x\n\n",phyid1, phyid2);
+    return ((phyid1 == 0xFFFF && phyid2 == 0xFFFF) ||
+            (phyid1 == 0x0 && phyid2 == 0x0));
+}
+static __inline int smsc9118_reset_phy(void)
+{
+	unsigned short read;
+	int error;
+
+	debug("smsc9118_reset_phy()\n");
+
+	error = 0;
+
+	if(smsc9118_phy_regread(SMSC9118_PHY_BCONTROL, &read)) {
+		printf("Error: PHY BCONTROL read failed.\n");
+		error = 1;
+	} else {
+
+		read |= (1 << 15);
+		if(smsc9118_phy_regwrite(SMSC9118_PHY_BCONTROL, read)) {
+			printf("Error: PHY BCONTROL write failed.\n");
+			error = 1;
+		}
+	}
+	return error;
+}
+
+/* Advertise all speeds and pause capabilities */
+static __inline void smsc9118_advertise_cap(void)
+{
+    unsigned short aneg_adv;
+    aneg_adv = 0;
+
+    smsc9118_phy_regread(SMSC9118_PHY_ANEG_ADV, &aneg_adv);
+    debug("advertise_cap: PHY_ANEG_ADV before write: 0x%08x\n",aneg_adv);
+    aneg_adv |= 0xDE0;
+
+    smsc9118_phy_regwrite(SMSC9118_PHY_ANEG_ADV, aneg_adv);
+    smsc9118_phy_regread(SMSC9118_PHY_ANEG_ADV, &aneg_adv);
+    debug("advertise_cap: PHY_ANEG_ADV: after write: 0x%08x\n",aneg_adv);
+    return;
+}
+static 
+__inline 
+void smsc9118_establish_link(void)
+{
+    unsigned short bcr;
+
+    smsc9118_phy_regread(SMSC9118_PHY_BCONTROL, &bcr);
+    debug("establish link: PHY_BCONTROL before write: 0x%08x\n",bcr);
+    bcr |= (1 << 12) | (1 << 9);
+    smsc9118_phy_regwrite(SMSC9118_PHY_BCONTROL, bcr);
+    smsc9118_phy_regread(SMSC9118_PHY_BCONTROL, &bcr);
+    debug("establish link: PHY_BCONTROL after write: 0x%08x\n", bcr);
+
+    {
+        unsigned int hw_cfg;
+
+        hw_cfg = 0;
+        hw_cfg = *SMSC9118_HW_CFG;
+
+        hw_cfg &= 0xF0000;
+        hw_cfg |= (1 << 20);
+        *SMSC9118_HW_CFG = hw_cfg;
+    }
+
+    return;
+}
+static 
+__inline 
+void smsc9118_enable_xmit(void)
+{
+    *SMSC9118_TX_CFG = 0x2; // Enable transmission
+    return;
+}
+
+static __inline void smsc9118_enable_mac_xmit(void)
+{
+    unsigned int mac_cr;
+
+    mac_cr = 0;
+    smsc9118_mac_regread(SMSC9118_MAC_CR, &mac_cr);
+
+    mac_cr |= (1 << 3);     // xmit enable
+    mac_cr |= (1 << 28);    // Heartbeat disable
+
+    smsc9118_mac_regwrite(SMSC9118_MAC_CR, mac_cr);
+    return;
+}
+
+static __inline void smsc9118_enable_mac_recv(void)
+{
+    unsigned int mac_cr;
+
+    mac_cr = 0;
+    smsc9118_mac_regread(SMSC9118_MAC_CR, &mac_cr);
+    mac_cr |= (1 << 2);     // Recv enable
+    smsc9118_mac_regwrite(SMSC9118_MAC_CR, mac_cr);
+
+    return;
+}
+
+
+static __inline void smsc9118_disable_mac_xmit(void)
+{
+    unsigned int mac_cr;
+
+    mac_cr = 0;
+    smsc9118_mac_regread(SMSC9118_MAC_CR, &mac_cr);
+
+    mac_cr &= ~(1 << 3);     // xmit enable
+    mac_cr &= ~(1 << 28);    // Heartbeat disable
+
+    smsc9118_mac_regwrite(SMSC9118_MAC_CR, mac_cr);
+    return;
+}
+static __inline void smsc9118_disable_xmit(void)
+{
+    *SMSC9118_TX_CFG = 0; // Disable trasmission
+    return;
+}
+
+static __inline void smsc9118_disable_mac_recv(void)
+{
+    unsigned int mac_cr;
+
+    mac_cr = 0;
+    smsc9118_mac_regread(SMSC9118_MAC_CR, &mac_cr);
+    mac_cr &= ~(1 << 2);     // Recv enable
+    smsc9118_mac_regwrite(SMSC9118_MAC_CR, mac_cr);
+
+    return;
+}
+
+
+
+#define SMC9118_DEFAULT_TXFIFO_KB	5
+/*
+ * Note that the datasheet states that an interrupt status bits is set regardless
+ * of the setting of the interrupt enable bit for that interrupt.
+ * i.e. we don't have to enable interrupts for a polled driver.
+ */
+static int smsc9118_initialise(void)
+{
+	int error = 1;
+	ulong start;
+
+	if(smsc9118_check_id()) {
+		printf("Reading the Ethernet ID register failed.\n"
+		"Check that a SMSC9118 device is present on the system @ %p.\n", (void*)CONFIG_SMC9118_BASE);
+	} else if(smsc9118_soft_reset()) {
+		printf("Error: SMSC9118 soft reset failed to complete.\n");
+	} else {
+		smsc9118_set_txfifo(SMC9118_DEFAULT_TXFIFO_KB);
+
+		// Sets automatic flow control thresholds, and backpressure
+		// threshold to defaults specified.
+		*SMSC9118_AFC_CFG = 0x006E3740;
+
+		if(smsc9118_wait_eeprom()) {
+			printf("Error: EEPROM failed to finish initialisation.\n");
+		} else {
+
+			// Configure GPIOs as LED outputs.
+			*SMSC9118_GPIO_CFG = 0x70070000;
+
+			smsc9118_init_irqs();
+		
+			/* Configure MAC addresses */
+			// Set from environment if present
+			// else check valid
+			if(smc9118_set_valid_ethaddr()){
+
+				if(smsc9118_check_phy()) {
+					printf("Error: SMSC9118 PHY not present.\n");
+				} else {
+
+					if(smsc9118_reset_phy()) {
+						printf("Error: SMSC9118 PHY reset failed.\n");
+					} else {
+						unsigned short phyreset = 0;
+
+						// Wait
+						start = get_timer(0);
+						while (get_timer(start) < MS100){
+							;
+						}
+
+						// Checking whether phy reset completed successfully.
+						smsc9118_phy_regread(SMSC9118_PHY_BCONTROL, &phyreset);
+						if(phyreset & (1 << 15)) {
+							printf("Error: SMSC9118 PHY reset stage failed to complete.\n");
+						} else {
+
+							/* Advertise capabilities */
+							smsc9118_advertise_cap();
+
+							/* Begin to establish link */
+							smsc9118_establish_link();      // bit [12] of BCONTROL seems self-clearing.
+							// Although it's not so in the manual.
+
+							/* Interrupt threshold */
+							*SMSC9118_FIFO_INT = 0xFF000000;
+
+							smsc9118_enable_mac_xmit();
+
+							smsc9118_enable_xmit();
+
+							*SMSC9118_RX_CFG = 0;
+
+							smsc9118_enable_mac_recv();
+
+							// Rx status FIFO level irq threshold
+							*SMSC9118_FIFO_INT &= ~(0xFF);  // Clear 2 bottom nibbles
+
+							// This spin is compulsory otherwise txmit/receive will fail.
+							start = get_timer(0);
+							while (get_timer(start) < MS2000){
+								;
+							}
+							error = 0;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return error;
+}
+
+int smsc9118_recv_packet(unsigned int *recvbuf, int *index)
+{
+    unsigned int rxfifo_inf;    // Tells us the status of rx payload and status fifos.
+    unsigned int rxfifo_stat;
+
+    unsigned int pktsize;
+    unsigned int dwords_to_read;
+
+    debug("recv_packet start: recvbuf: 0x%08x index: %d\n",
+            (unsigned int)recvbuf,*index);
+
+    rxfifo_inf = *SMSC9118_RX_FIFO_INF;
+
+    if(rxfifo_inf & 0xFFFF) { // If there's data
+        rxfifo_stat = *SMSC9118_RX_STAT_PORT;
+        if(rxfifo_stat != 0) {   // Fetch status of this packet
+            pktsize = ((rxfifo_stat >> 16) & 0x3FFF);
+            // debug("recv_packet: rxfifo_stat: 0x%08x, pktsize (bytes): %u\n",rxfifo_stat, pktsize);
+	    if(*SMSC9118_INT_STS & 0x4000){
+	    	printf("Status read RXE is %d\n", *SMSC9118_INT_STS & 0x4000 ? 1 : 0);
+	    	*SMSC9118_INT_STS = 0xFFFFFFFF;
+	    }
+            if(rxfifo_stat & (1 << 15)) {
+                printf("Error occured during receiving of packets on the bus.\n");
+                return 1;
+            } else {
+                /* Below formula (recommended by SMSC9118 code)
+                 * gives 1 more than required. This is because
+                 * a last word is needed for not word aligned packets.
+                 */
+                dwords_to_read = (pktsize + sizeof(unsigned int) - 1) >> 2;
+                debug("recv_packet: dwords_to_read: %u\n",dwords_to_read);
+                // PIO copy of data received:
+                while((*SMSC9118_RX_FIFO_INF & 0x0000FFFF) && (dwords_to_read > 0)) {
+                    recvbuf[*index] = *SMSC9118_RX_DATA_PORT;
+                    // debug("recv_packet: Received word[%d]: 0x%08x\n",*index,recvbuf[*index]);
+                    (*index)++;
+                    dwords_to_read--;
+                }
+	        if(*SMSC9118_INT_STS & 0x4000){
+			printf("Data read RXE is %d\n", *SMSC9118_INT_STS & 0x4000 ? 1 : 0);
+	    		*SMSC9118_INT_STS = 0xFFFFFFFF;
+		}
+            }
+        } else {
+            printf("Error: rx fifo status reads zero where data is available.\n");
+            return 1;
+        }
+    } else {
+        // printf("Error: No data available in rx FIFO\n");
+        return 1;
+    }
+
+    return 0;
+}
+// Does the actual transfer of data to FIFO, note it does no
+// fifo availability checking. This should be done by caller.
+// ASSUMES the whole frame is transferred at once as a single segment
+// ASSUMES chip auto pads to minimum ethernet packet length
+void smsc9118_xfer_to_txFIFO(unsigned char * pkt, unsigned int length)
+{
+    unsigned int txcmd_a, txcmd_b;
+    unsigned int dwords_to_write;
+    volatile unsigned int dwritten;
+    unsigned int *pktptr;
+
+    pktptr = (unsigned int *) pkt;
+    
+    txcmd_a = 0;
+    txcmd_b = 0;
+
+    txcmd_a |= (1 << 12) | (1 << 13);   // First and last segments
+    txcmd_a |= length & 0x7FF;          // [10:0] contains length
+
+    txcmd_b |= ((length & 0xFFFF) << 16); // [31:16] contains length, rather than tag
+    txcmd_b |= length & 0x7FF;          // [10:0] also contains length
+
+    debug("txcmd_a: 0x%08x\n", txcmd_a);
+    debug("txcmd_b: 0x%08x\n", txcmd_b);
+
+    *SMSC9118_TX_DATA_PORT = txcmd_a;
+    *SMSC9118_TX_DATA_PORT = txcmd_b;
+    dwritten = dwords_to_write = (length + sizeof(unsigned int) - 1) >> 2;
+
+
+    // PIO Copy to FIFO. Could replace this with DMA.
+    while(dwords_to_write > 0) {
+         *SMSC9118_TX_DATA_PORT = *pktptr;
+         debug("Transmitting word[%d]: 0x%08x\n",dwritten-dwords_to_write,*pktptr);
+         pktptr++;
+         dwords_to_write--;
+    }
+
+    {
+    	/* 
+	 * Note that the read after read timings from table 6.2 are not used
+	 */
+        volatile unsigned int xmit_stat, xmit_stat2, xmit_inf;
+        int i;
+        xmit_stat = *SMSC9118_TX_STAT_PORT;
+        debug("Finished transfer. TX_STATUS_WORD: 0x%08x\n",xmit_stat);
+        xmit_stat2 = *SMSC9118_TX_STAT_PORT;
+        xmit_inf = *SMSC9118_TX_FIFO_INF;
+        debug("After popping TX_STAT: %08x, TX_INF: 0x%08x\n\n",xmit_stat2, xmit_inf);
+
+	// ASSUMES that the register is emptied
+	// - doesn't seem to do so in real life.......
+        if(xmit_stat2 != 0 ) {
+            debug("The second read of TX_STAT is non-zero. Retry reading a few more times.\n");
+            for(i = 0; i < 6; i++) {
+                xmit_stat2 = *SMSC9118_TX_STAT_PORT;
+                debug("Retry %d: TX_STAT: 0x%08x\n",i+1,xmit_stat2);
+            }
+        }
+    }
+}
+
+int smsc9118_xmit_packet(unsigned char * pktbuf, int pktsize)
+{
+    unsigned int txfifo_inf;
+
+    txfifo_inf = *SMSC9118_TX_FIFO_INF;
+    debug("TX_FIFO_INF: 0x%08x\n", txfifo_inf);
+
+    if((txfifo_inf & 0xFFFF) >= pktsize) {
+        smsc9118_xfer_to_txFIFO(pktbuf, pktsize);
+    } else {
+        printf("Insufficient tx fifo space for packet size %d\n",pktsize);
+        return 1;
+    }
+    return 0;
+}
+
+/*
+ * Ethernet API
+ */
+int eth_init(bd_t *bd) {
+#ifdef SHARED_RESOURCES
+	swap_to(ETHERNET);
+#endif
+       return smsc9118_initialise();
+}
+
+void eth_halt() {
+	PRINTK2("%s: eth_halt\n", SMC9118_DEV_NAME);
+	smsc9118_disable_xmit();
+	smsc9118_disable_mac_xmit();
+	smsc9118_disable_mac_recv();
+}
+
+int eth_rx() {
+	int index = 0;
+    
+    	int rxfifo_inf = *SMSC9118_RX_FIFO_INF;
+
+	/*
+	 *  Any status info???
+	 */
+	if(rxfifo_inf & 0x00FF0000){
+
+		smsc9118_recv_packet((unsigned int *)NetRxPackets[0], &index);
+		if(index) {
+			NetReceive(NetRxPackets[0], index * 4);
+		}
+	}
+	return 4 * index;
+}
+
+int eth_send(volatile void *packet, int length) {
+	int result = 0;
+	int i;
+	debug("Raw packet as %d decimal bytes:\n", length);
+	for(i= 0; i < length; i++){
+		debug(" %02x ", ((char*)packet)[i]);
+		if(!((i+1)%8)){										    
+			debug("\n");									    
+		}											    
+	}												    
+	debug("\n");											    
+	if(!smsc9118_xmit_packet((unsigned char *)packet, length)){
+		result = length;
+	} 
+	return result;
+}
+
+
+#endif /* CONFIG_DRIVER_SMC9118 */
+
diff --git a/drivers/net/smc9118.h b/drivers/net/smc9118.h
new file mode 100644
index 0000000..108fe5f
--- /dev/null
+++ b/drivers/net/smc9118.h
@@ -0,0 +1,524 @@
+/*------------------------------------------------------------------------
+ . smc9118.h
+ . Macros for the LAN9118 Ethernet Driver
+ .
+ . (C) Copyright 2006 ARM Ltd. <www.arm.com>
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . This file contains register information and access macros for
+ . the LAN9118 single chip ethernet controller.  It is a modified
+ . version of the smc91111.h file.
+ .
+ . author:
+ .	Peter Pearse				( peter.pearse@arm.com)
+ .
+ . Sources:
+ .    o	  SMSC LAN9118 databook (www.smsc.com)
+ .    o	  drivers/smc1111.c
+ .
+ . History:
+ .	2006.10.24	Peter Pearse	Initial version based on drivers/smc91111.c	
+ .					- Dropped board specific code
+ .					- Dropped #if 0 code 
+ .                                        - it's in smc91111.h if you want it
+ .					- Dropped 91111 implementation specific code
+ .                                      - Dropped 16bit word & 32bit dword types
+ .                                        as confusing for ARM 32bit word users.
+ .					32 bit, macro access only.
+ ---------------------------------------------------------------------------*/
+#ifndef _SMC9118_H_
+#define _SMC9118_H_
+
+#include <asm/types.h>
+#include <config.h>
+
+
+/*
+ *  Timeouts
+ */
+#define MS10     10
+#define MS50     50
+#define MS100   100
+#define MS2000 2000
+
+/*
+ . DEBUGGING LEVELS
+ .
+ . 0 for normal operation
+ . 1 for slightly more details
+ . >2 for various levels of increasingly useless information
+ .    2 for interrupt tracking, status flags
+ .    3 for packet info
+ .    4 for complete packet dumps
+*/
+/*#define SMC9118_DBG 0 */
+
+/*
+ * These macros may not work on some boards
+ * Also the datasheet states:
+ *
+ * "32 bit access is the native environment for the LAN9118 Ethernet controller"
+ *
+ */
+#ifndef CONFIG_SMC_USE_IOFUNCS 
+
+	#if defined(CONFIG_SMC_USE_32_BIT)
+
+		#define	SMC9118_inu32(reg) 	(*((volatile u32 *)(reg)))
+
+		#define SMC9118_ins32(reg,base,len) 	({	int __i ;  \
+					u32 *__b2;  \
+			    		__b2 = (u32 *) base;  \
+			    		for (__i = 0; __i < len; __i++) {  \
+					  *(__b2 + __i) = SMC9118_inu32(reg);  \
+					  SMC9118_inu32(0);  \
+					};  \
+				})
+
+		#define	SMC9118_outu32(data,reg)	(*((volatile u32 *)(reg)) = data)
+		#define SMC9118_outs32(reg,base,len)	({	int __i; \
+					u32 *__b2; \
+					__b2 = (u32 *) base; \
+					for (__i = 0; __i < len; __i++) { \
+					    SMC9118_outu32( *(__b2 + __i), r); \
+					} \
+				})
+  	#else
+		#ifdef CONFIG_DRIVER_SMC9118
+		16 bit access macros have not been provided
+		#endif
+	#endif /* CONFIG_SMC_USE_32_BIT */
+#else
+	#ifdef CONFIG_DRIVER_SMC9118
+	Access functions have not been provided
+	#endif
+#endif  /* CONFIG_USE_IOFUNCS */
+
+
+/*---------------------------------------------------------------
+ . SMSC registers
+ -----------------------------------------------------------------------*/
+/* Transmit Control Register */
+#define	TCR_REG 	0x0000 	/* transmit control register */
+#define TCR_ENABLE	0x0001	/* When 1 we can transmit */
+#define TCR_LOOP	0x0002	/* Controls output pin LBK */
+#define TCR_FORCOL	0x0004	/* When 1 will force a collision */
+#define TCR_PAD_EN	0x0080	/* When 1 will pad tx frames < 64 bytes w/0 */
+#define TCR_NOCRC	0x0100	/* When 1 will not append CRC to tx frames */
+#define TCR_MON_CSN	0x0400	/* When 1 tx monitors carrier */
+#define TCR_FDUPLX    	0x0800  /* When 1 enables full duplex operation */
+#define TCR_STP_SQET	0x1000	/* When 1 stops tx if Signal Quality Error */
+#define	TCR_EPH_LOOP	0x2000	/* When 1 enables EPH block loopback */
+#define	TCR_SWFDUP	0x8000	/* When 1 enables Switched Full Duplex mode */
+
+#define	TCR_CLEAR	0	/* do NOTHING */
+/* the default settings for the TCR register : */
+/* QUESTION: do I want to enable padding of short packets ? */
+#define	TCR_DEFAULT  	TCR_ENABLE
+
+
+/* EPH Status Register */
+#define EPH_STATUS_REG	0x0002
+#define ES_TX_SUC	0x0001	/* Last TX was successful */
+#define ES_SNGL_COL	0x0002	/* Single collision detected for last tx */
+#define ES_MUL_COL	0x0004	/* Multiple collisions detected for last tx */
+#define ES_LTX_MULT	0x0008	/* Last tx was a multicast */
+#define ES_16COL	0x0010	/* 16 Collisions Reached */
+#define ES_SQET		0x0020	/* Signal Quality Error Test */
+#define ES_LTXBRD	0x0040	/* Last tx was a broadcast */
+#define ES_TXDEFR	0x0080	/* Transmit Deferred */
+#define ES_LATCOL	0x0200	/* Late collision detected on last tx */
+#define ES_LOSTCARR	0x0400	/* Lost Carrier Sense */
+#define ES_EXC_DEF	0x0800	/* Excessive Deferral */
+#define ES_CTR_ROL	0x1000	/* Counter Roll Over indication */
+#define ES_LINK_OK	0x4000	/* Driven by inverted value of nLNK pin */
+#define ES_TXUNRN	0x8000	/* Tx Underrun */
+
+
+/* Receive Control Register */
+#define	RCR_REG		0x0004
+#define	RCR_RX_ABORT	0x0001	/* Set if a rx frame was aborted */
+#define	RCR_PRMS	0x0002	/* Enable promiscuous mode */
+#define	RCR_ALMUL	0x0004	/* When set accepts all multicast frames */
+#define RCR_RXEN	0x0100	/* IFF this is set, we can receive packets */
+#define	RCR_STRIP_CRC	0x0200	/* When set strips CRC from rx packets */
+#define	RCR_ABORT_ENB	0x0200	/* When set will abort rx on collision */
+#define	RCR_FILT_CAR	0x0400	/* When set filters leading 12 bit s of carrier */
+#define RCR_SOFTRST	0x8000 	/* resets the chip */
+
+/* the normal settings for the RCR register : */
+#define	RCR_DEFAULT	(RCR_STRIP_CRC | RCR_RXEN)
+#define RCR_CLEAR	0x0	/* set it to a base state */
+
+/* Counter Register */
+#define	COUNTER_REG	0x0006
+
+/* Memory Information Register */
+#define	MIR_REG		0x0008
+
+/* Receive/Phy Control Register */
+#define	RPC_REG		0x000A
+#define	RPC_SPEED	0x2000	/* When 1 PHY is in 100Mbps mode. */
+#define	RPC_DPLX	0x1000	/* When 1 PHY is in Full-Duplex Mode */
+#define	RPC_ANEG	0x0800	/* When 1 PHY is in Auto-Negotiate Mode */
+#define	RPC_LSXA_SHFT	5	/* Bits to shift LS2A,LS1A,LS0A to lsb */
+#define	RPC_LSXB_SHFT	2	/* Bits to get LS2B,LS1B,LS0B to lsb */
+#define RPC_LED_100_10	(0x00)	/* LED = 100Mbps OR's with 10Mbps link detect */
+#define RPC_LED_RES	(0x01)	/* LED = Reserved */
+#define RPC_LED_10	(0x02)	/* LED = 10Mbps link detect */
+#define RPC_LED_FD	(0x03)	/* LED = Full Duplex Mode */
+#define RPC_LED_TX_RX	(0x04)	/* LED = TX or RX packet occurred */
+#define RPC_LED_100	(0x05)	/* LED = 100Mbps link dectect */
+#define RPC_LED_TX	(0x06)	/* LED = TX packet occurred */
+#define RPC_LED_RX	(0x07)	/* LED = RX packet occurred */
+#define RPC_DEFAULT	( RPC_SPEED | RPC_DPLX | RPC_ANEG	\
+			| (RPC_LED_100_10 << RPC_LSXA_SHFT)	\
+			| (RPC_LED_TX_RX << RPC_LSXB_SHFT)	)
+
+/* Bank 0 0x000C is reserved */
+
+/* Bank Select Register */
+/* All Banks */
+#define BSR_REG	0x000E
+
+
+/* Configuration Reg */
+#define CONFIG_REG	0x0000
+#define CONFIG_EXT_PHY	0x0200	/* 1=external MII, 0=internal Phy */
+#define CONFIG_GPCNTRL	0x0400	/* Inverse value drives pin nCNTRL */
+#define CONFIG_NO_WAIT	0x1000	/* When 1 no extra wait states on ISA bus */
+#define CONFIG_EPH_POWER_EN 0x8000 /* When 0 EPH is placed into low power mode. */
+
+/* Default is powered-up, Internal Phy, Wait States, and pin nCNTRL=low */
+#define CONFIG_DEFAULT	(CONFIG_EPH_POWER_EN)
+
+
+/* Base Address Register */
+#define	BASE_REG	0x0002
+
+
+/* Individual Address Registers */
+#define	ADDR0_REG	0x0004
+#define	ADDR1_REG	0x0006
+#define	ADDR2_REG	0x0008
+
+
+/* General Purpose Register */
+#define	GP_REG		0x000A
+
+
+/* Control Register */
+#define	CTL_REG		0x000C
+#define CTL_RCV_BAD	0x4000 /* When 1 bad CRC packets are received */
+#define CTL_AUTO_RELEASE 0x0800 /* When 1 tx pages are released automatically */
+#define	CTL_LE_ENABLE	0x0080 /* When 1 enables Link Error interrupt */
+#define	CTL_CR_ENABLE	0x0040 /* When 1 enables Counter Rollover interrupt */
+#define	CTL_TE_ENABLE	0x0020 /* When 1 enables Transmit Error interrupt */
+#define	CTL_EEPROM_SELECT 0x0004 /* Controls EEPROM reload & store */
+#define	CTL_RELOAD	0x0002 /* When set reads EEPROM into registers */
+#define	CTL_STORE	0x0001 /* When set stores registers into EEPROM */
+#define CTL_DEFAULT     (0x1A10) /* Autorelease enabled*/
+
+/* MMU Command Register */
+#define MMU_CMD_REG	0x0000
+#define MC_BUSY		1	/* When 1 the last release has not completed */
+#define MC_NOP		(0<<5)	/* No Op */
+#define	MC_ALLOC	(1<<5) 	/* OR with number of 256 byte packets */
+#define	MC_RESET	(2<<5)	/* Reset MMU to initial state */
+#define	MC_REMOVE	(3<<5) 	/* Remove the current rx packet */
+#define MC_RELEASE  	(4<<5) 	/* Remove and release the current rx packet */
+#define MC_FREEPKT  	(5<<5) 	/* Release packet in PNR register */
+#define MC_ENQUEUE	(6<<5)	/* Enqueue the packet for transmit */
+#define MC_RSTTXFIFO	(7<<5)	/* Reset the TX FIFOs */
+
+
+/* Packet Number Register */
+#define	PN_REG		0x0002
+
+
+/* Allocation Result Register */
+#define	AR_REG		0x0003
+#define AR_FAILED	0x80	/* Alocation Failed */
+
+
+/* RX FIFO Ports Register */
+#define RXFIFO_REG	0x0004	/* Must be read as a u16 */
+#define RXFIFO_REMPTY	0x8000	/* RX FIFO Empty */
+
+
+/* TX FIFO Ports Register */
+#define TXFIFO_REG	RXFIFO_REG	/* Must be read as a u16 */
+#define TXFIFO_TEMPTY	0x80	/* TX FIFO Empty */
+
+
+/* Pointer Register */
+#define PTR_REG		0x0006
+#define	PTR_RCV		0x8000 /* 1=Receive area, 0=Transmit area */
+#define	PTR_AUTOINC 	0x4000 /* Auto increment the pointer on each access */
+#define PTR_READ	0x2000 /* When 1 the operation is a read */
+#define PTR_NOTEMPTY	0x0800 /* When 1 _do not_ write fifo DATA REG */
+
+
+/* Data Register */
+#define	SMC9118_DATA_REG	0x0008
+
+
+/* Interrupt Status/Acknowledge Register */
+#define	SMC9118_INT_REG	0x000C
+
+
+/* Interrupt Mask Register */
+#define IM_REG		0x000D
+#define	IM_MDINT	0x80 /* PHY MI Register 18 Interrupt */
+#define	IM_ERCV_INT	0x40 /* Early Receive Interrupt */
+#define	IM_EPH_INT	0x20 /* Set by Etheret Protocol Handler section */
+#define	IM_RX_OVRN_INT	0x10 /* Set by Receiver Overruns */
+#define	IM_ALLOC_INT	0x08 /* Set when allocation request is completed */
+#define	IM_TX_EMPTY_INT	0x04 /* Set if the TX FIFO goes empty */
+#define	IM_TX_INT	0x02 /* Transmit Interrrupt */
+#define IM_RCV_INT	0x01 /* Receive Interrupt */
+
+
+/* Multicast Table Registers */
+#define	MCAST_REG1	0x0000
+#define	MCAST_REG2	0x0002
+#define	MCAST_REG3	0x0004
+#define	MCAST_REG4	0x0006
+
+
+/* Management Interface Register (MII) */
+#define	MII_REG		0x0008
+#define MII_MSK_CRS100	0x4000 /* Disables CRS100 detection during tx half dup */
+#define MII_MDOE	0x0008 /* MII Output Enable */
+#define MII_MCLK	0x0004 /* MII Clock, pin MDCLK */
+#define MII_MDI		0x0002 /* MII Input, pin MDI */
+#define MII_MDO		0x0001 /* MII Output, pin MDO */
+
+
+/* Revision Register */
+#define	REV_REG		0x000A /* ( hi: chip id   low: rev # ) */
+
+
+/* Early RCV Register */
+/* this is NOT on SMC9192 */
+#define	ERCV_REG	0x000C
+#define ERCV_RCV_DISCRD	0x0080 /* When 1 discards a packet being received */
+#define ERCV_THRESHOLD	0x001F /* ERCV Threshold Mask */
+
+/* External Register */
+#define	EXT_REG		0x0000
+
+
+#define CHIP_9192	3
+#define CHIP_9194	4
+#define CHIP_9195	5
+#define CHIP_9196	6
+#define CHIP_91100	7
+#define CHIP_91100FD	8
+#define CHIP_91111FD	9
+
+/*
+ . Transmit status bits
+*/
+#define TS_SUCCESS 0x0001
+#define TS_LOSTCAR 0x0400
+#define TS_LATCOL  0x0200
+#define TS_16COL   0x0010
+
+/*
+ . Receive status bits
+*/
+#define RS_ALGNERR	0x8000
+#define RS_BRODCAST	0x4000
+#define RS_BADCRC	0x2000
+#define RS_ODDFRAME	0x1000	/* bug: the LAN9118 never sets this on receive */
+#define RS_TOOLONG	0x0800
+#define RS_TOOSHORT	0x0400
+#define RS_MULTICAST	0x0001
+#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
+
+
+/* PHY Types */
+enum {
+	PHY_LAN83C183 = 1,	/* LAN9118 Internal PHY */
+	PHY_LAN83C180
+};
+
+
+/* PHY Register Addresses (LAN9118 Internal PHY) */
+
+/* PHY Control Register */
+#define PHY_CNTL_REG		0x00
+#define PHY_CNTL_RST		0x8000	/* 1=PHY Reset */
+#define PHY_CNTL_LPBK		0x4000	/* 1=PHY Loopback */
+#define PHY_CNTL_SPEED		0x2000	/* 1=100Mbps, 0=10Mpbs */
+#define PHY_CNTL_ANEG_EN	0x1000 /* 1=Enable Auto negotiation */
+#define PHY_CNTL_PDN		0x0800	/* 1=PHY Power Down mode */
+#define PHY_CNTL_MII_DIS	0x0400	/* 1=MII 4 bit interface disabled */
+#define PHY_CNTL_ANEG_RST	0x0200 /* 1=Reset Auto negotiate */
+#define PHY_CNTL_DPLX		0x0100	/* 1=Full Duplex, 0=Half Duplex */
+#define PHY_CNTL_COLTST		0x0080	/* 1= MII Colision Test */
+
+/* PHY Status Register */
+#define PHY_STAT_REG		0x01
+#define PHY_STAT_CAP_T4		0x8000	/* 1=100Base-T4 capable */
+#define PHY_STAT_CAP_TXF	0x4000	/* 1=100Base-X full duplex capable */
+#define PHY_STAT_CAP_TXH	0x2000	/* 1=100Base-X half duplex capable */
+#define PHY_STAT_CAP_TF		0x1000	/* 1=10Mbps full duplex capable */
+#define PHY_STAT_CAP_TH		0x0800	/* 1=10Mbps half duplex capable */
+#define PHY_STAT_CAP_SUPR	0x0040	/* 1=recv mgmt frames with not preamble */
+#define PHY_STAT_ANEG_ACK	0x0020	/* 1=ANEG has completed */
+#define PHY_STAT_REM_FLT	0x0010	/* 1=Remote Fault detected */
+#define PHY_STAT_CAP_ANEG	0x0008	/* 1=Auto negotiate capable */
+#define PHY_STAT_LINK		0x0004	/* 1=valid link */
+#define PHY_STAT_JAB		0x0002	/* 1=10Mbps jabber condition */
+#define PHY_STAT_EXREG		0x0001	/* 1=extended registers implemented */
+
+/* PHY Identifier Registers */
+#define PHY_ID1_REG		0x02	/* PHY Identifier 1 */
+#define PHY_ID2_REG		0x03	/* PHY Identifier 2 */
+
+/* PHY Auto-Negotiation Advertisement Register */
+#define PHY_AD_REG		0x04
+#define PHY_AD_NP		0x8000	/* 1=PHY requests exchange of Next Page */
+#define PHY_AD_ACK		0x4000	/* 1=got link code u16 from remote */
+#define PHY_AD_RF		0x2000	/* 1=advertise remote fault */
+#define PHY_AD_T4		0x0200	/* 1=PHY is capable of 100Base-T4 */
+#define PHY_AD_TX_FDX		0x0100	/* 1=PHY is capable of 100Base-TX FDPLX */
+#define PHY_AD_TX_HDX		0x0080	/* 1=PHY is capable of 100Base-TX HDPLX */
+#define PHY_AD_10_FDX		0x0040	/* 1=PHY is capable of 10Base-T FDPLX */
+#define PHY_AD_10_HDX		0x0020	/* 1=PHY is capable of 10Base-T HDPLX */
+#define PHY_AD_CSMA		0x0001	/* 1=PHY is capable of 802.3 CMSA */
+
+/* PHY Auto-negotiation Remote End Capability Register */
+#define PHY_RMT_REG		0x05
+/* Uses same bit definitions as PHY_AD_REG */
+
+/* PHY Configuration Register 1 */
+#define PHY_CFG1_REG		0x10
+#define PHY_CFG1_LNKDIS		0x8000	/* 1=Rx Link Detect Function disabled */
+#define PHY_CFG1_XMTDIS		0x4000	/* 1=TP Transmitter Disabled */
+#define PHY_CFG1_XMTPDN		0x2000	/* 1=TP Transmitter Powered Down */
+#define PHY_CFG1_BYPSCR		0x0400	/* 1=Bypass scrambler/descrambler */
+#define PHY_CFG1_UNSCDS		0x0200	/* 1=Unscramble Idle Reception Disable */
+#define PHY_CFG1_EQLZR		0x0100	/* 1=Rx Equalizer Disabled */
+#define PHY_CFG1_CABLE		0x0080	/* 1=STP(150ohm), 0=UTP(100ohm) */
+#define PHY_CFG1_RLVL0		0x0040	/* 1=Rx Squelch level reduced by 4.5db */
+#define PHY_CFG1_TLVL_SHIFT	2	/* Transmit Output Level Adjust */
+#define PHY_CFG1_TLVL_MASK	0x003C
+#define PHY_CFG1_TRF_MASK	0x0003	/* Transmitter Rise/Fall time */
+
+
+/* PHY Configuration Register 2 */
+#define PHY_CFG2_REG		0x11
+#define PHY_CFG2_APOLDIS	0x0020	/* 1=Auto Polarity Correction disabled */
+#define PHY_CFG2_JABDIS		0x0010	/* 1=Jabber disabled */
+#define PHY_CFG2_MREG		0x0008	/* 1=Multiple register access (MII mgt) */
+#define PHY_CFG2_INTMDIO	0x0004	/* 1=Interrupt signaled with MDIO pulseo */
+
+/* PHY Status Output (and Interrupt status) Register */
+#define PHY_INT_REG		0x12	/* Status Output (Interrupt Status) */
+#define PHY_INT_INT		0x8000	/* 1=bits have changed since last read */
+#define	PHY_INT_LNKFAIL		0x4000	/* 1=Link Not detected */
+#define PHY_INT_LOSSSYNC	0x2000	/* 1=Descrambler has lost sync */
+#define PHY_INT_CWRD		0x1000	/* 1=Invalid 4B5B code detected on rx */
+#define PHY_INT_SSD		0x0800	/* 1=No Start Of Stream detected on rx */
+#define PHY_INT_ESD		0x0400	/* 1=No End Of Stream detected on rx */
+#define PHY_INT_RPOL		0x0200	/* 1=Reverse Polarity detected */
+#define PHY_INT_JAB		0x0100	/* 1=Jabber detected */
+#define PHY_INT_SPDDET		0x0080	/* 1=100Base-TX mode, 0=10Base-T mode */
+#define PHY_INT_DPLXDET		0x0040	/* 1=Device in Full Duplex */
+
+/* PHY Interrupt/Status Mask Register */
+#define PHY_MASK_REG		0x13	/* Interrupt Mask */
+/* Uses the same bit definitions as PHY_INT_REG */
+
+
+// SMSC9118 FIFO Ports
+#define SMSC9118_RX_DATA_PORT   (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x0)
+#define SMSC9118_TX_DATA_PORT   (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x20)
+
+// SMSC9118 FIFO status ports and peeks
+// (Reads on ports destructive, reads on peeks have no side effect)
+#define SMSC9118_RX_STAT_PORT   (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x40)
+#define SMSC9118_RX_STAT_PEEK   (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x44)
+
+#define SMSC9118_TX_STAT_PORT   (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x48)
+#define SMSC9118_TX_STAT_PEEK   (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x4C)
+
+
+// SMSC9118 Registers
+#define SMSC9118_ID_REV         (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x50)
+#define SMSC9118_IRQ_CFG        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x54)
+#define SMSC9118_INT_STS        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x58)
+#define SMSC9118_INT_EN         (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x5C)
+#define SMSC9118_RESERVED1      (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x60)
+#define SMSC9118_BYTE_TEST      (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x64)
+#define SMSC9118_FIFO_INT       (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x68)
+#define SMSC9118_RX_CFG	        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x6C)
+#define SMSC9118_TX_CFG	        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x70)
+#define SMSC9118_HW_CFG	        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x74)
+#define SMSC9118_RX_DP_CTL	(volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x78)
+#define SMSC9118_RX_FIFO_INF    (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x7C)
+#define SMSC9118_TX_FIFO_INF    (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x80)
+#define SMSC9118_PMT_CTRL       (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x84)
+#define SMSC9118_GPIO_CFG       (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x88)
+#define SMSC9118_GPT_CFG        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x8C)
+#define SMSC9118_GPT_CNT        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x90)
+#define SMSC9118_RESERVED2      (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x94)
+#define SMSC9118_ENDIAN	        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x98)
+#define SMSC9118_FREE_RUN       (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0x9C)
+#define SMSC9118_RX_DROP        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0xA0)
+#define SMSC9118_MAC_CSR_CMD    (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0xA4)
+#define SMSC9118_MAC_CSR_DATA   (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0xA8)
+#define SMSC9118_AFC_CFG        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0xAC)
+#define SMSC9118_E2P_CMD        (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0xB0)
+#define SMSC9118_E2P_DATA       (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0xB4)
+#define SMSC9118_RESERVED3      (volatile unsigned int *)(CONFIG_SMC9118_BASE + 0xB8)
+
+
+// SMSC9118 MAC Registers       Indices
+#define SMSC9118_MAC_CR         0x1
+#define SMSC9118_MAC_ADDRH      0x2
+#define SMSC9118_MAC_ADDRL      0x3
+#define SMSC9118_MAC_HASHH      0x4
+#define SMSC9118_MAC_HASHL      0x5
+#define SMSC9118_MAC_MII_ACC    0x6
+#define SMSC9118_MAC_MII_DATA   0x7
+#define SMSC9118_MAC_FLOW       0x8
+#define SMSC9118_MAC_VLAN1      0x9
+#define SMSC9118_MAC_VLAN2      0xA
+#define SMSC9118_MAC_WUFF       0xB
+#define SMSC9118_MAC_WUCSR      0xC
+
+// SMSC9118 PHY Registers       Indices
+#define SMSC9118_PHY_BCONTROL   0x0
+#define SMSC9118_PHY_BSTATUS    0x1
+#define SMSC9118_PHY_ID1        0x2
+#define SMSC9118_PHY_ID2        0x3
+#define SMSC9118_PHY_ANEG_ADV   0x4
+#define SMSC9118_PHY_ANEG_LPA   0x5
+#define SMSC9118_PHY_ANEG_EXP   0x6
+#define SMSC9118_PHY_MCONTROL   0x17
+#define SMSC9118_PHY_MSTATUS    0x18
+#define SMSC9118_PHY_CSINDICATE 0x27
+#define SMSC9118_PHY_INTSRC     0x29
+#define SMSC9118_PHY_INTMASK    0x30
+#define SMSC9118_PHY_CS         0x31
+
+
+
+#endif  /* _SMC9118_9118_H_ */
diff --git a/drivers/net/smc_rv.c b/drivers/net/smc_rv.c
new file mode 100644
index 0000000..4fe4ca9
--- /dev/null
+++ b/drivers/net/smc_rv.c
@@ -0,0 +1,2596 @@
+/*------------------------------------------------------------------------
+ . smc_rv.c	This is a driver for the RealView boards ethernet chip(s)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ .
+ .	Before Rev D the chip was    SMSC's 91C111 single-chip Ethernet device.
+ .	For    Rev D the chip became SMSC's 9118   single-chip Ethernet device.
+ .
+ .	This file merges the code from
+ .
+ .		net/drivers/smc91111.c
+ . authors:
+ .	Erik Stahlman				( erik@vt.edu )
+ .	Daris A Nevil				( dnevil@snmc.com )
+ .
+ .		net/drivers/smc9118.c
+ . author:
+ .	Peter Pearse				( peter.pearse@arm.com)
+ .
+ .
+ .	The chip type is detected during init and determines which code is run
+ .
+ . Sources:
+ .    o	  Chip datasheets (www.smsc.com)
+ .
+ . author:
+ .	Peter Pearse				( peter.pearse@arm.com)
+ .
+ . History
+ .	2007.10.10	Initial file merge
+ .
+ ----------------------------------------------------------------------------*/
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include "smc_rv.h"
+#include <net.h>
+
+#ifdef CONFIG_DRIVER_SMC_RV
+
+// Chip type
+int chip_type = LAN_INVALID;
+/*
+ * SMSC9118 has an id register, 91111 has no register at that address 
+ */
+int get_chip_type(void){
+	unsigned int id_reg = *SMSC9118_ID_REV;
+	if((id_reg & 0xFFFF0000) == 0x01180000){
+		printf("LAN9118 ethernet chip detected\n");
+		return LAN9118;
+	} else {
+		printf("LAN91C111 ethernet chip assumed\n");
+		return LAN91C111;
+	}
+}
+
+// 91111 code start
+
+/* Use power-down feature of the chip */
+#define POWER_DOWN	0
+
+#define NO_AUTOPROBE
+
+#define SMC_DEBUG 0
+
+#if SMC_DEBUG > 1
+static const char version[] =
+	"smc91111.c:v1.0 04/25/01 by Daris A Nevil (dnevil@snmc.com)\n";
+#endif
+
+/* Autonegotiation timeout in seconds */
+#ifndef CONFIG_SMC_AUTONEG_TIMEOUT
+#define CONFIG_SMC_AUTONEG_TIMEOUT 10
+#endif
+
+/*------------------------------------------------------------------------
+ .
+ . Configuration options, for the experienced user to change.
+ .
+ -------------------------------------------------------------------------*/
+
+/*
+ . Wait time for memory to be free.  This probably shouldn't be
+ . tuned that much, as waiting for this means nothing else happens
+ . in the system
+*/
+#define MEMORY_WAIT_TIME 16
+
+
+#if (SMC_DEBUG > 2 )
+#define PRINTK3(args...) printf(args)
+#else
+#define PRINTK3(args...)
+#endif
+
+#if SMC_DEBUG > 1
+#define PRINTK2(args...) printf(args)
+#else
+#define PRINTK2(args...)
+#endif
+
+#ifdef SMC_DEBUG
+#define PRINTK(args...) printf(args)
+#else
+#define PRINTK(args...)
+#endif
+
+
+/*------------------------------------------------------------------------
+ .
+ . The internal workings of the driver.	 If you are changing anything
+ . here with the SMC stuff, you should have the datasheet and know
+ . what you are doing.
+ .
+ -------------------------------------------------------------------------*/
+#define CARDNAME "LAN91C111"
+
+/* Memory sizing constant */
+#define LAN91C111_MEMORY_MULTIPLIER	(1024*2)
+
+#ifndef CONFIG_SMC91111_BASE
+#define CONFIG_SMC91111_BASE 0x20000300
+#endif
+
+#define SMC_BASE_ADDRESS CONFIG_SMC91111_BASE
+
+#define SMC_DEV_NAME "SMC91111"
+#define SMC_PHY_ADDR 0x0000
+#define SMC_ALLOC_MAX_TRY 5
+#define SMC_TX_TIMEOUT 30
+
+#define SMC_PHY_CLOCK_DELAY 1000
+
+#define ETH_ZLEN 60
+
+#ifdef	CONFIG_SMC_USE_32_BIT
+#define USE_32_BIT  1
+#else
+#undef USE_32_BIT
+#endif
+/*-----------------------------------------------------------------
+ .
+ .  The driver can be entered at any of the following entry points.
+ .
+ .------------------------------------------------------------------  */
+
+int	eth_init	(bd_t *bd);
+void	eth_halt	(void);
+int	eth_rx		(void);
+int	eth_send	(volatile void *packet, int length);
+
+#ifdef SHARED_RESOURCES
+	extern void swap_to(int device_id);
+#endif
+
+/*
+ . This is called by  register_netdev().  It is responsible for
+ . checking the portlist for the SMC9000 series chipset.  If it finds
+ . one, then it will initialize the device, find the hardware information,
+ . and sets up the appropriate device parameters.
+ . NOTE: Interrupts are *OFF* when this procedure is called.
+ .
+ . NB:This shouldn't be static since it is referred to externally.
+*/
+int smc_init(void);
+
+/*
+ . This is called by  unregister_netdev().  It is responsible for
+ . cleaning up before the driver is finally unregistered and discarded.
+*/
+void smc_destructor(void);
+
+/*
+ . The kernel calls this function when someone wants to use the device,
+ . typically 'ifconfig ethX up'.
+*/
+static int smc_open(bd_t *bd);
+
+
+/*
+ . This is called by the kernel in response to 'ifconfig ethX down'.  It
+ . is responsible for cleaning up everything that the open routine
+ . does, and maybe putting the card into a powerdown state.
+*/
+static int smc_close(void);
+
+/*
+ . Configures the PHY through the MII Management interface
+*/
+#ifndef CONFIG_SMC91111_EXT_PHY
+static void smc_phy_configure(void);
+#endif /* !CONFIG_SMC91111_EXT_PHY */
+
+/*
+ . This is a separate procedure to handle the receipt of a packet, to
+ . leave the interrupt code looking slightly cleaner
+*/
+static int smc_rcv(void);
+
+/* See if a MAC address is defined in the current environment. If so use it. If not
+ . print a warning and set the environment and other globals with the default.
+ . If an EEPROM is present it really should be consulted.
+*/
+int smc_get_ethaddr(bd_t *bd);
+int get_rom_mac(uchar *v_rom_mac);
+
+/*
+ ------------------------------------------------------------
+ .
+ . Internal routines
+ .
+ ------------------------------------------------------------
+*/
+
+#ifdef CONFIG_SMC_USE_IOFUNCS
+/*
+ * input and output functions
+ *
+ * Implemented due to inx,outx macros accessing the device improperly
+ * and putting the device into an unkown state.
+ *
+ * For instance, on Sharp LPD7A400 SDK, affects were chip memory
+ * could not be free'd (hence the alloc failures), duplicate packets,
+ * packets being corrupt (shifted) on the wire, etc.  Switching to the
+ * inx,outx functions fixed this problem.
+ */
+static inline word SMC_inw(dword offset);
+static inline void SMC_outw(word value, dword offset);
+static inline byte SMC_inb(dword offset);
+static inline void SMC_outb(byte value, dword offset);
+static inline void SMC_insw(dword offset, volatile uchar* buf, dword len);
+static inline void SMC_outsw(dword offset, uchar* buf, dword len);
+
+#define barrier() __asm__ __volatile__("": : :"memory")
+
+static inline word SMC_inw(dword offset)
+{
+	word v;
+	v = *((volatile word*)(SMC_BASE_ADDRESS+offset));
+	barrier(); *(volatile u32*)(0xc0000000);
+	return v;
+}
+
+static inline void SMC_outw(word value, dword offset)
+{
+	*((volatile word*)(SMC_BASE_ADDRESS+offset)) = value;
+	barrier(); *(volatile u32*)(0xc0000000);
+}
+
+static inline byte SMC_inb(dword offset)
+{
+	word  _w;
+
+	_w = SMC_inw(offset & ~((dword)1));
+	return (offset & 1) ? (byte)(_w >> 8) : (byte)(_w);
+}
+
+static inline void SMC_outb(byte value, dword offset)
+{
+	word  _w;
+
+	_w = SMC_inw(offset & ~((dword)1));
+	if (offset & 1)
+			*((volatile word*)(SMC_BASE_ADDRESS+(offset & ~((dword)1)))) = (value<<8) | (_w & 0x00ff);
+	else
+			*((volatile word*)(SMC_BASE_ADDRESS+offset)) = value | (_w & 0xff00);
+}
+
+static inline void SMC_insw(dword offset, volatile uchar* buf, dword len)
+{
+	volatile word *p = (volatile word *)buf;
+
+	while (len-- > 0) {
+		*p++ = SMC_inw(offset);
+		barrier();
+		*((volatile u32*)(0xc0000000));
+	}
+}
+
+static inline void SMC_outsw(dword offset, uchar* buf, dword len)
+{
+	volatile word *p = (volatile word *)buf;
+
+	while (len-- > 0) {
+		SMC_outw(*p++, offset);
+		barrier();
+		*(volatile u32*)(0xc0000000);
+	}
+}
+#endif  /* CONFIG_SMC_USE_IOFUNCS */
+
+static char unsigned smc_mac_addr[6] = {0x02, 0x80, 0xad, 0x20, 0x31, 0xb8};
+
+/*
+ * This function must be called before smc_open() if you want to override
+ * the default mac address.
+ */
+
+void smc_set_mac_addr(const unsigned char *addr) {
+	int i;
+
+	for (i=0; i < sizeof(smc_mac_addr); i++){
+		smc_mac_addr[i] = addr[i];
+	}
+}
+
+/*
+ * smc_get_macaddr is no longer used. If you want to override the default
+ * mac address, call smc_get_mac_addr as a part of the board initialization.
+ */
+
+#if 0
+void smc_get_macaddr( byte *addr ) {
+	/* MAC ADDRESS AT FLASHBLOCK 1 / OFFSET 0x10 */
+	unsigned char *dnp1110_mac = (unsigned char *) (0xE8000000 + 0x20010);
+	int i;
+
+
+	for (i=0; i<6; i++) {
+	    addr[0] = *(dnp1110_mac+0);
+	    addr[1] = *(dnp1110_mac+1);
+	    addr[2] = *(dnp1110_mac+2);
+	    addr[3] = *(dnp1110_mac+3);
+	    addr[4] = *(dnp1110_mac+4);
+	    addr[5] = *(dnp1110_mac+5);
+	}
+}
+#endif /* 0 */
+
+/***********************************************
+ * Show available memory		       *
+ ***********************************************/
+void dump_memory_info(void)
+{
+	word mem_info;
+	word old_bank;
+
+	old_bank = SMC_inw(BANK_SELECT)&0xF;
+
+	SMC_SELECT_BANK(0);
+	mem_info = SMC_inw( MIR_REG );
+	PRINTK2("Memory: %4d available\n", (mem_info >> 8)*2048);
+
+	SMC_SELECT_BANK(old_bank);
+}
+/*
+ . A rather simple routine to print out a packet for debugging purposes.
+*/
+#if SMC_DEBUG > 2
+static void print_packet( byte *, int );
+#endif
+
+#define tx_done(dev) 1
+
+
+/* this does a soft reset on the device */
+static void smc_reset( void );
+
+/* Enable Interrupts, Receive, and Transmit */
+static void smc_enable( void );
+
+/* this puts the device in an inactive state */
+static void smc_shutdown( void );
+
+/* Routines to Read and Write the PHY Registers across the
+   MII Management Interface
+*/
+
+#ifndef CONFIG_SMC91111_EXT_PHY
+static word smc_read_phy_register(byte phyreg);
+static void smc_write_phy_register(byte phyreg, word phydata);
+#endif /* !CONFIG_SMC91111_EXT_PHY */
+
+
+static int poll4int (byte mask, int timeout)
+{
+	int tmo = get_timer (0) + timeout * CFG_HZ;
+	int is_timeout = 0;
+	word old_bank = SMC_inw (BSR_REG);
+
+	PRINTK2 ("Polling...\n");
+	SMC_SELECT_BANK (2);
+	while ((SMC_inw (SMC91111_INT_REG) & mask) == 0) {
+		if (get_timer (0) >= tmo) {
+			is_timeout = 1;
+			break;
+		}
+	}
+
+	/* restore old bank selection */
+	SMC_SELECT_BANK (old_bank);
+
+	if (is_timeout)
+		return 1;
+	else
+		return 0;
+}
+
+/* Only one release command at a time, please */
+static inline void smc_wait_mmu_release_complete (void)
+{
+	int count = 0;
+
+	/* assume bank 2 selected */
+	while (SMC_inw (MMU_CMD_REG) & MC_BUSY) {
+		udelay (1);	/* Wait until not busy */
+		if (++count > 200)
+			break;
+	}
+}
+
+/*
+ . Function: smc_reset( void )
+ . Purpose:
+ .	This sets the SMC91111 chip to its normal state, hopefully from whatever
+ .	mess that any other DOS driver has put it in.
+ .
+ . Maybe I should reset more registers to defaults in here?  SOFTRST  should
+ . do that for me.
+ .
+ . Method:
+ .	1.  send a SOFT RESET
+ .	2.  wait for it to finish
+ .	3.  enable autorelease mode
+ .	4.  reset the memory management unit
+ .	5.  clear all interrupts
+ .
+*/
+static void smc_reset (void)
+{
+	PRINTK2 ("%s: smc_reset\n", SMC_DEV_NAME);
+
+	/* This resets the registers mostly to defaults, but doesn't
+	   affect EEPROM.  That seems unnecessary */
+	SMC_SELECT_BANK (0);
+	SMC_outw (RCR_SOFTRST, RCR_REG);
+
+	/* Setup the Configuration Register */
+	/* This is necessary because the CONFIG_REG is not affected */
+	/* by a soft reset */
+
+	SMC_SELECT_BANK (1);
+#if defined(CONFIG_SMC91111_EXT_PHY)
+	SMC_outw (CONFIG_DEFAULT | CONFIG_EXT_PHY, CONFIG_REG);
+#else
+	SMC_outw (CONFIG_DEFAULT, CONFIG_REG);
+#endif
+
+
+	/* Release from possible power-down state */
+	/* Configuration register is not affected by Soft Reset */
+	SMC_outw (SMC_inw (CONFIG_REG) | CONFIG_EPH_POWER_EN, CONFIG_REG);
+
+	SMC_SELECT_BANK (0);
+
+	/* this should pause enough for the chip to be happy */
+	udelay (10);
+
+	/* Disable transmit and receive functionality */
+	SMC_outw (RCR_CLEAR, RCR_REG);
+	SMC_outw (TCR_CLEAR, TCR_REG);
+
+	/* set the control register */
+	SMC_SELECT_BANK (1);
+	SMC_outw (CTL_DEFAULT, CTL_REG);
+
+	/* Reset the MMU */
+	SMC_SELECT_BANK (2);
+	smc_wait_mmu_release_complete ();
+	SMC_outw (MC_RESET, MMU_CMD_REG);
+	while (SMC_inw (MMU_CMD_REG) & MC_BUSY)
+		udelay (1);	/* Wait until not busy */
+
+	/* Note:  It doesn't seem that waiting for the MMU busy is needed here,
+	   but this is a place where future chipsets _COULD_ break.  Be wary
+	   of issuing another MMU command right after this */
+
+	/* Disable all interrupts */
+	SMC_outb (0, IM_REG);
+}
+
+/*
+ . Function: smc_enable
+ . Purpose: let the chip talk to the outside work
+ . Method:
+ .	1.  Enable the transmitter
+ .	2.  Enable the receiver
+ .	3.  Enable interrupts
+*/
+static void smc_enable()
+{
+	PRINTK2("%s: smc_enable\n", SMC_DEV_NAME);
+	SMC_SELECT_BANK( 0 );
+	/* see the header file for options in TCR/RCR DEFAULT*/
+	SMC_outw( TCR_DEFAULT, TCR_REG );
+	SMC_outw( RCR_DEFAULT, RCR_REG );
+
+	/* clear MII_DIS */
+/*	smc_write_phy_register(PHY_CNTL_REG, 0x0000); */
+}
+
+/*
+ . Function: smc_shutdown
+ . Purpose:  closes down the SMC91xxx chip.
+ . Method:
+ .	1. zero the interrupt mask
+ .	2. clear the enable receive flag
+ .	3. clear the enable xmit flags
+ .
+ . TODO:
+ .   (1) maybe utilize power down mode.
+ .	Why not yet?  Because while the chip will go into power down mode,
+ .	the manual says that it will wake up in response to any I/O requests
+ .	in the register space.	 Empirical results do not show this working.
+*/
+static void smc_shutdown()
+{
+	PRINTK2(CARDNAME ": smc_shutdown\n");
+
+	/* no more interrupts for me */
+	SMC_SELECT_BANK( 2 );
+	SMC_outb( 0, IM_REG );
+
+	/* and tell the card to stay away from that nasty outside world */
+	SMC_SELECT_BANK( 0 );
+	SMC_outb( RCR_CLEAR, RCR_REG );
+	SMC_outb( TCR_CLEAR, TCR_REG );
+#ifdef SHARED_RESOURCES
+	swap_to(FLASH);
+#endif
+}
+
+
+/*
+ . Function:  smc_hardware_send_packet(struct net_device * )
+ . Purpose:
+ .	This sends the actual packet to the SMC9xxx chip.
+ .
+ . Algorithm:
+ .	First, see if a saved_skb is available.
+ .		( this should NOT be called if there is no 'saved_skb'
+ .	Now, find the packet number that the chip allocated
+ .	Point the data pointers at it in memory
+ .	Set the length word in the chip's memory
+ .	Dump the packet to chip memory
+ .	Check if a last byte is needed ( odd length packet )
+ .		if so, set the control flag right
+ .	Tell the card to send it
+ .	Enable the transmit interrupt, so I know if it failed
+ .	Free the kernel data if I actually sent it.
+*/
+static int smc_send_packet (volatile void *packet, int packet_length)
+{
+	byte packet_no;
+	unsigned long ioaddr;
+	byte *buf;
+	int length;
+	int numPages;
+	int try = 0;
+	int time_out;
+	byte status;
+	byte saved_pnr;
+	word saved_ptr;
+
+	/* save PTR and PNR registers before manipulation */
+	SMC_SELECT_BANK (2);
+	saved_pnr = SMC_inb( PN_REG );
+	saved_ptr = SMC_inw( PTR_REG );
+
+	PRINTK3 ("%s: smc_hardware_send_packet\n", SMC_DEV_NAME);
+
+	length = ETH_ZLEN < packet_length ? packet_length : ETH_ZLEN;
+
+	/* allocate memory
+	 ** The MMU wants the number of pages to be the number of 256 bytes
+	 ** 'pages', minus 1 ( since a packet can't ever have 0 pages :) )
+	 **
+	 ** The 91C111 ignores the size bits, but the code is left intact
+	 ** for backwards and future compatibility.
+	 **
+	 ** Pkt size for allocating is data length +6 (for additional status
+	 ** words, length and ctl!)
+	 **
+	 ** If odd size then last byte is included in this header.
+	 */
+	numPages = ((length & 0xfffe) + 6);
+	numPages >>= 8;		/* Divide by 256 */
+
+	if (numPages > 7) {
+		printf ("%s: Far too big packet error. \n", SMC_DEV_NAME);
+		return 0;
+	}
+
+	/* now, try to allocate the memory */
+	SMC_SELECT_BANK (2);
+	SMC_outw (MC_ALLOC | numPages, MMU_CMD_REG);
+
+	/* FIXME: the ALLOC_INT bit never gets set *
+	 * so the following will always give a	   *
+	 * memory allocation error.		   *
+	 * same code works in armboot though	   *
+	 * -ro
+	 */
+
+again:
+	try++;
+	time_out = MEMORY_WAIT_TIME;
+	do {
+		status = SMC_inb (SMC91111_INT_REG);
+		if (status & IM_ALLOC_INT) {
+			/* acknowledge the interrupt */
+			SMC_outb (IM_ALLOC_INT, SMC91111_INT_REG);
+			break;
+		}
+	} while (--time_out);
+
+	if (!time_out) {
+		PRINTK2 ("%s: memory allocation, try %d failed ...\n",
+			 SMC_DEV_NAME, try);
+		if (try < SMC_ALLOC_MAX_TRY)
+			goto again;
+		else
+			return 0;
+	}
+
+	PRINTK2 ("%s: memory allocation, try %d succeeded ...\n",
+		 SMC_DEV_NAME, try);
+
+	/* I can send the packet now.. */
+
+	ioaddr = SMC_BASE_ADDRESS;
+
+	buf = (byte *) packet;
+
+	/* If I get here, I _know_ there is a packet slot waiting for me */
+	packet_no = SMC_inb (AR_REG);
+	if (packet_no & AR_FAILED) {
+		/* or isn't there?  BAD CHIP! */
+		printf ("%s: Memory allocation failed. \n", SMC_DEV_NAME);
+		return 0;
+	}
+
+	/* we have a packet address, so tell the card to use it */
+#ifndef CONFIG_XAENIAX
+	SMC_outb (packet_no, PN_REG);
+#else
+	/* On Xaeniax board, we can't use SMC_outb here because that way
+	 * the Allocate MMU command will end up written to the command register
+	 * as well, which will lead to a problem.
+	 */
+	SMC_outl (packet_no << 16, 0);
+#endif
+	/* do not write new ptr value if Write data fifo not empty */
+	while ( saved_ptr & PTR_NOTEMPTY )
+		printf ("Write data fifo not empty!\n");
+
+	/* point to the beginning of the packet */
+	SMC_outw (PTR_AUTOINC, PTR_REG);
+
+	PRINTK3 ("%s: Trying to xmit packet of length %x\n",
+		 SMC_DEV_NAME, length);
+
+#if SMC_DEBUG > 2
+	printf ("Transmitting Packet\n");
+	print_packet (buf, length);
+#endif
+
+	/* send the packet length ( +6 for status, length and ctl byte )
+	   and the status word ( set to zeros ) */
+#ifdef USE_32_BIT
+	SMC_outl ((length + 6) << 16, SMC91111_DATA_REG);
+#else
+	SMC_outw (0, SMC91111_DATA_REG);
+	/* send the packet length ( +6 for status words, length, and ctl */
+	SMC_outw ((length + 6), SMC91111_DATA_REG);
+#endif
+
+	/* send the actual data
+	   . I _think_ it's faster to send the longs first, and then
+	   . mop up by sending the last word.  It depends heavily
+	   . on alignment, at least on the 486.	 Maybe it would be
+	   . a good idea to check which is optimal?  But that could take
+	   . almost as much time as is saved?
+	 */
+#ifdef USE_32_BIT
+	SMC_outsl (SMC91111_DATA_REG, buf, length >> 2);
+#ifndef CONFIG_XAENIAX
+	if (length & 0x2)
+		SMC_outw (*((word *) (buf + (length & 0xFFFFFFFC))),
+			  SMC91111_DATA_REG);
+#else
+	/* On XANEIAX, we can only use 32-bit writes, so we need to handle
+	 * unaligned tail part specially. The standard code doesn't work.
+	 */
+	if ((length & 3) == 3) {
+		u16 * ptr = (u16*) &buf[length-3];
+		SMC_outl((*ptr) | ((0x2000 | buf[length-1]) << 16),
+				SMC91111_DATA_REG);
+	} else if ((length & 2) == 2) {
+		u16 * ptr = (u16*) &buf[length-2];
+		SMC_outl(*ptr, SMC91111_DATA_REG);
+	} else if (length & 1) {
+		SMC_outl((0x2000 | buf[length-1]), SMC91111_DATA_REG);
+	} else {
+		SMC_outl(0, SMC91111_DATA_REG);
+	}
+#endif
+#else
+	SMC_outsw (SMC91111_DATA_REG, buf, (length) >> 1);
+#endif /* USE_32_BIT */
+
+#ifndef CONFIG_XAENIAX
+	/* Send the last byte, if there is one.	  */
+	if ((length & 1) == 0) {
+		SMC_outw (0, SMC91111_DATA_REG);
+	} else {
+		SMC_outw (buf[length - 1] | 0x2000, SMC91111_DATA_REG);
+	}
+#endif
+
+	/* and let the chipset deal with it */
+	SMC_outw (MC_ENQUEUE, MMU_CMD_REG);
+
+	/* poll for TX INT */
+	/* if (poll4int (IM_TX_INT, SMC_TX_TIMEOUT)) { */
+	/* poll for TX_EMPTY INT - autorelease enabled */
+	if (poll4int(IM_TX_EMPTY_INT, SMC_TX_TIMEOUT)) {
+		/* sending failed */
+		PRINTK2 ("%s: TX timeout, sending failed...\n", SMC_DEV_NAME);
+
+		/* release packet */
+		/* no need to release, MMU does that now */
+#ifdef CONFIG_XAENIAX
+		 SMC_outw (MC_FREEPKT, MMU_CMD_REG);
+#endif
+
+		/* wait for MMU getting ready (low) */
+		while (SMC_inw (MMU_CMD_REG) & MC_BUSY) {
+			udelay (10);
+		}
+
+		PRINTK2 ("MMU ready\n");
+
+
+		return 0;
+	} else {
+		/* ack. int */
+		SMC_outb (IM_TX_EMPTY_INT, SMC91111_INT_REG);
+		/* SMC_outb (IM_TX_INT, SMC91111_INT_REG); */
+		PRINTK2 ("%s: Sent packet of length %d \n", SMC_DEV_NAME,
+			 length);
+
+		/* release packet */
+		/* no need to release, MMU does that now */
+#ifdef CONFIG_XAENIAX
+		SMC_outw (MC_FREEPKT, MMU_CMD_REG);
+#endif
+
+		/* wait for MMU getting ready (low) */
+		while (SMC_inw (MMU_CMD_REG) & MC_BUSY) {
+			udelay (10);
+		}
+
+		PRINTK2 ("MMU ready\n");
+
+
+	}
+
+	/* restore previously saved registers */
+#ifndef CONFIG_XAENIAX
+	SMC_outb( saved_pnr, PN_REG );
+#else
+	/* On Xaeniax board, we can't use SMC_outb here because that way
+	 * the Allocate MMU command will end up written to the command register
+	 * as well, which will lead to a problem.
+	 */
+	SMC_outl(saved_pnr << 16, 0);
+#endif
+	SMC_outw( saved_ptr, PTR_REG );
+
+	return length;
+}
+
+/*-------------------------------------------------------------------------
+ |
+ | smc_destructor( struct net_device * dev )
+ |   Input parameters:
+ |	dev, pointer to the device structure
+ |
+ |   Output:
+ |	None.
+ |
+ ---------------------------------------------------------------------------
+*/
+void smc_destructor()
+{
+	PRINTK2(CARDNAME ": smc_destructor\n");
+}
+
+
+/*
+ * Open and Initialize the board
+ *
+ * Set up everything, reset the card, etc ..
+ *
+ */
+static int smc_open (bd_t * bd)
+{
+	int i, err;
+
+	PRINTK2 ("%s: smc_open\n", SMC_DEV_NAME);
+
+	/* reset the hardware */
+	smc_reset ();
+	smc_enable ();
+
+	/* Configure the PHY */
+#ifndef CONFIG_SMC91111_EXT_PHY
+	smc_phy_configure ();
+#endif
+
+	/* conservative setting (10Mbps, HalfDuplex, no AutoNeg.) */
+/*	SMC_SELECT_BANK(0); */
+/*	SMC_outw(0, RPC_REG); */
+	SMC_SELECT_BANK (1);
+
+	err = smc_get_ethaddr (bd);	/* set smc_mac_addr, and sync it with u-boot globals */
+	if (err < 0) {
+		memset (bd->bi_enetaddr, 0, 6); /* hack to make error stick! upper code will abort if not set */
+		return (-1);	/* upper code ignores this, but NOT bi_enetaddr */
+	}
+#ifdef USE_32_BIT
+	for (i = 0; i < 6; i += 2) {
+		word address;
+
+		address = smc_mac_addr[i + 1] << 8;
+		address |= smc_mac_addr[i];
+		SMC_outw (address, (ADDR0_REG + i));
+	}
+#else
+	for (i = 0; i < 6; i++)
+		SMC_outb (smc_mac_addr[i], (ADDR0_REG + i));
+#endif
+
+	return 0;
+}
+
+/*-------------------------------------------------------------
+ .
+ . smc_rcv -  receive a packet from the card
+ .
+ . There is ( at least ) a packet waiting to be read from
+ . chip-memory.
+ .
+ . o Read the status
+ . o If an error, record it
+ . o otherwise, read in the packet
+ --------------------------------------------------------------
+*/
+static int smc_rcv()
+{
+	int	packet_number;
+	word	status;
+	word	packet_length;
+	int	is_error = 0;
+#ifdef USE_32_BIT
+	dword stat_len;
+#endif
+	byte saved_pnr;
+	word saved_ptr;
+
+	SMC_SELECT_BANK(2);
+	/* save PTR and PTR registers */
+	saved_pnr = SMC_inb( PN_REG );
+	saved_ptr = SMC_inw( PTR_REG );
+
+	packet_number = SMC_inw( RXFIFO_REG );
+
+	if ( packet_number & RXFIFO_REMPTY ) {
+
+		return 0;
+	}
+
+	PRINTK3("%s: smc_rcv\n", SMC_DEV_NAME);
+	/*  start reading from the start of the packet */
+	SMC_outw( PTR_READ | PTR_RCV | PTR_AUTOINC, PTR_REG );
+
+	/* First two words are status and packet_length */
+#ifdef USE_32_BIT
+	stat_len = SMC_inl(SMC91111_DATA_REG);
+	status = stat_len & 0xffff;
+	packet_length = stat_len >> 16;
+#else
+	status		= SMC_inw( SMC91111_DATA_REG );
+	packet_length	= SMC_inw( SMC91111_DATA_REG );
+#endif
+
+	packet_length &= 0x07ff;  /* mask off top bits */
+
+	PRINTK2("RCV: STATUS %4x LENGTH %4x\n", status, packet_length );
+
+	if ( !(status & RS_ERRORS ) ){
+		/* Adjust for having already read the first two words */
+		packet_length -= 4; /*4; */
+
+
+		/* set odd length for bug in LAN91C111, */
+		/* which never sets RS_ODDFRAME */
+		/* TODO ? */
+
+
+#ifdef USE_32_BIT
+		PRINTK3(" Reading %d dwords (and %d bytes) \n",
+			packet_length >> 2, packet_length & 3 );
+		/* QUESTION:  Like in the TX routine, do I want
+		   to send the DWORDs or the bytes first, or some
+		   mixture.  A mixture might improve already slow PIO
+		   performance	*/
+		SMC_insl( SMC91111_DATA_REG , NetRxPackets[0], packet_length >> 2 );
+		/* read the left over bytes */
+		if (packet_length & 3) {
+			int i;
+
+			byte *tail = (byte *)(NetRxPackets[0] + (packet_length & ~3));
+			dword leftover = SMC_inl(SMC91111_DATA_REG);
+			for (i=0; i<(packet_length & 3); i++)
+				*tail++ = (byte) (leftover >> (8*i)) & 0xff;
+		}
+#else
+		PRINTK3(" Reading %d words and %d byte(s) \n",
+			(packet_length >> 1 ), packet_length & 1 );
+		SMC_insw(SMC91111_DATA_REG , NetRxPackets[0], packet_length >> 1);
+
+#endif /* USE_32_BIT */
+
+#if	SMC_DEBUG > 2
+		printf("Receiving Packet\n");
+		print_packet( NetRxPackets[0], packet_length );
+#endif
+	} else {
+		/* error ... */
+		/* TODO ? */
+		is_error = 1;
+	}
+
+	while ( SMC_inw( MMU_CMD_REG ) & MC_BUSY )
+		udelay(1); /* Wait until not busy */
+
+	/*  error or good, tell the card to get rid of this packet */
+	SMC_outw( MC_RELEASE, MMU_CMD_REG );
+
+	while ( SMC_inw( MMU_CMD_REG ) & MC_BUSY )
+		udelay(1); /* Wait until not busy */
+
+	/* restore saved registers */
+#ifndef CONFIG_XAENIAX
+	SMC_outb( saved_pnr, PN_REG );
+#else
+	/* On Xaeniax board, we can't use SMC_outb here because that way
+	 * the Allocate MMU command will end up written to the command register
+	 * as well, which will lead to a problem.
+	 */
+	SMC_outl( saved_pnr << 16, 0);
+#endif
+	SMC_outw( saved_ptr, PTR_REG );
+
+	if (!is_error) {
+		/* Pass the packet up to the protocol layers. */
+		NetReceive(NetRxPackets[0], packet_length);
+		return packet_length;
+	} else {
+		return 0;
+	}
+
+}
+
+
+/*----------------------------------------------------
+ . smc_close
+ .
+ . this makes the board clean up everything that it can
+ . and not talk to the outside world.	Caused by
+ . an 'ifconfig ethX down'
+ .
+ -----------------------------------------------------*/
+static int smc_close()
+{
+	PRINTK2("%s: smc_close\n", SMC_DEV_NAME);
+
+	/* clear everything */
+	smc_shutdown();
+
+	return 0;
+}
+
+
+#if 0
+/*------------------------------------------------------------
+ . Modify a bit in the LAN91C111 register set
+ .-------------------------------------------------------------*/
+static word smc_modify_regbit(int bank, int ioaddr, int reg,
+	unsigned int bit, int val)
+{
+	word regval;
+
+	SMC_SELECT_BANK( bank );
+
+	regval = SMC_inw( reg );
+	if (val)
+		regval |= bit;
+	else
+		regval &= ~bit;
+
+	SMC_outw( regval, 0 );
+	return(regval);
+}
+
+
+/*------------------------------------------------------------
+ . Retrieve a bit in the LAN91C111 register set
+ .-------------------------------------------------------------*/
+static int smc_get_regbit(int bank, int ioaddr, int reg, unsigned int bit)
+{
+	SMC_SELECT_BANK( bank );
+	if ( SMC_inw( reg ) & bit)
+		return(1);
+	else
+		return(0);
+}
+
+
+/*------------------------------------------------------------
+ . Modify a LAN91C111 register (word access only)
+ .-------------------------------------------------------------*/
+static void smc_modify_reg(int bank, int ioaddr, int reg, word val)
+{
+	SMC_SELECT_BANK( bank );
+	SMC_outw( val, reg );
+}
+
+
+/*------------------------------------------------------------
+ . Retrieve a LAN91C111 register (word access only)
+ .-------------------------------------------------------------*/
+static int smc_get_reg(int bank, int ioaddr, int reg)
+{
+	SMC_SELECT_BANK( bank );
+	return(SMC_inw( reg ));
+}
+
+#endif /* 0 */
+
+/*---PHY CONTROL AND CONFIGURATION----------------------------------------- */
+
+#if (SMC_DEBUG > 2 )
+
+/*------------------------------------------------------------
+ . Debugging function for viewing MII Management serial bitstream
+ .-------------------------------------------------------------*/
+static void smc_dump_mii_stream (byte * bits, int size)
+{
+	int i;
+
+	printf ("BIT#:");
+	for (i = 0; i < size; ++i) {
+		printf ("%d", i % 10);
+	}
+
+	printf ("\nMDOE:");
+	for (i = 0; i < size; ++i) {
+		if (bits[i] & MII_MDOE)
+			printf ("1");
+		else
+			printf ("0");
+	}
+
+	printf ("\nMDO :");
+	for (i = 0; i < size; ++i) {
+		if (bits[i] & MII_MDO)
+			printf ("1");
+		else
+			printf ("0");
+	}
+
+	printf ("\nMDI :");
+	for (i = 0; i < size; ++i) {
+		if (bits[i] & MII_MDI)
+			printf ("1");
+		else
+			printf ("0");
+	}
+
+	printf ("\n");
+}
+#endif
+
+/*------------------------------------------------------------
+ . Reads a register from the MII Management serial interface
+ .-------------------------------------------------------------*/
+#ifndef CONFIG_SMC91111_EXT_PHY
+static word smc_read_phy_register (byte phyreg)
+{
+	int oldBank;
+	int i;
+	byte mask;
+	word mii_reg;
+	byte bits[64];
+	int clk_idx = 0;
+	int input_idx;
+	word phydata;
+	byte phyaddr = SMC_PHY_ADDR;
+
+	/* 32 consecutive ones on MDO to establish sync */
+	for (i = 0; i < 32; ++i)
+		bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	/* Start code <01> */
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	/* Read command <10> */
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+	bits[clk_idx++] = MII_MDOE;
+
+	/* Output the PHY address, msb first */
+	mask = (byte) 0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyaddr & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		/* Shift to next lowest bit */
+		mask >>= 1;
+	}
+
+	/* Output the phy register number, msb first */
+	mask = (byte) 0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyreg & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		/* Shift to next lowest bit */
+		mask >>= 1;
+	}
+
+	/* Tristate and turnaround (2 bit times) */
+	bits[clk_idx++] = 0;
+	/*bits[clk_idx++] = 0; */
+
+	/* Input starts at this bit time */
+	input_idx = clk_idx;
+
+	/* Will input 16 bits */
+	for (i = 0; i < 16; ++i)
+		bits[clk_idx++] = 0;
+
+	/* Final clock bit */
+	bits[clk_idx++] = 0;
+
+	/* Save the current bank */
+	oldBank = SMC_inw (BANK_SELECT);
+
+	/* Select bank 3 */
+	SMC_SELECT_BANK (3);
+
+	/* Get the current MII register value */
+	mii_reg = SMC_inw (MII_REG);
+
+	/* Turn off all MII Interface bits */
+	mii_reg &= ~(MII_MDOE | MII_MCLK | MII_MDI | MII_MDO);
+
+	/* Clock all 64 cycles */
+	for (i = 0; i < sizeof bits; ++i) {
+		/* Clock Low - output data */
+		SMC_outw (mii_reg | bits[i], MII_REG);
+		udelay (SMC_PHY_CLOCK_DELAY);
+
+
+		/* Clock Hi - input data */
+		SMC_outw (mii_reg | bits[i] | MII_MCLK, MII_REG);
+		udelay (SMC_PHY_CLOCK_DELAY);
+		bits[i] |= SMC_inw (MII_REG) & MII_MDI;
+	}
+
+	/* Return to idle state */
+	/* Set clock to low, data to low, and output tristated */
+	SMC_outw (mii_reg, MII_REG);
+	udelay (SMC_PHY_CLOCK_DELAY);
+
+	/* Restore original bank select */
+	SMC_SELECT_BANK (oldBank);
+
+	/* Recover input data */
+	phydata = 0;
+	for (i = 0; i < 16; ++i) {
+		phydata <<= 1;
+
+		if (bits[input_idx++] & MII_MDI)
+			phydata |= 0x0001;
+	}
+
+#if (SMC_DEBUG > 2 )
+	printf ("smc_read_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x\n",
+		phyaddr, phyreg, phydata);
+	smc_dump_mii_stream (bits, sizeof bits);
+#endif
+
+	return (phydata);
+}
+
+
+/*------------------------------------------------------------
+ . Writes a register to the MII Management serial interface
+ .-------------------------------------------------------------*/
+static void smc_write_phy_register (byte phyreg, word phydata)
+{
+	int oldBank;
+	int i;
+	word mask;
+	word mii_reg;
+	byte bits[65];
+	int clk_idx = 0;
+	byte phyaddr = SMC_PHY_ADDR;
+
+	/* 32 consecutive ones on MDO to establish sync */
+	for (i = 0; i < 32; ++i)
+		bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	/* Start code <01> */
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	/* Write command <01> */
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	/* Output the PHY address, msb first */
+	mask = (byte) 0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyaddr & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		/* Shift to next lowest bit */
+		mask >>= 1;
+	}
+
+	/* Output the phy register number, msb first */
+	mask = (byte) 0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyreg & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		/* Shift to next lowest bit */
+		mask >>= 1;
+	}
+
+	/* Tristate and turnaround (2 bit times) */
+	bits[clk_idx++] = 0;
+	bits[clk_idx++] = 0;
+
+	/* Write out 16 bits of data, msb first */
+	mask = 0x8000;
+	for (i = 0; i < 16; ++i) {
+		if (phydata & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		/* Shift to next lowest bit */
+		mask >>= 1;
+	}
+
+	/* Final clock bit (tristate) */
+	bits[clk_idx++] = 0;
+
+	/* Save the current bank */
+	oldBank = SMC_inw (BANK_SELECT);
+
+	/* Select bank 3 */
+	SMC_SELECT_BANK (3);
+
+	/* Get the current MII register value */
+	mii_reg = SMC_inw (MII_REG);
+
+	/* Turn off all MII Interface bits */
+	mii_reg &= ~(MII_MDOE | MII_MCLK | MII_MDI | MII_MDO);
+
+	/* Clock all cycles */
+	for (i = 0; i < sizeof bits; ++i) {
+		/* Clock Low - output data */
+		SMC_outw (mii_reg | bits[i], MII_REG);
+		udelay (SMC_PHY_CLOCK_DELAY);
+
+
+		/* Clock Hi - input data */
+		SMC_outw (mii_reg | bits[i] | MII_MCLK, MII_REG);
+		udelay (SMC_PHY_CLOCK_DELAY);
+		bits[i] |= SMC_inw (MII_REG) & MII_MDI;
+	}
+
+	/* Return to idle state */
+	/* Set clock to low, data to low, and output tristated */
+	SMC_outw (mii_reg, MII_REG);
+	udelay (SMC_PHY_CLOCK_DELAY);
+
+	/* Restore original bank select */
+	SMC_SELECT_BANK (oldBank);
+
+#if (SMC_DEBUG > 2 )
+	printf ("smc_write_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x\n",
+		phyaddr, phyreg, phydata);
+	smc_dump_mii_stream (bits, sizeof bits);
+#endif
+}
+#endif /* !CONFIG_SMC91111_EXT_PHY */
+
+
+/*------------------------------------------------------------
+ . Waits the specified number of milliseconds - kernel friendly
+ .-------------------------------------------------------------*/
+#ifndef CONFIG_SMC91111_EXT_PHY
+static void smc_wait_ms(unsigned int ms)
+{
+	udelay(ms*1000);
+}
+#endif /* !CONFIG_SMC91111_EXT_PHY */
+
+
+/*------------------------------------------------------------
+ . Configures the specified PHY using Autonegotiation. Calls
+ . smc_phy_fixed() if the user has requested a certain config.
+ .-------------------------------------------------------------*/
+#ifndef CONFIG_SMC91111_EXT_PHY
+static void smc_phy_configure ()
+{
+	int timeout;
+	byte phyaddr;
+	word my_phy_caps;	/* My PHY capabilities */
+	word my_ad_caps;	/* My Advertised capabilities */
+	word status = 0;	/*;my status = 0 */
+	int failed = 0;
+
+	PRINTK3 ("%s: smc_program_phy()\n", SMC_DEV_NAME);
+
+
+	/* Get the detected phy address */
+	phyaddr = SMC_PHY_ADDR;
+
+	/* Reset the PHY, setting all other bits to zero */
+	smc_write_phy_register (PHY_CNTL_REG, PHY_CNTL_RST);
+
+	/* Wait for the reset to complete, or time out */
+	timeout = 6;		/* Wait up to 3 seconds */
+	while (timeout--) {
+		if (!(smc_read_phy_register (PHY_CNTL_REG)
+		      & PHY_CNTL_RST)) {
+			/* reset complete */
+			break;
+		}
+
+		smc_wait_ms (500);	/* wait 500 millisecs */
+	}
+
+	if (timeout < 1) {
+		printf ("%s:PHY reset timed out\n", SMC_DEV_NAME);
+		goto smc_phy_configure_exit;
+	}
+
+	/* Read PHY Register 18, Status Output */
+	/* lp->lastPhy18 = smc_read_phy_register(PHY_INT_REG); */
+
+	/* Enable PHY Interrupts (for register 18) */
+	/* Interrupts listed here are disabled */
+	smc_write_phy_register (PHY_MASK_REG, 0xffff);
+
+	/* Configure the Receive/Phy Control register */
+	SMC_SELECT_BANK (0);
+	SMC_outw (RPC_DEFAULT, RPC_REG);
+
+	/* Copy our capabilities from PHY_STAT_REG to PHY_AD_REG */
+	my_phy_caps = smc_read_phy_register (PHY_STAT_REG);
+	my_ad_caps = PHY_AD_CSMA;	/* I am CSMA capable */
+
+	if (my_phy_caps & PHY_STAT_CAP_T4)
+		my_ad_caps |= PHY_AD_T4;
+
+	if (my_phy_caps & PHY_STAT_CAP_TXF)
+		my_ad_caps |= PHY_AD_TX_FDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TXH)
+		my_ad_caps |= PHY_AD_TX_HDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TF)
+		my_ad_caps |= PHY_AD_10_FDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TH)
+		my_ad_caps |= PHY_AD_10_HDX;
+
+	/* Update our Auto-Neg Advertisement Register */
+	smc_write_phy_register (PHY_AD_REG, my_ad_caps);
+
+	/* Read the register back.  Without this, it appears that when */
+	/* auto-negotiation is restarted, sometimes it isn't ready and */
+	/* the link does not come up. */
+	smc_read_phy_register(PHY_AD_REG);
+
+	PRINTK2 ("%s: phy caps=%x\n", SMC_DEV_NAME, my_phy_caps);
+	PRINTK2 ("%s: phy advertised caps=%x\n", SMC_DEV_NAME, my_ad_caps);
+
+	/* Restart auto-negotiation process in order to advertise my caps */
+	smc_write_phy_register (PHY_CNTL_REG,
+				PHY_CNTL_ANEG_EN | PHY_CNTL_ANEG_RST);
+
+	/* Wait for the auto-negotiation to complete.  This may take from */
+	/* 2 to 3 seconds. */
+	/* Wait for the reset to complete, or time out */
+	timeout = CONFIG_SMC_AUTONEG_TIMEOUT * 2;
+	while (timeout--) {
+
+		status = smc_read_phy_register (PHY_STAT_REG);
+		if (status & PHY_STAT_ANEG_ACK) {
+			/* auto-negotiate complete */
+			break;
+		}
+
+		smc_wait_ms (500);	/* wait 500 millisecs */
+
+		/* Restart auto-negotiation if remote fault */
+		if (status & PHY_STAT_REM_FLT) {
+			printf ("%s: PHY remote fault detected\n",
+				SMC_DEV_NAME);
+
+			/* Restart auto-negotiation */
+			printf ("%s: PHY restarting auto-negotiation\n",
+				SMC_DEV_NAME);
+			smc_write_phy_register (PHY_CNTL_REG,
+						PHY_CNTL_ANEG_EN |
+						PHY_CNTL_ANEG_RST |
+						PHY_CNTL_SPEED |
+						PHY_CNTL_DPLX);
+		}
+	}
+
+	if (timeout < 1) {
+		printf ("%s: PHY auto-negotiate timed out\n", SMC_DEV_NAME);
+		failed = 1;
+	}
+
+	/* Fail if we detected an auto-negotiate remote fault */
+	if (status & PHY_STAT_REM_FLT) {
+		printf ("%s: PHY remote fault detected\n", SMC_DEV_NAME);
+		failed = 1;
+	}
+
+	/* Re-Configure the Receive/Phy Control register */
+	SMC_outw (RPC_DEFAULT, RPC_REG);
+
+smc_phy_configure_exit:	;
+
+}
+#endif /* !CONFIG_SMC91111_EXT_PHY */
+
+
+#if SMC_DEBUG > 2
+static void print_packet( byte * buf, int length )
+{
+	int i;
+	int remainder;
+	int lines;
+
+	printf("Packet of length %d \n", length );
+
+#if SMC_DEBUG > 3
+	lines = length / 16;
+	remainder = length % 16;
+
+	for ( i = 0; i < lines ; i ++ ) {
+		int cur;
+
+		for ( cur = 0; cur < 8; cur ++ ) {
+			byte a, b;
+
+			a = *(buf ++ );
+			b = *(buf ++ );
+			printf("%02x%02x ", a, b );
+		}
+		printf("\n");
+	}
+	for ( i = 0; i < remainder/2 ; i++ ) {
+		byte a, b;
+
+		a = *(buf ++ );
+		b = *(buf ++ );
+		printf("%02x%02x ", a, b );
+	}
+	printf("\n");
+#endif
+}
+#endif
+
+int smc_get_ethaddr (bd_t * bd)
+{
+	int env_size, rom_valid, env_present = 0, reg;
+	char *s = NULL, *e, *v_mac, es[] = "11:22:33:44:55:66";
+	char s_env_mac[64];
+	uchar v_env_mac[6], v_rom_mac[6];
+
+	env_size = getenv_r ("ethaddr", s_env_mac, sizeof (s_env_mac));
+	if ((env_size > 0) && (env_size < sizeof (es))) {	/* exit if env is bad */
+		printf ("\n*** ERROR: ethaddr is not set properly!!\n");
+		return (-1);
+	}
+
+	if (env_size > 0) {
+		env_present = 1;
+		s = s_env_mac;
+	}
+
+	for (reg = 0; reg < 6; ++reg) { /* turn string into mac value */
+		v_env_mac[reg] = s ? simple_strtoul (s, &e, 16) : 0;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+	rom_valid = get_rom_mac (v_rom_mac);	/* get ROM mac value if any */
+
+	if (!env_present) {	/* if NO env */
+		if (rom_valid) {	/* but ROM is valid */
+			v_mac = (char *)v_rom_mac;
+			sprintf (s_env_mac, "%02X:%02X:%02X:%02X:%02X:%02X",
+				 v_mac[0], v_mac[1], v_mac[2], v_mac[3],
+				 v_mac[4], v_mac[5]);
+			setenv ("ethaddr", s_env_mac);
+		} else {	/* no env, bad ROM */
+			printf ("\n*** ERROR: ethaddr is NOT set !!\n");
+			return (-1);
+		}
+	} else {		/* good env, don't care ROM */
+		v_mac = (char *)v_env_mac;	/* always use a good env over a ROM */
+	}
+
+	if (env_present && rom_valid) { /* if both env and ROM are good */
+		if (memcmp (v_env_mac, v_rom_mac, 6) != 0) {
+			printf ("\nWarning: MAC addresses don't match:\n");
+			printf ("\tHW MAC address:  "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_rom_mac[0], v_rom_mac[1],
+				v_rom_mac[2], v_rom_mac[3],
+				v_rom_mac[4], v_rom_mac[5] );
+			printf ("\t\"ethaddr\" value: "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_env_mac[0], v_env_mac[1],
+				v_env_mac[2], v_env_mac[3],
+				v_env_mac[4], v_env_mac[5]) ;
+			debug ("### Set MAC addr from environment\n");
+		}
+	}
+	memcpy (bd->bi_enetaddr, v_mac, 6);	/* update global address to match env (allows env changing) */
+	smc_set_mac_addr ((uchar *)v_mac);	/* use old function to update smc default */
+	PRINTK("Using MAC Address %02X:%02X:%02X:%02X:%02X:%02X\n", v_mac[0], v_mac[1],
+		v_mac[2], v_mac[3], v_mac[4], v_mac[5]);
+	return (0);
+}
+
+int get_rom_mac (uchar *v_rom_mac)
+{
+#ifdef HARDCODE_MAC	/* used for testing or to supress run time warnings */
+	char hw_mac_addr[] = { 0x02, 0x80, 0xad, 0x20, 0x31, 0xb8 };
+
+	memcpy (v_rom_mac, hw_mac_addr, 6);
+	return (1);
+#else
+	int i;
+	int valid_mac = 0;
+
+	SMC_SELECT_BANK (1);
+	for (i=0; i<6; i++)
+	{
+		v_rom_mac[i] = SMC_inb ((ADDR0_REG + i));
+		valid_mac |= v_rom_mac[i];
+	}
+
+	return (valid_mac ? 1 : 0);
+#endif
+}
+
+// 91111 code end
+
+// 9118 code start
+#define SMC9118_DEV_NAME "SMC9118"
+
+#ifndef CONFIG_SMC_RV_BASE
+	include/configs/<board>.h must define the base address of the device registers
+#endif
+
+#define SMC9118_DBG 0
+
+#if SMC9118_DBG > 1
+static const char version[] =
+	"smc9118.c:v1.0 06/10/24 by Peter Pearse <peter.pearse@arm.com>\n";
+#endif
+
+#if (SMC9118_DBG > 2 )
+# define PRINTK3(args...) printf(args)
+#else
+# define PRINTK3(args...)
+#endif
+
+#if SMC9118_DBG > 1
+# define PRINTK2(args...) printf(args)
+#else
+# define PRINTK2(args...)
+#endif
+
+#ifdef SMC9118_DBG
+# define PRINTK(args...) printf(args)
+#else
+# define PRINTK(args...)
+#endif
+
+#if SMC9118_DBG > 0
+
+static void smsc9118_print_mac_registers(void)
+{
+    unsigned int read;
+    int i;
+
+    i = 0;
+    read = 0;
+
+    for(i = 1; i <= 0xC; i++) {
+        smsc9118_mac_regread(i, &read);
+        debug("MAC Register %02d: 0x%08x\n",i,read);
+    }
+
+    debug("\n");
+    return;
+}
+static void smsc9118_print_registers(void){
+    volatile unsigned int *i;
+
+    for  (i = (volatile unsigned int *)CONFIG_SMC_RV_BASE; (int)i < (int)SMSC9118_RESERVED3; i++){
+        debug("Register @%p 0x%08x\n",i, *i);
+    }
+
+} 
+static void smsc9118_print_phy_registers(void)
+{
+    unsigned short read;
+    unsigned int i;
+
+    i = 0;
+    read = 0;
+    for(i = 0; i <= 6; i++) {
+        smsc9118_phy_regread(i, &read);
+        debug("PHY Register %02d: 0x%08x\n",i,read);
+    }
+    smsc9118_phy_regread(i = 17, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 18, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 27, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 29, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 30, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    smsc9118_phy_regread(i = 31, &read);
+    debug("Phy Register %02d: 0x%08x\n", i, read);
+
+    debug("\n");
+    return;
+}
+#endif /* SMC9118_DBG > 0 */
+
+#ifdef SHARED_RESOURCES
+/*
+ * Resource swapper
+ */
+void swap_to(int device_id);
+#endif
+
+/*
+ * ----------------------------------------------------------
+ *
+ * Chip register access routines
+ *
+ * ----------------------------------------------------------
+ */
+static int smsc9118_mac_regread(unsigned char regoffset, unsigned int *data)
+{
+    unsigned int val, maccmd;
+    int timedout;
+    int error;
+    ulong start;
+
+    error = 0;
+    val = *SMSC9118_MAC_CSR_CMD;
+    if(!(val & ((unsigned int)1 << 31))) {    // Make sure there's no pending operation
+        maccmd = 0;
+        maccmd |= regoffset;
+        maccmd |= ((unsigned int)1 << 30);     // Indicates read
+        maccmd |= ((unsigned int)1 << 31);     // Start bit
+        *SMSC9118_MAC_CSR_CMD = maccmd; // Start operation
+
+	start = get_timer (0);
+        do {
+	    timedout = get_timer(start) > MS50 ? 1 : 0;
+            val = *SMSC9118_BYTE_TEST;  // A no-op read.
+        } while(!timedout && (*SMSC9118_MAC_CSR_CMD & ((unsigned int)1 << 31)));
+
+        if(timedout) {
+            printf("Error: SMSC9118 MAC CSR read operation timed out.\n");
+            error = 1;
+            return error;
+        }
+        *data = *SMSC9118_MAC_CSR_DATA;
+    } else {
+        printf("Warning: SMSC9118 MAC CSR is busy. No data read.\n");
+        *data = 0;
+    }
+    return 0;
+}
+
+static int smsc9118_mac_regwrite(unsigned char regoffset, unsigned int val)
+{
+    unsigned int read, maccmd;
+    int timedout;
+    int error;
+    ulong start;
+
+    debug("MAC[%02d] write 0x%08x \n", regoffset, val);
+
+    error = 0;
+    read = *SMSC9118_MAC_CSR_CMD;
+    if(!(read & ((unsigned int)1 << 31))) { // Make sure there's no pending operation
+        *SMSC9118_MAC_CSR_DATA = val;       // Load data.
+        maccmd = 0;
+        maccmd |= regoffset;
+        maccmd &= ~((unsigned int)1 << 30); // Clear indicates write
+        maccmd |= ((unsigned int)1 << 31);  // Indicate start of operation
+        *SMSC9118_MAC_CSR_CMD = maccmd;
+
+	start = get_timer (0);
+        do {
+	    timedout = get_timer(start) > MS50 ? 1 : 0;
+            read = *SMSC9118_BYTE_TEST;     // A no-op read.
+        } while(!timedout && (*SMSC9118_MAC_CSR_CMD & ((unsigned int)1 << 31)));
+
+        if(timedout) {
+            printf("Error: SMSC9118 MAC CSR write operation timed out.\n");
+            error = 1;
+            return error;
+        }
+    } else {
+        printf("Warning: SMSC9118 MAC CSR is busy. No data written.\n");
+    }
+    return 0;
+}
+
+static int smsc9118_phy_regread(unsigned char regoffset, unsigned short *data)
+{
+    unsigned int val, phycmd; int error;
+    int timedout;
+    ulong start;
+
+    error = 0;
+
+    smsc9118_mac_regread(SMSC9118_MAC_MII_ACC, &val);
+
+    if(!(val & 1)) {				// Not busy
+        phycmd = 0;
+        phycmd |= (1 << 11);			// 1 to [15:11]
+        phycmd |= ((regoffset & 0x1F) << 6);	// Put regoffset to [10:6]
+        phycmd &= ~(1 << 1);			// Clear [1] indicates read.
+        phycmd |= (1 << 0);			// Set [0] indicates operation start
+
+        smsc9118_mac_regwrite(SMSC9118_MAC_MII_ACC, phycmd);
+
+	        val = 0;
+        timedout = 0;
+	start = get_timer (0);
+        do {
+	    timedout = get_timer(start) > MS50 ? 1 : 0;
+            smsc9118_mac_regread(SMSC9118_MAC_MII_ACC,&val);
+        } while(!timedout && (val & ((unsigned int)1 << 0)));
+
+        if(timedout) {
+            printf("Error: SMSC9118 MAC MII read operation timed out.\n");
+            error = 1;
+            return error;
+        }
+        smsc9118_mac_regread(SMSC9118_MAC_MII_DATA, &val);
+
+    } else {
+        printf("Warning: SMSC9118 MAC MII is busy. No data read.\n");
+        val = 0;
+    }
+    *data = (unsigned short)(val & 0xFFFF);
+    return 0;
+}
+
+static int smsc9118_phy_regwrite(unsigned char regoffset, unsigned short data)
+{
+    unsigned int val, phycmd, u32data; int error;
+    int timedout;
+    ulong start;
+
+    u32data = (unsigned int)data;
+
+    debug("PHY[%02d] write 0x%08x \n", regoffset, u32data);
+    smsc9118_mac_regread(SMSC9118_MAC_MII_ACC, &val);
+
+    if(!(val & 1)) {    // Not busy
+        smsc9118_mac_regwrite(SMSC9118_MAC_MII_DATA, u32data); // Load the data
+        phycmd = 0;
+        phycmd |= (1 << 11);                    // 1 to [15:11]
+        phycmd |= ((regoffset & 0x1F) << 6);     // Put regoffset to [10:6]
+        phycmd |= (1 << 1);                     // Set [1] indicates write.
+        phycmd |= (1 << 0);                     // Set [0] indicates operation start
+        smsc9118_mac_regwrite(SMSC9118_MAC_MII_ACC, phycmd);   // Start operation
+
+        phycmd = 0;
+        timedout = 0;
+
+	start = get_timer (0);
+        do {
+	    timedout = get_timer(start) > MS50 ? 1 : 0;
+            smsc9118_mac_regread(SMSC9118_MAC_MII_ACC, &phycmd);
+        } while(!timedout && (phycmd & (1 << 0)));
+
+        if(timedout) {
+            printf("Error: SMSC9118 MAC MII write operation timed out.\n");
+            error = 1;
+            return error;
+        }
+
+    } else {
+        printf("Warning: SMSC9118 MAC MII is busy. No data written.\n");
+    }
+    return 0;
+}
+
+/*
+ ------------------------------------------------------------
+ .
+ . Internal routines
+ .
+ ------------------------------------------------------------
+*/
+/*
+ * Functions left as in/outu16, even for ARM where ARM WORD == 32 bits == (2* Other Architecture Word)
+ * until we decide we can't use the common functions.....
+ */
+#ifdef CONFIG_SMC_USE_IOFUNCS
+/*
+ * input and output functions
+ * - the access macros defined in smc9118.h may not 
+ *   work for other boards - they have only been tested on 
+ *   ARM RealViewEB Revision D boards 
+ *
+ *   This code is copied from smc91111.c (functions & types renamed),
+ *   however 16 bit access may be different for SMC9118 
+ *   - see the datasheet & test well before use
+ *
+ */
+# if defined(CONFIG_SMC_USE_32_BIT)
+	32 bit access functions not yet provided
+# else
+static inline u16 SMC9118_inu16(u32 offset);
+static inline void SMC9118_outu16(u16 value, u32 offset);
+static inline u8 SMC9118_inu8(u32 offset);
+static inline void SMC9118_outu8(u8 value, u32 offset);
+static inline void SMC9118_ins16(u32 offset, volatile uchar* buf, u32 len);
+static inline void SMC9118_outs16(u32 offset, uchar* buf, u32 len);
+
+#define barrier() __asm__ __volatile__("": : :"memory")
+
+#define SMC9118_BASE_ADDRESS CONFIG_SMC_RV_BASE
+
+static inline u16 SMC9118_inu16(u32 offset)
+{
+	u16 v;
+	v = *((volatile u16*)(SMC9118_BASE_ADDRESS+offset));
+	barrier(); *(volatile u32*)(0xc0000000);
+	return v;
+}
+
+static inline void SMC9118_outu16(u16 value, u32 offset)
+{
+	*((volatile u16*)(SMC9118_BASE_ADDRESS+offset)) = value;
+	barrier(); *(volatile u32*)(0xc0000000);
+}
+
+static inline u8 SMC9118_inu8(u32 offset)
+{
+	u16  _w;
+
+	_w = SMC9118_inu16(offset & ~((u32)1));
+	return (offset & 1) ? (u8)(_w >> 8) : (u8)(_w);
+}
+
+static inline void SMC9118_outu8(u8 value, u32 offset)
+{
+	u16  _w;
+
+	_w = SMC9118_inu16(offset & ~((u32)1));
+	if (offset & 1)
+			*((volatile u16*)(SMC9118_BASE_ADDRESS+(offset & ~((u32)1)))) = (value<<8) | (_w & 0x00ff);
+	else
+			*((volatile u16*)(SMC9118_BASE_ADDRESS+offset)) = value | (_w & 0xff00);
+}
+
+static inline void SMC9118_ins16(u32 offset, volatile uchar* buf, u32 len)
+{
+	volatile u16 *p = (volatile u16 *)buf;
+
+	while (len-- > 0) {
+		*p++ = SMC9118_inu16(offset);
+		barrier();
+		*((volatile u32*)(0xc0000000));
+	}
+}
+
+static inline void SMC9118_outs16(u32 offset, uchar* buf, u32 len)
+{
+	volatile u16 *p = (volatile u16 *)buf;
+
+	while (len-- > 0) {
+		SMC9118_outu16(*p++, offset);
+		barrier();
+		*(volatile u32*)(0xc0000000);
+	}
+}
+# endif
+#endif  /* CONFIG_SMC_USE_IOFUNCS */
+
+// Returns smsc9118 id.
+static unsigned int smsc9118_read_id(void)
+{
+    return *SMSC9118_ID_REV;
+}
+
+static int smsc9118_check_id(void)
+{
+    int error = 0;
+    unsigned int id;
+
+    id = smsc9118_read_id();
+
+    switch(((id >> 16) & 0xFFFF)) {
+        case 0x118:
+            // If bottom and top halves of the words are the same
+	    // then the bus mode is incorrect
+            if(((id >> 16) & 0xFFFF) == (id & 0xFFFF)) {
+                printf("Error: The SMSC9118 bus is in 16-bit mode. 32-bit mode was expected.\n");
+                error = 1;
+            } 
+            break;
+
+        default:
+            printf("Error: SMSC9118 id reads: 0x%08x, either an unknown chip, or error.\n",id);
+            error = 1;
+            break;
+    }
+
+    if((id & 0xFFFF) == 0) {
+        printf("Error: This test is not intended for this chip revision.\n");
+        error = 1;
+    }
+
+    return error;
+}
+
+// Initiates a soft reset, returns failure or success.
+static __inline int smsc9118_soft_reset(void)
+{
+    int timedout = 0;
+    ulong start;
+
+    // Soft reset
+    *SMSC9118_HW_CFG |= 1;
+
+    // Wait
+    start = get_timer(0);
+    while (!timedout && (*SMSC9118_HW_CFG & 1)){
+    	timedout = get_timer(start) < MS10 ? 0 : 1;
+    }
+
+    return timedout;
+}
+
+
+static 
+__inline 
+void smsc9118_set_txfifo(unsigned int val)
+{
+    // 2kb minimum, 14kb maximum
+    if(val < 2 || val > 14)
+        return;
+
+    *SMSC9118_HW_CFG = val << 16;
+}
+
+static int smsc9118_wait_eeprom(void)
+{
+    int timedout = 0;
+    // Wait
+    ulong start = get_timer(0);
+    while (!timedout && (*SMSC9118_E2P_CMD & ((unsigned int) 1 << 31))){
+    	timedout = get_timer(start) < MS50 ? 0 : 1;
+    }
+
+    return timedout;
+}
+
+static 
+__inline 
+void smsc9118_init_irqs(void)
+{
+	*SMSC9118_INT_EN    = 0;
+	*SMSC9118_INT_STS   = 0xFFFFFFFF;
+	*SMSC9118_IRQ_CFG   = 0x22000100;   //irq deassertion at 220 usecs.
+}
+
+/* 
+ * If ethaddr environment variable has a valid values, set the MAC address to it,
+ * otherwise check that the MAC address loaded in the smc9118 is valid
+ * Note that we do not change the value of the MAC address stored in the smc9118 EEPROM (the auto-loaded MAC)
+ *
+ * Datasheet has 12:34:56:78:9A:BC stored as ADDRH 0xBC9A
+ *		 ADDRH 0x....BC9A
+ *		 ADDRL 0x12345678
+ *		 0x12 transmitted first
+ * This code gets them in the same order in the TX buffer as the smc91111
+ *
+ * Returns 1 on success
+ */
+int smc9118_set_valid_ethaddr(void){
+	unsigned int mac_low;
+	unsigned int mac_high;
+	uchar mac[6];
+	int env_size = 0, env_present = 0, reg;
+	char *s = NULL, *endp, dummy_mac[] = "11:22:33:44:55:66";
+	char s_env_mac[0x18];
+
+	/* Try for ethadd from environment */
+	env_size = getenv_r ("ethaddr", s_env_mac, sizeof (s_env_mac));
+	if ((env_size > 0) && (env_size != sizeof (dummy_mac))) {	/* exit if env is bad */
+		printf ("\n*** ERROR: ethaddr is not set properly!!\n");
+	} else {
+		env_present = 1;
+	}
+
+	if (env_present) {
+		s = s_env_mac;
+
+		/* Environment string to mac numbers */
+		for (reg = 0; reg < 6; ++reg) { 
+			mac[reg] = s ? simple_strtoul (s, &endp, 16) : 0;
+			if (s)
+				s = (*endp) ? endp + 1 : endp;
+		}
+		mac_high =                                             (mac[5] * 0x100) + mac[4];
+		mac_low =  (mac[3] * 0x1000000) + (mac[2] * 0x10000) + (mac[1] * 0x100) + mac[0];
+		debug("MAC Address environment                   value hi:0x%08x lo:0x%08x\n", mac_high, mac_low);
+	} else {
+		/* read from smc9118 */
+		if(*SMSC9118_E2P_CMD & 1) {
+        		// Read current auto-loaded mac address.
+    			smsc9118_mac_regread(SMSC9118_MAC_ADDRH, &mac_high);
+    			smsc9118_mac_regread(SMSC9118_MAC_ADDRL, &mac_low);
+			env_present = 1;
+			debug("MAC Address Auto Load                     value hi:0x%08x lo:0x%08x\n", mac_high, mac_low);
+		} else {
+			printf("This board has no MAC Address Auto Load\n");
+		}
+	}
+	if(env_present){
+		/* Set the MAC address int the smc9118 registers */
+		debug("MAC address in chip is about to be set to value hi:0x%08x lo:0x%08x\n", mac_high, mac_low);
+		smsc9118_mac_regwrite(SMSC9118_MAC_ADDRH, mac_high);
+		smsc9118_mac_regwrite(SMSC9118_MAC_ADDRL, mac_low);
+	}
+	return env_present; 
+}
+
+static __inline int smsc9118_check_phy(void)
+{
+    unsigned short phyid1, phyid2;
+
+    smsc9118_phy_regread(SMSC9118_PHY_ID1,&phyid1);
+    smsc9118_phy_regread(SMSC9118_PHY_ID2,&phyid2);
+    debug("PHY ID1: 0x%08x, PHY ID2: 0x%08x\n\n",phyid1, phyid2);
+    return ((phyid1 == 0xFFFF && phyid2 == 0xFFFF) ||
+            (phyid1 == 0x0 && phyid2 == 0x0));
+}
+static __inline int smsc9118_reset_phy(void)
+{
+	unsigned short read;
+	int error;
+
+	debug("smsc9118_reset_phy()\n");
+
+	error = 0;
+
+	if(smsc9118_phy_regread(SMSC9118_PHY_BCONTROL, &read)) {
+		printf("Error: PHY BCONTROL read failed.\n");
+		error = 1;
+	} else {
+
+		read |= (1 << 15);
+		if(smsc9118_phy_regwrite(SMSC9118_PHY_BCONTROL, read)) {
+			printf("Error: PHY BCONTROL write failed.\n");
+			error = 1;
+		}
+	}
+	return error;
+}
+
+/* Advertise all speeds and pause capabilities */
+static __inline void smsc9118_advertise_cap(void)
+{
+    unsigned short aneg_adv;
+    aneg_adv = 0;
+
+    smsc9118_phy_regread(SMSC9118_PHY_ANEG_ADV, &aneg_adv);
+    debug("advertise_cap: PHY_ANEG_ADV before write: 0x%08x\n",aneg_adv);
+    aneg_adv |= 0xDE0;
+
+    smsc9118_phy_regwrite(SMSC9118_PHY_ANEG_ADV, aneg_adv);
+    smsc9118_phy_regread(SMSC9118_PHY_ANEG_ADV, &aneg_adv);
+    debug("advertise_cap: PHY_ANEG_ADV: after write: 0x%08x\n",aneg_adv);
+    return;
+}
+static 
+__inline 
+void smsc9118_establish_link(void)
+{
+    unsigned short bcr;
+
+    smsc9118_phy_regread(SMSC9118_PHY_BCONTROL, &bcr);
+    debug("establish link: PHY_BCONTROL before write: 0x%08x\n",bcr);
+    bcr |= (1 << 12) | (1 << 9);
+    smsc9118_phy_regwrite(SMSC9118_PHY_BCONTROL, bcr);
+    smsc9118_phy_regread(SMSC9118_PHY_BCONTROL, &bcr);
+    debug("establish link: PHY_BCONTROL after write: 0x%08x\n", bcr);
+
+    {
+        unsigned int hw_cfg;
+
+        hw_cfg = 0;
+        hw_cfg = *SMSC9118_HW_CFG;
+
+        hw_cfg &= 0xF0000;
+        hw_cfg |= (1 << 20);
+        *SMSC9118_HW_CFG = hw_cfg;
+    }
+
+    return;
+}
+static 
+__inline 
+void smsc9118_enable_xmit(void)
+{
+    *SMSC9118_TX_CFG = 0x2; // Enable transmission
+    return;
+}
+
+static __inline void smsc9118_enable_mac_xmit(void)
+{
+    unsigned int mac_cr;
+
+    mac_cr = 0;
+    smsc9118_mac_regread(SMSC9118_MAC_CR, &mac_cr);
+
+    mac_cr |= (1 << 3);     // xmit enable
+    mac_cr |= (1 << 28);    // Heartbeat disable
+
+    smsc9118_mac_regwrite(SMSC9118_MAC_CR, mac_cr);
+    return;
+}
+
+static __inline void smsc9118_enable_mac_recv(void)
+{
+    unsigned int mac_cr;
+
+    mac_cr = 0;
+    smsc9118_mac_regread(SMSC9118_MAC_CR, &mac_cr);
+    mac_cr |= (1 << 2);     // Recv enable
+    smsc9118_mac_regwrite(SMSC9118_MAC_CR, mac_cr);
+
+    return;
+}
+
+
+static __inline void smsc9118_disable_mac_xmit(void)
+{
+    unsigned int mac_cr;
+
+    mac_cr = 0;
+    smsc9118_mac_regread(SMSC9118_MAC_CR, &mac_cr);
+
+    mac_cr &= ~(1 << 3);     // xmit enable
+    mac_cr &= ~(1 << 28);    // Heartbeat disable
+
+    smsc9118_mac_regwrite(SMSC9118_MAC_CR, mac_cr);
+    return;
+}
+static __inline void smsc9118_disable_xmit(void)
+{
+    *SMSC9118_TX_CFG = 0; // Disable trasmission
+    return;
+}
+
+static __inline void smsc9118_disable_mac_recv(void)
+{
+    unsigned int mac_cr;
+
+    mac_cr = 0;
+    smsc9118_mac_regread(SMSC9118_MAC_CR, &mac_cr);
+    mac_cr &= ~(1 << 2);     // Recv enable
+    smsc9118_mac_regwrite(SMSC9118_MAC_CR, mac_cr);
+
+    return;
+}
+
+
+
+#define SMC9118_DEFAULT_TXFIFO_KB	5
+/*
+ * Note that the datasheet states that an interrupt status bits is set regardless
+ * of the setting of the interrupt enable bit for that interrupt.
+ * i.e. we don't have to enable interrupts for a polled driver.
+ */
+static int smsc9118_initialise(void)
+{
+	int error = 1;
+	ulong start;
+
+	if(smsc9118_check_id()) {
+		printf("Reading the Ethernet ID register failed.\n"
+		"Check that a SMSC9118 device is present on the system @ %p.\n", (void*)CONFIG_SMC_RV_BASE);
+	} else if(smsc9118_soft_reset()) {
+		printf("Error: SMSC9118 soft reset failed to complete.\n");
+	} else {
+		smsc9118_set_txfifo(SMC9118_DEFAULT_TXFIFO_KB);
+
+		// Sets automatic flow control thresholds, and backpressure
+		// threshold to defaults specified.
+		*SMSC9118_AFC_CFG = 0x006E3740;
+
+		if(smsc9118_wait_eeprom()) {
+			printf("Error: EEPROM failed to finish initialisation.\n");
+		} else {
+
+			// Configure GPIOs as LED outputs.
+			*SMSC9118_GPIO_CFG = 0x70070000;
+
+			smsc9118_init_irqs();
+		
+			/* Configure MAC addresses */
+			// Set from environment if present
+			// else check valid
+			if(smc9118_set_valid_ethaddr()){
+
+				if(smsc9118_check_phy()) {
+					printf("Error: SMSC9118 PHY not present.\n");
+				} else {
+
+					if(smsc9118_reset_phy()) {
+						printf("Error: SMSC9118 PHY reset failed.\n");
+					} else {
+						unsigned short phyreset = 0;
+
+						// Wait
+						start = get_timer(0);
+						while (get_timer(start) < MS100){
+							;
+						}
+
+						// Checking whether phy reset completed successfully.
+						smsc9118_phy_regread(SMSC9118_PHY_BCONTROL, &phyreset);
+						if(phyreset & (1 << 15)) {
+							printf("Error: SMSC9118 PHY reset stage failed to complete.\n");
+						} else {
+
+							/* Advertise capabilities */
+							smsc9118_advertise_cap();
+
+							/* Begin to establish link */
+							smsc9118_establish_link();      // bit [12] of BCONTROL seems self-clearing.
+							// Although it's not so in the manual.
+
+							/* Interrupt threshold */
+							*SMSC9118_FIFO_INT = 0xFF000000;
+
+							smsc9118_enable_mac_xmit();
+
+							smsc9118_enable_xmit();
+
+							*SMSC9118_RX_CFG = 0;
+
+							smsc9118_enable_mac_recv();
+
+							// Rx status FIFO level irq threshold
+							*SMSC9118_FIFO_INT &= ~(0xFF);  // Clear 2 bottom nibbles
+
+							// This spin is compulsory otherwise txmit/receive will fail.
+							start = get_timer(0);
+							while (get_timer(start) < MS2000){
+								;
+							}
+							error = 0;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return error;
+}
+
+int smsc9118_recv_packet(unsigned int *recvbuf, int *index)
+{
+    unsigned int rxfifo_inf;    // Tells us the status of rx payload and status fifos.
+    unsigned int rxfifo_stat;
+
+    unsigned int pktsize;
+    unsigned int dwords_to_read;
+
+    debug("recv_packet start: recvbuf: 0x%08x index: %d\n",
+            (unsigned int)recvbuf,*index);
+
+    rxfifo_inf = *SMSC9118_RX_FIFO_INF;
+
+    if(rxfifo_inf & 0xFFFF) { // If there's data
+        rxfifo_stat = *SMSC9118_RX_STAT_PORT;
+        if(rxfifo_stat != 0) {   // Fetch status of this packet
+            pktsize = ((rxfifo_stat >> 16) & 0x3FFF);
+            // debug("recv_packet: rxfifo_stat: 0x%08x, pktsize (bytes): %u\n",rxfifo_stat, pktsize);
+	    if(*SMSC9118_INT_STS & 0x4000){
+	    	printf("Status read RXE is %d\n", *SMSC9118_INT_STS & 0x4000 ? 1 : 0);
+	    	*SMSC9118_INT_STS = 0xFFFFFFFF;
+	    }
+            if(rxfifo_stat & (1 << 15)) {
+                printf("Error occured during receiving of packets on the bus.\n");
+                return 1;
+            } else {
+                /* Below formula (recommended by SMSC9118 code)
+                 * gives 1 more than required. This is because
+                 * a last word is needed for not word aligned packets.
+                 */
+                dwords_to_read = (pktsize + sizeof(unsigned int) - 1) >> 2;
+                debug("recv_packet: dwords_to_read: %u\n",dwords_to_read);
+                // PIO copy of data received:
+                while((*SMSC9118_RX_FIFO_INF & 0x0000FFFF) && (dwords_to_read > 0)) {
+                    recvbuf[*index] = *SMSC9118_RX_DATA_PORT;
+                    // debug("recv_packet: Received word[%d]: 0x%08x\n",*index,recvbuf[*index]);
+                    (*index)++;
+                    dwords_to_read--;
+                }
+	        if(*SMSC9118_INT_STS & 0x4000){
+			printf("Data read RXE is %d\n", *SMSC9118_INT_STS & 0x4000 ? 1 : 0);
+	    		*SMSC9118_INT_STS = 0xFFFFFFFF;
+		}
+            }
+        } else {
+            printf("Error: rx fifo status reads zero where data is available.\n");
+            return 1;
+        }
+    } else {
+        // printf("Error: No data available in rx FIFO\n");
+        return 1;
+    }
+
+    return 0;
+}
+// Does the actual transfer of data to FIFO, note it does no
+// fifo availability checking. This should be done by caller.
+// ASSUMES the whole frame is transferred at once as a single segment
+// ASSUMES chip auto pads to minimum ethernet packet length
+void smsc9118_xfer_to_txFIFO(unsigned char * pkt, unsigned int length)
+{
+    unsigned int txcmd_a, txcmd_b;
+    unsigned int dwords_to_write;
+    volatile unsigned int dwritten;
+    unsigned int *pktptr;
+
+    pktptr = (unsigned int *) pkt;
+    
+    txcmd_a = 0;
+    txcmd_b = 0;
+
+    txcmd_a |= (1 << 12) | (1 << 13);   // First and last segments
+    txcmd_a |= length & 0x7FF;          // [10:0] contains length
+
+    txcmd_b |= ((length & 0xFFFF) << 16); // [31:16] contains length, rather than tag
+    txcmd_b |= length & 0x7FF;          // [10:0] also contains length
+
+    debug("txcmd_a: 0x%08x\n", txcmd_a);
+    debug("txcmd_b: 0x%08x\n", txcmd_b);
+
+    *SMSC9118_TX_DATA_PORT = txcmd_a;
+    *SMSC9118_TX_DATA_PORT = txcmd_b;
+    dwritten = dwords_to_write = (length + sizeof(unsigned int) - 1) >> 2;
+
+
+    // PIO Copy to FIFO. Could replace this with DMA.
+    while(dwords_to_write > 0) {
+         *SMSC9118_TX_DATA_PORT = *pktptr;
+         debug("Transmitting word[%d]: 0x%08x\n",dwritten-dwords_to_write,*pktptr);
+         pktptr++;
+         dwords_to_write--;
+    }
+
+    {
+    	/* 
+	 * Note that the read after read timings from table 6.2 are not used
+	 */
+        volatile unsigned int xmit_stat, xmit_stat2, xmit_inf;
+        int i;
+        xmit_stat = *SMSC9118_TX_STAT_PORT;
+        debug("Finished transfer. TX_STATUS_WORD: 0x%08x\n",xmit_stat);
+        xmit_stat2 = *SMSC9118_TX_STAT_PORT;
+        xmit_inf = *SMSC9118_TX_FIFO_INF;
+        debug("After popping TX_STAT: %08x, TX_INF: 0x%08x\n\n",xmit_stat2, xmit_inf);
+
+	// ASSUMES that the register is emptied
+	// - doesn't seem to do so in real life.......
+        if(xmit_stat2 != 0 ) {
+            debug("The second read of TX_STAT is non-zero. Retry reading a few more times.\n");
+            for(i = 0; i < 6; i++) {
+                xmit_stat2 = *SMSC9118_TX_STAT_PORT;
+                debug("Retry %d: TX_STAT: 0x%08x\n",i+1,xmit_stat2);
+            }
+        }
+    }
+}
+
+int smsc9118_xmit_packet(unsigned char * pktbuf, int pktsize)
+{
+    unsigned int txfifo_inf;
+
+    txfifo_inf = *SMSC9118_TX_FIFO_INF;
+    debug("TX_FIFO_INF: 0x%08x\n", txfifo_inf);
+
+    if((txfifo_inf & 0xFFFF) >= pktsize) {
+        smsc9118_xfer_to_txFIFO(pktbuf, pktsize);
+    } else {
+        printf("Insufficient tx fifo space for packet size %d\n",pktsize);
+        return 1;
+    }
+    return 0;
+}
+// 9118 code end
+
+// Merged functions
+
+/*
+ * Ethernet API
+ */
+int eth_init(bd_t *bd) {
+	int retval = 0;
+
+#ifdef SHARED_RESOURCES
+	swap_to(ETHERNET);
+#endif
+	if(LAN_INVALID == chip_type){
+		chip_type = get_chip_type();
+	}
+	switch (chip_type){
+	case LAN91C111:	
+		retval = smc_open(bd);
+		break;
+
+	case LAN9118:	
+		retval = smsc9118_initialise();
+		break;
+	}
+
+	return retval;
+}
+
+
+void eth_halt() {
+	if(LAN_INVALID == chip_type){
+		chip_type = get_chip_type();
+	}
+	switch(chip_type){
+	case LAN91C111:
+		smc_close();
+		break;
+
+	case LAN9118:
+		smsc9118_disable_xmit();
+		smsc9118_disable_mac_xmit();
+		smsc9118_disable_mac_recv();
+		break;
+	}
+}
+
+int eth_rx() {
+	int retval = 0;
+	if(LAN_INVALID == chip_type){
+		chip_type = get_chip_type();
+	}
+	switch(chip_type){
+	case LAN91C111:
+		retval = smc_rcv();
+		break;
+
+	case LAN9118:
+	{
+		int index = 0;
+    
+    		int rxfifo_inf = *SMSC9118_RX_FIFO_INF;
+		/*
+		 *  Any status info???
+		 */
+		if(rxfifo_inf & 0x00FF0000){
+
+			smsc9118_recv_packet((unsigned int *)NetRxPackets[0], &index);
+			if(index) {
+				NetReceive(NetRxPackets[0], index * 4);
+			}
+		}
+		retval = 4 * index;
+
+		break;
+	}
+	}
+	return retval;
+
+}
+
+int eth_send(volatile void *packet, int length) {
+	int retval = 0;
+	if(LAN_INVALID == chip_type){
+		chip_type = get_chip_type();
+	}
+	switch(chip_type){
+	case LAN91C111:
+		retval = smc_send_packet(packet, length);
+		break;
+	
+	case LAN9118:
+	{
+		int result = 0;
+		int i;
+		debug("Raw packet as %d decimal bytes:\n", length);
+		for(i= 0; i < length; i++){
+			debug(" %02x ", ((char*)packet)[i]);
+			if(!((i+1)%8)){										    
+				debug("\n");									    
+			}											    
+		}												    
+		debug("\n");											    
+		if(!smsc9118_xmit_packet((unsigned char *)packet, length)){
+			result = length;
+		} 
+		retval = result;
+		break;
+	}
+	}
+	return retval;
+}
+
+
+#endif /* CONFIG_DRIVER_SMC_RV */
diff --git a/drivers/net/smc_rv.h b/drivers/net/smc_rv.h
new file mode 100644
index 0000000..9269466
--- /dev/null
+++ b/drivers/net/smc_rv.h
@@ -0,0 +1,1198 @@
+/*------------------------------------------------------------------------
+ . A merge of the following files to use for the RealView boards
+ . - it may have either chip
+ .
+ . Macros for the LAN91C111 Ethernet Driver drivers/net/smc91111.h
+ . 	Authors
+ . 		Erik Stahlman		( erik@vt.edu )
+ .		Daris A Nevil		( dnevil@snmc.com )
+ .
+ . Macros for the LAN9118   Ethernet Driver drivers/net/smc9118.h
+ . 	author:
+ .		Peter Pearse 		( peter.pearse@arm.com)
+ .
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . author:
+ .	Peter Pearse				( peter.pearse@arm.com)
+ .
+ . History
+ .	2007.10.10	Initial file merge
+ .
+ ---------------------------------------------------------------------------*/
+#ifndef _SMC_RV_H_
+#define _SMC_RV_H_
+
+#include <asm/types.h>
+#include <config.h>
+
+/* Chip Types */
+enum {
+	LAN_INVALID,
+	LAN91C111,
+	LAN9118, 
+};
+
+// 91111 Start
+
+/*
+ * This function may be called by the board specific initialisation code
+ * in order to override the default mac address.
+ */
+
+void smc_set_mac_addr (const unsigned char *addr);
+
+
+/* I want some simple types */
+
+typedef unsigned char			byte;
+typedef unsigned short			word;
+typedef unsigned long int 		dword;
+
+/*
+ . DEBUGGING LEVELS
+ .
+ . 0 for normal operation
+ . 1 for slightly more details
+ . >2 for various levels of increasingly useless information
+ .    2 for interrupt tracking, status flags
+ .    3 for packet info
+ .    4 for complete packet dumps
+*/
+/*#define SMC_DEBUG 0 */
+
+/* Because of bank switching, the LAN91xxx uses only 16 I/O ports */
+
+#define	SMC_IO_EXTENT	16
+
+#ifdef CONFIG_PXA250
+
+#ifdef CONFIG_XSENGINE
+#define	SMC_inl(r) 	(*((volatile dword *)(SMC_BASE_ADDRESS+(r<<1))))
+#define	SMC_inw(r) 	(*((volatile word *)(SMC_BASE_ADDRESS+(r<<1))))
+#define SMC_inb(p)	({ \
+	unsigned int __p = (unsigned int)(SMC_BASE_ADDRESS + (p<<1)); \
+	unsigned int __v = *(volatile unsigned short *)((__p) & ~2); \
+	if (__p & 2) __v >>= 8; \
+	else __v &= 0xff; \
+	__v; })
+#elif defined(CONFIG_XAENIAX)
+#define SMC_inl(r)	(*((volatile dword *)(SMC_BASE_ADDRESS+(r))))
+#define SMC_inw(z)	({ \
+	unsigned int __p = (unsigned int)(SMC_BASE_ADDRESS + (z)); \
+	unsigned int __v = *(volatile unsigned int *)((__p) & ~3); \
+	if (__p & 3) __v >>= 16; \
+	else __v &= 0xffff; \
+	__v; })
+#define SMC_inb(p)	({ \
+	unsigned int ___v = SMC_inw((p) & ~1); \
+	if (p & 1) ___v >>= 8; \
+	else ___v &= 0xff; \
+	___v; })
+#else
+#define	SMC_inl(r) 	(*((volatile dword *)(SMC_BASE_ADDRESS+(r))))
+#define	SMC_inw(r) 	(*((volatile word *)(SMC_BASE_ADDRESS+(r))))
+#define SMC_inb(p)	({ \
+	unsigned int __p = (unsigned int)(SMC_BASE_ADDRESS + (p)); \
+	unsigned int __v = *(volatile unsigned short *)((__p) & ~1); \
+	if (__p & 1) __v >>= 8; \
+	else __v &= 0xff; \
+	__v; })
+#endif
+
+#ifdef CONFIG_XSENGINE
+#define	SMC_outl(d,r)	(*((volatile dword *)(SMC_BASE_ADDRESS+(r<<1))) = d)
+#define	SMC_outw(d,r)	(*((volatile word *)(SMC_BASE_ADDRESS+(r<<1))) = d)
+#elif defined (CONFIG_XAENIAX)
+#define SMC_outl(d,r)	(*((volatile dword *)(SMC_BASE_ADDRESS+(r))) = d)
+#define SMC_outw(d,p)	({ \
+	dword __dwo = SMC_inl((p) & ~3); \
+	dword __dwn = (word)(d); \
+	__dwo &= ((p) & 3) ? 0x0000ffff : 0xffff0000; \
+	__dwo |= ((p) & 3) ? __dwn << 16 : __dwn; \
+	SMC_outl(__dwo, (p) & ~3); \
+})
+#else
+#define	SMC_outl(d,r)	(*((volatile dword *)(SMC_BASE_ADDRESS+(r))) = d)
+#define	SMC_outw(d,r)	(*((volatile word *)(SMC_BASE_ADDRESS+(r))) = d)
+#endif
+
+#define	SMC_outb(d,r)	({	word __d = (byte)(d);  \
+				word __w = SMC_inw((r)&~1);  \
+				__w &= ((r)&1) ? 0x00FF : 0xFF00;  \
+				__w |= ((r)&1) ? __d<<8 : __d;  \
+				SMC_outw(__w,(r)&~1);  \
+			})
+
+#define SMC_outsl(r,b,l)	({	int __i; \
+					dword *__b2; \
+					__b2 = (dword *) b; \
+					for (__i = 0; __i < l; __i++) { \
+					    SMC_outl( *(__b2 + __i), r); \
+					} \
+				})
+
+#define SMC_outsw(r,b,l)	({	int __i; \
+					word *__b2; \
+					__b2 = (word *) b; \
+					for (__i = 0; __i < l; __i++) { \
+					    SMC_outw( *(__b2 + __i), r); \
+					} \
+				})
+
+#define SMC_insl(r,b,l) 	({	int __i ;  \
+					dword *__b2;  \
+			    		__b2 = (dword *) b;  \
+			    		for (__i = 0; __i < l; __i++) {  \
+					  *(__b2 + __i) = SMC_inl(r);  \
+					  SMC_inl(0);  \
+					};  \
+				})
+
+#define SMC_insw(r,b,l) 	({	int __i ;  \
+					word *__b2;  \
+			    		__b2 = (word *) b;  \
+			    		for (__i = 0; __i < l; __i++) {  \
+					  *(__b2 + __i) = SMC_inw(r);  \
+					  SMC_inw(0);  \
+					};  \
+				})
+
+#define SMC_insb(r,b,l) 	({	int __i ;  \
+					byte *__b2;  \
+			    		__b2 = (byte *) b;  \
+			    		for (__i = 0; __i < l; __i++) {  \
+					  *(__b2 + __i) = SMC_inb(r);  \
+					  SMC_inb(0);  \
+					};  \
+				})
+
+#else /* if not CONFIG_PXA250 */
+
+#ifndef CONFIG_SMC_USE_IOFUNCS /* these macros don't work on some boards */
+/*
+ * We have only 16 Bit PCMCIA access on Socket 0
+ */
+
+#ifdef CONFIG_ADNPESC1
+#define	SMC_inw(r) 	(*((volatile word *)(SMC_BASE_ADDRESS+((r)<<1))))
+#elif CONFIG_BLACKFIN
+#define	SMC_inw(r) 	({ word __v = (*((volatile word *)(SMC_BASE_ADDRESS+(r)))); asm("ssync;"); __v;})
+#else
+#define	SMC_inw(r) 	(*((volatile word *)(SMC_BASE_ADDRESS+(r))))
+#endif
+#define  SMC_inb(r)	(((r)&1) ? SMC_inw((r)&~1)>>8 : SMC_inw(r)&0xFF)
+
+#ifdef CONFIG_ADNPESC1
+#define	SMC_outw(d,r)	(*((volatile word *)(SMC_BASE_ADDRESS+((r)<<1))) = d)
+#elif CONFIG_BLACKFIN
+#define	SMC_outw(d,r)	{(*((volatile word *)(SMC_BASE_ADDRESS+(r))) = d);asm("ssync;");}
+#else
+#define	SMC_outw(d,r)	(*((volatile word *)(SMC_BASE_ADDRESS+(r))) = d)
+#endif
+#define	SMC_outb(d,r)	({	word __d = (byte)(d);  \
+				word __w = SMC_inw((r)&~1);  \
+				__w &= ((r)&1) ? 0x00FF : 0xFF00;  \
+				__w |= ((r)&1) ? __d<<8 : __d;  \
+				SMC_outw(__w,(r)&~1);  \
+			})
+#if 0
+#define	SMC_outsw(r,b,l)	outsw(SMC_BASE_ADDRESS+(r), (b), (l))
+#else
+#define SMC_outsw(r,b,l)	({	int __i; \
+					word *__b2; \
+					__b2 = (word *) b; \
+					for (__i = 0; __i < l; __i++) { \
+					    SMC_outw( *(__b2 + __i), r); \
+					} \
+				})
+#endif
+
+#if 0
+#define	SMC_insw(r,b,l) 	insw(SMC_BASE_ADDRESS+(r), (b), (l))
+#else
+#define SMC_insw(r,b,l) 	({	int __i ;  \
+					word *__b2;  \
+			    		__b2 = (word *) b;  \
+			    		for (__i = 0; __i < l; __i++) {  \
+					  *(__b2 + __i) = SMC_inw(r);  \
+					  SMC_inw(0);  \
+					};  \
+				})
+#endif
+
+#endif  /* CONFIG_SMC_USE_IOFUNCS */
+
+#if defined(CONFIG_SMC_USE_32_BIT)
+
+#ifdef CONFIG_XSENGINE
+#define	SMC_inl(r) 	(*((volatile dword *)(SMC_BASE_ADDRESS+(r<<1))))
+#else
+#define	SMC_inl(r) 	(*((volatile dword *)(SMC_BASE_ADDRESS+(r))))
+#endif
+
+#define SMC_insl(r,b,l) 	({	int __i ;  \
+					dword *__b2;  \
+			    		__b2 = (dword *) b;  \
+			    		for (__i = 0; __i < l; __i++) {  \
+					  *(__b2 + __i) = SMC_inl(r);  \
+					  SMC_inl(0);  \
+					};  \
+				})
+
+#ifdef CONFIG_XSENGINE
+#define	SMC_outl(d,r)	(*((volatile dword *)(SMC_BASE_ADDRESS+(r<<1))) = d)
+#else
+#define	SMC_outl(d,r)	(*((volatile dword *)(SMC_BASE_ADDRESS+(r))) = d)
+#endif
+#define SMC_outsl(r,b,l)	({	int __i; \
+					dword *__b2; \
+					__b2 = (dword *) b; \
+					for (__i = 0; __i < l; __i++) { \
+					    SMC_outl( *(__b2 + __i), r); \
+					} \
+				})
+
+#endif /* CONFIG_SMC_USE_32_BIT */
+
+#endif
+
+/*---------------------------------------------------------------
+ .
+ . A description of the SMSC registers is probably in order here,
+ . although for details, the SMC datasheet is invaluable.
+ .
+ . Basically, the chip has 4 banks of registers ( 0 to 3 ), which
+ . are accessed by writing a number into the BANK_SELECT register
+ . ( I also use a SMC_SELECT_BANK macro for this ).
+ .
+ . The banks are configured so that for most purposes, bank 2 is all
+ . that is needed for simple run time tasks.
+ -----------------------------------------------------------------------*/
+
+/*
+ . Bank Select Register:
+ .
+ .		yyyy yyyy 0000 00xx
+ .		xx 		= bank number
+ .		yyyy yyyy	= 0x33, for identification purposes.
+*/
+#define	BANK_SELECT		14
+
+/* Transmit Control Register */
+/* BANK 0  */
+#define	TCR_REG 	0x0000 	/* transmit control register */
+#define TCR_ENABLE	0x0001	/* When 1 we can transmit */
+#define TCR_LOOP	0x0002	/* Controls output pin LBK */
+#define TCR_FORCOL	0x0004	/* When 1 will force a collision */
+#define TCR_PAD_EN	0x0080	/* When 1 will pad tx frames < 64 bytes w/0 */
+#define TCR_NOCRC	0x0100	/* When 1 will not append CRC to tx frames */
+#define TCR_MON_CSN	0x0400	/* When 1 tx monitors carrier */
+#define TCR_FDUPLX    	0x0800  /* When 1 enables full duplex operation */
+#define TCR_STP_SQET	0x1000	/* When 1 stops tx if Signal Quality Error */
+#define	TCR_EPH_LOOP	0x2000	/* When 1 enables EPH block loopback */
+#define	TCR_SWFDUP	0x8000	/* When 1 enables Switched Full Duplex mode */
+
+#define	TCR_CLEAR	0	/* do NOTHING */
+/* the default settings for the TCR register : */
+/* QUESTION: do I want to enable padding of short packets ? */
+#define	TCR_DEFAULT  	TCR_ENABLE
+
+
+/* EPH Status Register */
+/* BANK 0  */
+#define EPH_STATUS_REG	0x0002
+#define ES_TX_SUC	0x0001	/* Last TX was successful */
+#define ES_SNGL_COL	0x0002	/* Single collision detected for last tx */
+#define ES_MUL_COL	0x0004	/* Multiple collisions detected for last tx */
+#define ES_LTX_MULT	0x0008	/* Last tx was a multicast */
+#define ES_16COL	0x0010	/* 16 Collisions Reached */
+#define ES_SQET		0x0020	/* Signal Quality Error Test */
+#define ES_LTXBRD	0x0040	/* Last tx was a broadcast */
+#define ES_TXDEFR	0x0080	/* Transmit Deferred */
+#define ES_LATCOL	0x0200	/* Late collision detected on last tx */
+#define ES_LOSTCARR	0x0400	/* Lost Carrier Sense */
+#define ES_EXC_DEF	0x0800	/* Excessive Deferral */
+#define ES_CTR_ROL	0x1000	/* Counter Roll Over indication */
+#define ES_LINK_OK	0x4000	/* Driven by inverted value of nLNK pin */
+#define ES_TXUNRN	0x8000	/* Tx Underrun */
+
+
+/* Receive Control Register */
+/* BANK 0  */
+#define	RCR_REG		0x0004
+#define	RCR_RX_ABORT	0x0001	/* Set if a rx frame was aborted */
+#define	RCR_PRMS	0x0002	/* Enable promiscuous mode */
+#define	RCR_ALMUL	0x0004	/* When set accepts all multicast frames */
+#define RCR_RXEN	0x0100	/* IFF this is set, we can receive packets */
+#define	RCR_STRIP_CRC	0x0200	/* When set strips CRC from rx packets */
+#define	RCR_ABORT_ENB	0x0200	/* When set will abort rx on collision */
+#define	RCR_FILT_CAR	0x0400	/* When set filters leading 12 bit s of carrier */
+#define RCR_SOFTRST	0x8000 	/* resets the chip */
+
+/* the normal settings for the RCR register : */
+#define	RCR_DEFAULT	(RCR_STRIP_CRC | RCR_RXEN)
+#define RCR_CLEAR	0x0	/* set it to a base state */
+
+/* Counter Register */
+/* BANK 0  */
+#define	COUNTER_REG	0x0006
+
+/* Memory Information Register */
+/* BANK 0  */
+#define	MIR_REG		0x0008
+
+/* Receive/Phy Control Register */
+/* BANK 0  */
+#define	RPC_REG		0x000A
+#define	RPC_SPEED	0x2000	/* When 1 PHY is in 100Mbps mode. */
+#define	RPC_DPLX	0x1000	/* When 1 PHY is in Full-Duplex Mode */
+#define	RPC_ANEG	0x0800	/* When 1 PHY is in Auto-Negotiate Mode */
+#define	RPC_LSXA_SHFT	5	/* Bits to shift LS2A,LS1A,LS0A to lsb */
+#define	RPC_LSXB_SHFT	2	/* Bits to get LS2B,LS1B,LS0B to lsb */
+#define RPC_LED_100_10	(0x00)	/* LED = 100Mbps OR's with 10Mbps link detect */
+#define RPC_LED_RES	(0x01)	/* LED = Reserved */
+#define RPC_LED_10	(0x02)	/* LED = 10Mbps link detect */
+#define RPC_LED_FD	(0x03)	/* LED = Full Duplex Mode */
+#define RPC_LED_TX_RX	(0x04)	/* LED = TX or RX packet occurred */
+#define RPC_LED_100	(0x05)	/* LED = 100Mbps link dectect */
+#define RPC_LED_TX	(0x06)	/* LED = TX packet occurred */
+#define RPC_LED_RX	(0x07)	/* LED = RX packet occurred */
+#if defined(CONFIG_DK1C20) || defined(CONFIG_DK1S10)
+/* buggy schematic: LEDa -> yellow, LEDb --> green */
+#define RPC_DEFAULT	( RPC_SPEED | RPC_DPLX | RPC_ANEG	\
+			| (RPC_LED_TX_RX << RPC_LSXA_SHFT)	\
+			| (RPC_LED_100_10 << RPC_LSXB_SHFT)	)
+#elif defined(CONFIG_ADNPESC1)
+/* SSV ADNP/ESC1 has only one LED: LEDa -> Rx/Tx indicator */
+#define RPC_DEFAULT	( RPC_SPEED | RPC_DPLX | RPC_ANEG	\
+			| (RPC_LED_TX_RX << RPC_LSXA_SHFT)	\
+			| (RPC_LED_100_10 << RPC_LSXB_SHFT)	)
+#else
+/* SMSC reference design: LEDa --> green, LEDb --> yellow */
+#define RPC_DEFAULT	( RPC_SPEED | RPC_DPLX | RPC_ANEG	\
+			| (RPC_LED_100_10 << RPC_LSXA_SHFT)	\
+			| (RPC_LED_TX_RX << RPC_LSXB_SHFT)	)
+#endif
+
+/* Bank 0 0x000C is reserved */
+
+/* Bank Select Register */
+/* All Banks */
+#define BSR_REG	0x000E
+
+
+/* Configuration Reg */
+/* BANK 1 */
+#define CONFIG_REG	0x0000
+#define CONFIG_EXT_PHY	0x0200	/* 1=external MII, 0=internal Phy */
+#define CONFIG_GPCNTRL	0x0400	/* Inverse value drives pin nCNTRL */
+#define CONFIG_NO_WAIT	0x1000	/* When 1 no extra wait states on ISA bus */
+#define CONFIG_EPH_POWER_EN 0x8000 /* When 0 EPH is placed into low power mode. */
+
+/* Default is powered-up, Internal Phy, Wait States, and pin nCNTRL=low */
+#define CONFIG_DEFAULT	(CONFIG_EPH_POWER_EN)
+
+
+/* Base Address Register */
+/* BANK 1 */
+#define	BASE_REG	0x0002
+
+
+/* Individual Address Registers */
+/* BANK 1 */
+#define	ADDR0_REG	0x0004
+#define	ADDR1_REG	0x0006
+#define	ADDR2_REG	0x0008
+
+
+/* General Purpose Register */
+/* BANK 1 */
+#define	GP_REG		0x000A
+
+
+/* Control Register */
+/* BANK 1 */
+#define	CTL_REG		0x000C
+#define CTL_RCV_BAD	0x4000 /* When 1 bad CRC packets are received */
+#define CTL_AUTO_RELEASE 0x0800 /* When 1 tx pages are released automatically */
+#define	CTL_LE_ENABLE	0x0080 /* When 1 enables Link Error interrupt */
+#define	CTL_CR_ENABLE	0x0040 /* When 1 enables Counter Rollover interrupt */
+#define	CTL_TE_ENABLE	0x0020 /* When 1 enables Transmit Error interrupt */
+#define	CTL_EEPROM_SELECT 0x0004 /* Controls EEPROM reload & store */
+#define	CTL_RELOAD	0x0002 /* When set reads EEPROM into registers */
+#define	CTL_STORE	0x0001 /* When set stores registers into EEPROM */
+#define CTL_DEFAULT     (0x1A10) /* Autorelease enabled*/
+
+/* MMU Command Register */
+/* BANK 2 */
+#define MMU_CMD_REG	0x0000
+#define MC_BUSY		1	/* When 1 the last release has not completed */
+#define MC_NOP		(0<<5)	/* No Op */
+#define	MC_ALLOC	(1<<5) 	/* OR with number of 256 byte packets */
+#define	MC_RESET	(2<<5)	/* Reset MMU to initial state */
+#define	MC_REMOVE	(3<<5) 	/* Remove the current rx packet */
+#define MC_RELEASE  	(4<<5) 	/* Remove and release the current rx packet */
+#define MC_FREEPKT  	(5<<5) 	/* Release packet in PNR register */
+#define MC_ENQUEUE	(6<<5)	/* Enqueue the packet for transmit */
+#define MC_RSTTXFIFO	(7<<5)	/* Reset the TX FIFOs */
+
+
+/* Packet Number Register */
+/* BANK 2 */
+#define	PN_REG		0x0002
+
+
+/* Allocation Result Register */
+/* BANK 2 */
+#define	AR_REG		0x0003
+#define AR_FAILED	0x80	/* Alocation Failed */
+
+
+/* RX FIFO Ports Register */
+/* BANK 2 */
+#define RXFIFO_REG	0x0004	/* Must be read as a word */
+#define RXFIFO_REMPTY	0x8000	/* RX FIFO Empty */
+
+
+/* TX FIFO Ports Register */
+/* BANK 2 */
+#define TXFIFO_REG	RXFIFO_REG	/* Must be read as a word */
+#define TXFIFO_TEMPTY	0x80	/* TX FIFO Empty */
+
+
+/* Pointer Register */
+/* BANK 2 */
+#define PTR_REG		0x0006
+#define	PTR_RCV		0x8000 /* 1=Receive area, 0=Transmit area */
+#define	PTR_AUTOINC 	0x4000 /* Auto increment the pointer on each access */
+#define PTR_READ	0x2000 /* When 1 the operation is a read */
+#define PTR_NOTEMPTY	0x0800 /* When 1 _do not_ write fifo DATA REG */
+
+
+/* Data Register */
+/* BANK 2 */
+#define	SMC91111_DATA_REG	0x0008
+
+
+/* Interrupt Status/Acknowledge Register */
+/* BANK 2 */
+#define	SMC91111_INT_REG	0x000C
+
+
+/* Interrupt Mask Register */
+/* BANK 2 */
+#define IM_REG		0x000D
+#define	IM_MDINT	0x80 /* PHY MI Register 18 Interrupt */
+#define	IM_ERCV_INT	0x40 /* Early Receive Interrupt */
+#define	IM_EPH_INT	0x20 /* Set by Etheret Protocol Handler section */
+#define	IM_RX_OVRN_INT	0x10 /* Set by Receiver Overruns */
+#define	IM_ALLOC_INT	0x08 /* Set when allocation request is completed */
+#define	IM_TX_EMPTY_INT	0x04 /* Set if the TX FIFO goes empty */
+#define	IM_TX_INT	0x02 /* Transmit Interrrupt */
+#define IM_RCV_INT	0x01 /* Receive Interrupt */
+
+
+/* Multicast Table Registers */
+/* BANK 3 */
+#define	MCAST_REG1	0x0000
+#define	MCAST_REG2	0x0002
+#define	MCAST_REG3	0x0004
+#define	MCAST_REG4	0x0006
+
+
+/* Management Interface Register (MII) */
+/* BANK 3 */
+#define	MII_REG		0x0008
+#define MII_MSK_CRS100	0x4000 /* Disables CRS100 detection during tx half dup */
+#define MII_MDOE	0x0008 /* MII Output Enable */
+#define MII_MCLK	0x0004 /* MII Clock, pin MDCLK */
+#define MII_MDI		0x0002 /* MII Input, pin MDI */
+#define MII_MDO		0x0001 /* MII Output, pin MDO */
+
+
+/* Revision Register */
+/* BANK 3 */
+#define	REV_REG		0x000A /* ( hi: chip id   low: rev # ) */
+
+
+/* Early RCV Register */
+/* BANK 3 */
+/* this is NOT on SMC9192 */
+#define	ERCV_REG	0x000C
+#define ERCV_RCV_DISCRD	0x0080 /* When 1 discards a packet being received */
+#define ERCV_THRESHOLD	0x001F /* ERCV Threshold Mask */
+
+/* External Register */
+/* BANK 7 */
+#define	EXT_REG		0x0000
+
+
+#define CHIP_9192	3
+#define CHIP_9194	4
+#define CHIP_9195	5
+#define CHIP_9196	6
+#define CHIP_91100	7
+#define CHIP_91100FD	8
+#define CHIP_91111FD	9
+
+#if 0
+static const char * chip_ids[ 15 ] =  {
+	NULL, NULL, NULL,
+	/* 3 */ "SMC91C90/91C92",
+	/* 4 */ "SMC91C94",
+	/* 5 */ "SMC91C95",
+	/* 6 */ "SMC91C96",
+	/* 7 */ "SMC91C100",
+	/* 8 */ "SMC91C100FD",
+	/* 9 */ "SMC91C111",
+	NULL, NULL,
+	NULL, NULL, NULL};
+#endif
+
+/*
+ . Transmit status bits
+*/
+#define TS_SUCCESS 0x0001
+#define TS_LOSTCAR 0x0400
+#define TS_LATCOL  0x0200
+#define TS_16COL   0x0010
+
+/*
+ . Receive status bits
+*/
+#define RS_ALGNERR	0x8000
+#define RS_BRODCAST	0x4000
+#define RS_BADCRC	0x2000
+#define RS_ODDFRAME	0x1000	/* bug: the LAN91C111 never sets this on receive */
+#define RS_TOOLONG	0x0800
+#define RS_TOOSHORT	0x0400
+#define RS_MULTICAST	0x0001
+#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
+
+
+/* PHY Types */
+enum {
+	PHY_LAN83C183 = 1,	/* LAN91C111 Internal PHY */
+	PHY_LAN83C180
+};
+
+
+/* PHY Register Addresses (LAN91C111 Internal PHY) */
+
+/* PHY Control Register */
+#define PHY_CNTL_REG		0x00
+#define PHY_CNTL_RST		0x8000	/* 1=PHY Reset */
+#define PHY_CNTL_LPBK		0x4000	/* 1=PHY Loopback */
+#define PHY_CNTL_SPEED		0x2000	/* 1=100Mbps, 0=10Mpbs */
+#define PHY_CNTL_ANEG_EN	0x1000 /* 1=Enable Auto negotiation */
+#define PHY_CNTL_PDN		0x0800	/* 1=PHY Power Down mode */
+#define PHY_CNTL_MII_DIS	0x0400	/* 1=MII 4 bit interface disabled */
+#define PHY_CNTL_ANEG_RST	0x0200 /* 1=Reset Auto negotiate */
+#define PHY_CNTL_DPLX		0x0100	/* 1=Full Duplex, 0=Half Duplex */
+#define PHY_CNTL_COLTST		0x0080	/* 1= MII Colision Test */
+
+/* PHY Status Register */
+#define PHY_STAT_REG		0x01
+#define PHY_STAT_CAP_T4		0x8000	/* 1=100Base-T4 capable */
+#define PHY_STAT_CAP_TXF	0x4000	/* 1=100Base-X full duplex capable */
+#define PHY_STAT_CAP_TXH	0x2000	/* 1=100Base-X half duplex capable */
+#define PHY_STAT_CAP_TF		0x1000	/* 1=10Mbps full duplex capable */
+#define PHY_STAT_CAP_TH		0x0800	/* 1=10Mbps half duplex capable */
+#define PHY_STAT_CAP_SUPR	0x0040	/* 1=recv mgmt frames with not preamble */
+#define PHY_STAT_ANEG_ACK	0x0020	/* 1=ANEG has completed */
+#define PHY_STAT_REM_FLT	0x0010	/* 1=Remote Fault detected */
+#define PHY_STAT_CAP_ANEG	0x0008	/* 1=Auto negotiate capable */
+#define PHY_STAT_LINK		0x0004	/* 1=valid link */
+#define PHY_STAT_JAB		0x0002	/* 1=10Mbps jabber condition */
+#define PHY_STAT_EXREG		0x0001	/* 1=extended registers implemented */
+
+/* PHY Identifier Registers */
+#define PHY_ID1_REG		0x02	/* PHY Identifier 1 */
+#define PHY_ID2_REG		0x03	/* PHY Identifier 2 */
+
+/* PHY Auto-Negotiation Advertisement Register */
+#define PHY_AD_REG		0x04
+#define PHY_AD_NP		0x8000	/* 1=PHY requests exchange of Next Page */
+#define PHY_AD_ACK		0x4000	/* 1=got link code word from remote */
+#define PHY_AD_RF		0x2000	/* 1=advertise remote fault */
+#define PHY_AD_T4		0x0200	/* 1=PHY is capable of 100Base-T4 */
+#define PHY_AD_TX_FDX		0x0100	/* 1=PHY is capable of 100Base-TX FDPLX */
+#define PHY_AD_TX_HDX		0x0080	/* 1=PHY is capable of 100Base-TX HDPLX */
+#define PHY_AD_10_FDX		0x0040	/* 1=PHY is capable of 10Base-T FDPLX */
+#define PHY_AD_10_HDX		0x0020	/* 1=PHY is capable of 10Base-T HDPLX */
+#define PHY_AD_CSMA		0x0001	/* 1=PHY is capable of 802.3 CMSA */
+
+/* PHY Auto-negotiation Remote End Capability Register */
+#define PHY_RMT_REG		0x05
+/* Uses same bit definitions as PHY_AD_REG */
+
+/* PHY Configuration Register 1 */
+#define PHY_CFG1_REG		0x10
+#define PHY_CFG1_LNKDIS		0x8000	/* 1=Rx Link Detect Function disabled */
+#define PHY_CFG1_XMTDIS		0x4000	/* 1=TP Transmitter Disabled */
+#define PHY_CFG1_XMTPDN		0x2000	/* 1=TP Transmitter Powered Down */
+#define PHY_CFG1_BYPSCR		0x0400	/* 1=Bypass scrambler/descrambler */
+#define PHY_CFG1_UNSCDS		0x0200	/* 1=Unscramble Idle Reception Disable */
+#define PHY_CFG1_EQLZR		0x0100	/* 1=Rx Equalizer Disabled */
+#define PHY_CFG1_CABLE		0x0080	/* 1=STP(150ohm), 0=UTP(100ohm) */
+#define PHY_CFG1_RLVL0		0x0040	/* 1=Rx Squelch level reduced by 4.5db */
+#define PHY_CFG1_TLVL_SHIFT	2	/* Transmit Output Level Adjust */
+#define PHY_CFG1_TLVL_MASK	0x003C
+#define PHY_CFG1_TRF_MASK	0x0003	/* Transmitter Rise/Fall time */
+
+
+/* PHY Configuration Register 2 */
+#define PHY_CFG2_REG		0x11
+#define PHY_CFG2_APOLDIS	0x0020	/* 1=Auto Polarity Correction disabled */
+#define PHY_CFG2_JABDIS		0x0010	/* 1=Jabber disabled */
+#define PHY_CFG2_MREG		0x0008	/* 1=Multiple register access (MII mgt) */
+#define PHY_CFG2_INTMDIO	0x0004	/* 1=Interrupt signaled with MDIO pulseo */
+
+/* PHY Status Output (and Interrupt status) Register */
+#define PHY_INT_REG		0x12	/* Status Output (Interrupt Status) */
+#define PHY_INT_INT		0x8000	/* 1=bits have changed since last read */
+#define	PHY_INT_LNKFAIL		0x4000	/* 1=Link Not detected */
+#define PHY_INT_LOSSSYNC	0x2000	/* 1=Descrambler has lost sync */
+#define PHY_INT_CWRD		0x1000	/* 1=Invalid 4B5B code detected on rx */
+#define PHY_INT_SSD		0x0800	/* 1=No Start Of Stream detected on rx */
+#define PHY_INT_ESD		0x0400	/* 1=No End Of Stream detected on rx */
+#define PHY_INT_RPOL		0x0200	/* 1=Reverse Polarity detected */
+#define PHY_INT_JAB		0x0100	/* 1=Jabber detected */
+#define PHY_INT_SPDDET		0x0080	/* 1=100Base-TX mode, 0=10Base-T mode */
+#define PHY_INT_DPLXDET		0x0040	/* 1=Device in Full Duplex */
+
+/* PHY Interrupt/Status Mask Register */
+#define PHY_MASK_REG		0x13	/* Interrupt Mask */
+/* Uses the same bit definitions as PHY_INT_REG */
+
+
+/*-------------------------------------------------------------------------
+ .  I define some macros to make it easier to do somewhat common
+ . or slightly complicated, repeated tasks.
+ --------------------------------------------------------------------------*/
+
+/* select a register bank, 0 to 3  */
+
+#define SMC_SELECT_BANK(x)  { SMC_outw( x, BANK_SELECT ); }
+
+/* this enables an interrupt in the interrupt mask register */
+#define SMC_ENABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = SMC_inb( IM_REG );\
+		mask |= (x);\
+		SMC_outb( mask, IM_REG ); \
+}
+
+/* this disables an interrupt from the interrupt mask register */
+
+#define SMC_DISABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = SMC_inb( IM_REG );\
+		mask &= ~(x);\
+		SMC_outb( mask, IM_REG ); \
+}
+
+/*----------------------------------------------------------------------
+ . Define the interrupts that I want to receive from the card
+ .
+ . I want:
+ .  IM_EPH_INT, for nasty errors
+ .  IM_RCV_INT, for happy received packets
+ .  IM_RX_OVRN_INT, because I have to kick the receiver
+ .  IM_MDINT, for PHY Register 18 Status Changes
+ --------------------------------------------------------------------------*/
+#define SMC_INTERRUPT_MASK   (IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | \
+	IM_MDINT)
+
+// 91111 End
+// =====================================================================================
+// 9118 Start
+
+/*
+ *  Timeouts
+ */
+#define MS10     10
+#define MS50     50
+#define MS100   100
+#define MS2000 2000
+
+/*
+ . DEBUGGING LEVELS
+ .
+ . 0 for normal operation
+ . 1 for slightly more details
+ . >2 for various levels of increasingly useless information
+ .    2 for interrupt tracking, status flags
+ .    3 for packet info
+ .    4 for complete packet dumps
+*/
+/*#define SMC9118_DBG 0 */
+
+/*
+ * These macros may not work on some boards
+ * Also the datasheet states:
+ *
+ * "32 bit access is the native environment for the LAN9118 Ethernet controller"
+ *
+ */
+#ifndef CONFIG_SMC_USE_IOFUNCS 
+
+	#if defined(CONFIG_SMC_USE_32_BIT)
+
+		#define	SMC9118_inu32(reg) 	(*((volatile u32 *)(reg)))
+
+		#define SMC9118_ins32(reg,base,len) 	({	int __i ;  \
+					u32 *__b2;  \
+			    		__b2 = (u32 *) base;  \
+			    		for (__i = 0; __i < len; __i++) {  \
+					  *(__b2 + __i) = SMC9118_inu32(reg);  \
+					  SMC9118_inu32(0);  \
+					};  \
+				})
+
+		#define	SMC9118_outu32(data,reg)	(*((volatile u32 *)(reg)) = data)
+		#define SMC9118_outs32(reg,base,len)	({	int __i; \
+					u32 *__b2; \
+					__b2 = (u32 *) base; \
+					for (__i = 0; __i < len; __i++) { \
+					    SMC9118_outu32( *(__b2 + __i), r); \
+					} \
+				})
+  	#else
+		#ifdef CONFIG_DRIVER_SMC9118
+		16 bit access macros have not been provided
+		#endif
+	#endif /* CONFIG_SMC_USE_32_BIT */
+#else
+	#ifdef CONFIG_DRIVER_SMC9118
+	Access functions have not been provided
+	#endif
+#endif  /* CONFIG_USE_IOFUNCS */
+
+
+/*---------------------------------------------------------------
+ . SMSC registers
+ -----------------------------------------------------------------------*/
+/* Transmit Control Register */
+#define	TCR_REG 	0x0000 	/* transmit control register */
+#define TCR_ENABLE	0x0001	/* When 1 we can transmit */
+#define TCR_LOOP	0x0002	/* Controls output pin LBK */
+#define TCR_FORCOL	0x0004	/* When 1 will force a collision */
+#define TCR_PAD_EN	0x0080	/* When 1 will pad tx frames < 64 bytes w/0 */
+#define TCR_NOCRC	0x0100	/* When 1 will not append CRC to tx frames */
+#define TCR_MON_CSN	0x0400	/* When 1 tx monitors carrier */
+#define TCR_FDUPLX    	0x0800  /* When 1 enables full duplex operation */
+#define TCR_STP_SQET	0x1000	/* When 1 stops tx if Signal Quality Error */
+#define	TCR_EPH_LOOP	0x2000	/* When 1 enables EPH block loopback */
+#define	TCR_SWFDUP	0x8000	/* When 1 enables Switched Full Duplex mode */
+
+#define	TCR_CLEAR	0	/* do NOTHING */
+/* the default settings for the TCR register : */
+/* QUESTION: do I want to enable padding of short packets ? */
+#define	TCR_DEFAULT  	TCR_ENABLE
+
+
+/* EPH Status Register */
+#define EPH_STATUS_REG	0x0002
+#define ES_TX_SUC	0x0001	/* Last TX was successful */
+#define ES_SNGL_COL	0x0002	/* Single collision detected for last tx */
+#define ES_MUL_COL	0x0004	/* Multiple collisions detected for last tx */
+#define ES_LTX_MULT	0x0008	/* Last tx was a multicast */
+#define ES_16COL	0x0010	/* 16 Collisions Reached */
+#define ES_SQET		0x0020	/* Signal Quality Error Test */
+#define ES_LTXBRD	0x0040	/* Last tx was a broadcast */
+#define ES_TXDEFR	0x0080	/* Transmit Deferred */
+#define ES_LATCOL	0x0200	/* Late collision detected on last tx */
+#define ES_LOSTCARR	0x0400	/* Lost Carrier Sense */
+#define ES_EXC_DEF	0x0800	/* Excessive Deferral */
+#define ES_CTR_ROL	0x1000	/* Counter Roll Over indication */
+#define ES_LINK_OK	0x4000	/* Driven by inverted value of nLNK pin */
+#define ES_TXUNRN	0x8000	/* Tx Underrun */
+
+
+/* Receive Control Register */
+#define	RCR_REG		0x0004
+#define	RCR_RX_ABORT	0x0001	/* Set if a rx frame was aborted */
+#define	RCR_PRMS	0x0002	/* Enable promiscuous mode */
+#define	RCR_ALMUL	0x0004	/* When set accepts all multicast frames */
+#define RCR_RXEN	0x0100	/* IFF this is set, we can receive packets */
+#define	RCR_STRIP_CRC	0x0200	/* When set strips CRC from rx packets */
+#define	RCR_ABORT_ENB	0x0200	/* When set will abort rx on collision */
+#define	RCR_FILT_CAR	0x0400	/* When set filters leading 12 bit s of carrier */
+#define RCR_SOFTRST	0x8000 	/* resets the chip */
+
+/* the normal settings for the RCR register : */
+#define	RCR_DEFAULT	(RCR_STRIP_CRC | RCR_RXEN)
+#define RCR_CLEAR	0x0	/* set it to a base state */
+
+/* Counter Register */
+#define	COUNTER_REG	0x0006
+
+/* Memory Information Register */
+#define	MIR_REG		0x0008
+
+/* Receive/Phy Control Register */
+#define	RPC_REG		0x000A
+#define	RPC_SPEED	0x2000	/* When 1 PHY is in 100Mbps mode. */
+#define	RPC_DPLX	0x1000	/* When 1 PHY is in Full-Duplex Mode */
+#define	RPC_ANEG	0x0800	/* When 1 PHY is in Auto-Negotiate Mode */
+#define	RPC_LSXA_SHFT	5	/* Bits to shift LS2A,LS1A,LS0A to lsb */
+#define	RPC_LSXB_SHFT	2	/* Bits to get LS2B,LS1B,LS0B to lsb */
+#define RPC_LED_100_10	(0x00)	/* LED = 100Mbps OR's with 10Mbps link detect */
+#define RPC_LED_RES	(0x01)	/* LED = Reserved */
+#define RPC_LED_10	(0x02)	/* LED = 10Mbps link detect */
+#define RPC_LED_FD	(0x03)	/* LED = Full Duplex Mode */
+#define RPC_LED_TX_RX	(0x04)	/* LED = TX or RX packet occurred */
+#define RPC_LED_100	(0x05)	/* LED = 100Mbps link dectect */
+#define RPC_LED_TX	(0x06)	/* LED = TX packet occurred */
+#define RPC_LED_RX	(0x07)	/* LED = RX packet occurred */
+#define RPC_DEFAULT	( RPC_SPEED | RPC_DPLX | RPC_ANEG	\
+			| (RPC_LED_100_10 << RPC_LSXA_SHFT)	\
+			| (RPC_LED_TX_RX << RPC_LSXB_SHFT)	)
+
+/* Bank 0 0x000C is reserved */
+
+/* Bank Select Register */
+/* All Banks */
+#define BSR_REG	0x000E
+
+
+/* Configuration Reg */
+#define CONFIG_REG	0x0000
+#define CONFIG_EXT_PHY	0x0200	/* 1=external MII, 0=internal Phy */
+#define CONFIG_GPCNTRL	0x0400	/* Inverse value drives pin nCNTRL */
+#define CONFIG_NO_WAIT	0x1000	/* When 1 no extra wait states on ISA bus */
+#define CONFIG_EPH_POWER_EN 0x8000 /* When 0 EPH is placed into low power mode. */
+
+/* Default is powered-up, Internal Phy, Wait States, and pin nCNTRL=low */
+#define CONFIG_DEFAULT	(CONFIG_EPH_POWER_EN)
+
+
+/* Base Address Register */
+#define	BASE_REG	0x0002
+
+
+/* Individual Address Registers */
+#define	ADDR0_REG	0x0004
+#define	ADDR1_REG	0x0006
+#define	ADDR2_REG	0x0008
+
+
+/* General Purpose Register */
+#define	GP_REG		0x000A
+
+
+/* Control Register */
+#define	CTL_REG		0x000C
+#define CTL_RCV_BAD	0x4000 /* When 1 bad CRC packets are received */
+#define CTL_AUTO_RELEASE 0x0800 /* When 1 tx pages are released automatically */
+#define	CTL_LE_ENABLE	0x0080 /* When 1 enables Link Error interrupt */
+#define	CTL_CR_ENABLE	0x0040 /* When 1 enables Counter Rollover interrupt */
+#define	CTL_TE_ENABLE	0x0020 /* When 1 enables Transmit Error interrupt */
+#define	CTL_EEPROM_SELECT 0x0004 /* Controls EEPROM reload & store */
+#define	CTL_RELOAD	0x0002 /* When set reads EEPROM into registers */
+#define	CTL_STORE	0x0001 /* When set stores registers into EEPROM */
+#define CTL_DEFAULT     (0x1A10) /* Autorelease enabled*/
+
+/* MMU Command Register */
+#define MMU_CMD_REG	0x0000
+#define MC_BUSY		1	/* When 1 the last release has not completed */
+#define MC_NOP		(0<<5)	/* No Op */
+#define	MC_ALLOC	(1<<5) 	/* OR with number of 256 byte packets */
+#define	MC_RESET	(2<<5)	/* Reset MMU to initial state */
+#define	MC_REMOVE	(3<<5) 	/* Remove the current rx packet */
+#define MC_RELEASE  	(4<<5) 	/* Remove and release the current rx packet */
+#define MC_FREEPKT  	(5<<5) 	/* Release packet in PNR register */
+#define MC_ENQUEUE	(6<<5)	/* Enqueue the packet for transmit */
+#define MC_RSTTXFIFO	(7<<5)	/* Reset the TX FIFOs */
+
+
+/* Packet Number Register */
+#define	PN_REG		0x0002
+
+
+/* Allocation Result Register */
+#define	AR_REG		0x0003
+#define AR_FAILED	0x80	/* Alocation Failed */
+
+
+/* RX FIFO Ports Register */
+#define RXFIFO_REG	0x0004	/* Must be read as a u16 */
+#define RXFIFO_REMPTY	0x8000	/* RX FIFO Empty */
+
+
+/* TX FIFO Ports Register */
+#define TXFIFO_REG	RXFIFO_REG	/* Must be read as a u16 */
+#define TXFIFO_TEMPTY	0x80	/* TX FIFO Empty */
+
+
+/* Pointer Register */
+#define PTR_REG		0x0006
+#define	PTR_RCV		0x8000 /* 1=Receive area, 0=Transmit area */
+#define	PTR_AUTOINC 	0x4000 /* Auto increment the pointer on each access */
+#define PTR_READ	0x2000 /* When 1 the operation is a read */
+#define PTR_NOTEMPTY	0x0800 /* When 1 _do not_ write fifo DATA REG */
+
+
+/* Data Register */
+#define	SMC9118_DATA_REG	0x0008
+
+
+/* Interrupt Status/Acknowledge Register */
+#define	SMC9118_INT_REG	0x000C
+
+
+/* Interrupt Mask Register */
+#define IM_REG		0x000D
+#define	IM_MDINT	0x80 /* PHY MI Register 18 Interrupt */
+#define	IM_ERCV_INT	0x40 /* Early Receive Interrupt */
+#define	IM_EPH_INT	0x20 /* Set by Etheret Protocol Handler section */
+#define	IM_RX_OVRN_INT	0x10 /* Set by Receiver Overruns */
+#define	IM_ALLOC_INT	0x08 /* Set when allocation request is completed */
+#define	IM_TX_EMPTY_INT	0x04 /* Set if the TX FIFO goes empty */
+#define	IM_TX_INT	0x02 /* Transmit Interrrupt */
+#define IM_RCV_INT	0x01 /* Receive Interrupt */
+
+
+/* Multicast Table Registers */
+#define	MCAST_REG1	0x0000
+#define	MCAST_REG2	0x0002
+#define	MCAST_REG3	0x0004
+#define	MCAST_REG4	0x0006
+
+
+/* Management Interface Register (MII) */
+#define	MII_REG		0x0008
+#define MII_MSK_CRS100	0x4000 /* Disables CRS100 detection during tx half dup */
+#define MII_MDOE	0x0008 /* MII Output Enable */
+#define MII_MCLK	0x0004 /* MII Clock, pin MDCLK */
+#define MII_MDI		0x0002 /* MII Input, pin MDI */
+#define MII_MDO		0x0001 /* MII Output, pin MDO */
+
+
+/* Revision Register */
+#define	REV_REG		0x000A /* ( hi: chip id   low: rev # ) */
+
+
+/* Early RCV Register */
+/* this is NOT on SMC9192 */
+#define	ERCV_REG	0x000C
+#define ERCV_RCV_DISCRD	0x0080 /* When 1 discards a packet being received */
+#define ERCV_THRESHOLD	0x001F /* ERCV Threshold Mask */
+
+/* External Register */
+#define	EXT_REG		0x0000
+
+
+#define CHIP_9192	3
+#define CHIP_9194	4
+#define CHIP_9195	5
+#define CHIP_9196	6
+#define CHIP_91100	7
+#define CHIP_91100FD	8
+#define CHIP_91111FD	9
+
+/*
+ . Transmit status bits
+*/
+#define TS_SUCCESS 0x0001
+#define TS_LOSTCAR 0x0400
+#define TS_LATCOL  0x0200
+#define TS_16COL   0x0010
+
+/*
+ . Receive status bits
+*/
+#define RS_ALGNERR	0x8000
+#define RS_BRODCAST	0x4000
+#define RS_BADCRC	0x2000
+#define RS_ODDFRAME	0x1000	/* bug: the LAN9118 never sets this on receive */
+#define RS_TOOLONG	0x0800
+#define RS_TOOSHORT	0x0400
+#define RS_MULTICAST	0x0001
+#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
+
+
+/* PHY Register Addresses (LAN9118 Internal PHY) */
+
+/* PHY Control Register */
+#define PHY_CNTL_REG		0x00
+#define PHY_CNTL_RST		0x8000	/* 1=PHY Reset */
+#define PHY_CNTL_LPBK		0x4000	/* 1=PHY Loopback */
+#define PHY_CNTL_SPEED		0x2000	/* 1=100Mbps, 0=10Mpbs */
+#define PHY_CNTL_ANEG_EN	0x1000 /* 1=Enable Auto negotiation */
+#define PHY_CNTL_PDN		0x0800	/* 1=PHY Power Down mode */
+#define PHY_CNTL_MII_DIS	0x0400	/* 1=MII 4 bit interface disabled */
+#define PHY_CNTL_ANEG_RST	0x0200 /* 1=Reset Auto negotiate */
+#define PHY_CNTL_DPLX		0x0100	/* 1=Full Duplex, 0=Half Duplex */
+#define PHY_CNTL_COLTST		0x0080	/* 1= MII Colision Test */
+
+/* PHY Status Register */
+#define PHY_STAT_REG		0x01
+#define PHY_STAT_CAP_T4		0x8000	/* 1=100Base-T4 capable */
+#define PHY_STAT_CAP_TXF	0x4000	/* 1=100Base-X full duplex capable */
+#define PHY_STAT_CAP_TXH	0x2000	/* 1=100Base-X half duplex capable */
+#define PHY_STAT_CAP_TF		0x1000	/* 1=10Mbps full duplex capable */
+#define PHY_STAT_CAP_TH		0x0800	/* 1=10Mbps half duplex capable */
+#define PHY_STAT_CAP_SUPR	0x0040	/* 1=recv mgmt frames with not preamble */
+#define PHY_STAT_ANEG_ACK	0x0020	/* 1=ANEG has completed */
+#define PHY_STAT_REM_FLT	0x0010	/* 1=Remote Fault detected */
+#define PHY_STAT_CAP_ANEG	0x0008	/* 1=Auto negotiate capable */
+#define PHY_STAT_LINK		0x0004	/* 1=valid link */
+#define PHY_STAT_JAB		0x0002	/* 1=10Mbps jabber condition */
+#define PHY_STAT_EXREG		0x0001	/* 1=extended registers implemented */
+
+/* PHY Identifier Registers */
+#define PHY_ID1_REG		0x02	/* PHY Identifier 1 */
+#define PHY_ID2_REG		0x03	/* PHY Identifier 2 */
+
+/* PHY Auto-Negotiation Advertisement Register */
+#define PHY_AD_REG		0x04
+#define PHY_AD_NP		0x8000	/* 1=PHY requests exchange of Next Page */
+#define PHY_AD_ACK		0x4000	/* 1=got link code u16 from remote */
+#define PHY_AD_RF		0x2000	/* 1=advertise remote fault */
+#define PHY_AD_T4		0x0200	/* 1=PHY is capable of 100Base-T4 */
+#define PHY_AD_TX_FDX		0x0100	/* 1=PHY is capable of 100Base-TX FDPLX */
+#define PHY_AD_TX_HDX		0x0080	/* 1=PHY is capable of 100Base-TX HDPLX */
+#define PHY_AD_10_FDX		0x0040	/* 1=PHY is capable of 10Base-T FDPLX */
+#define PHY_AD_10_HDX		0x0020	/* 1=PHY is capable of 10Base-T HDPLX */
+#define PHY_AD_CSMA		0x0001	/* 1=PHY is capable of 802.3 CMSA */
+
+/* PHY Auto-negotiation Remote End Capability Register */
+#define PHY_RMT_REG		0x05
+/* Uses same bit definitions as PHY_AD_REG */
+
+/* PHY Configuration Register 1 */
+#define PHY_CFG1_REG		0x10
+#define PHY_CFG1_LNKDIS		0x8000	/* 1=Rx Link Detect Function disabled */
+#define PHY_CFG1_XMTDIS		0x4000	/* 1=TP Transmitter Disabled */
+#define PHY_CFG1_XMTPDN		0x2000	/* 1=TP Transmitter Powered Down */
+#define PHY_CFG1_BYPSCR		0x0400	/* 1=Bypass scrambler/descrambler */
+#define PHY_CFG1_UNSCDS		0x0200	/* 1=Unscramble Idle Reception Disable */
+#define PHY_CFG1_EQLZR		0x0100	/* 1=Rx Equalizer Disabled */
+#define PHY_CFG1_CABLE		0x0080	/* 1=STP(150ohm), 0=UTP(100ohm) */
+#define PHY_CFG1_RLVL0		0x0040	/* 1=Rx Squelch level reduced by 4.5db */
+#define PHY_CFG1_TLVL_SHIFT	2	/* Transmit Output Level Adjust */
+#define PHY_CFG1_TLVL_MASK	0x003C
+#define PHY_CFG1_TRF_MASK	0x0003	/* Transmitter Rise/Fall time */
+
+
+/* PHY Configuration Register 2 */
+#define PHY_CFG2_REG		0x11
+#define PHY_CFG2_APOLDIS	0x0020	/* 1=Auto Polarity Correction disabled */
+#define PHY_CFG2_JABDIS		0x0010	/* 1=Jabber disabled */
+#define PHY_CFG2_MREG		0x0008	/* 1=Multiple register access (MII mgt) */
+#define PHY_CFG2_INTMDIO	0x0004	/* 1=Interrupt signaled with MDIO pulseo */
+
+/* PHY Status Output (and Interrupt status) Register */
+#define PHY_INT_REG		0x12	/* Status Output (Interrupt Status) */
+#define PHY_INT_INT		0x8000	/* 1=bits have changed since last read */
+#define	PHY_INT_LNKFAIL		0x4000	/* 1=Link Not detected */
+#define PHY_INT_LOSSSYNC	0x2000	/* 1=Descrambler has lost sync */
+#define PHY_INT_CWRD		0x1000	/* 1=Invalid 4B5B code detected on rx */
+#define PHY_INT_SSD		0x0800	/* 1=No Start Of Stream detected on rx */
+#define PHY_INT_ESD		0x0400	/* 1=No End Of Stream detected on rx */
+#define PHY_INT_RPOL		0x0200	/* 1=Reverse Polarity detected */
+#define PHY_INT_JAB		0x0100	/* 1=Jabber detected */
+#define PHY_INT_SPDDET		0x0080	/* 1=100Base-TX mode, 0=10Base-T mode */
+#define PHY_INT_DPLXDET		0x0040	/* 1=Device in Full Duplex */
+
+/* PHY Interrupt/Status Mask Register */
+#define PHY_MASK_REG		0x13	/* Interrupt Mask */
+/* Uses the same bit definitions as PHY_INT_REG */
+
+
+// SMSC9118 FIFO Ports
+#define SMSC9118_RX_DATA_PORT   (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x0)
+#define SMSC9118_TX_DATA_PORT   (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x20)
+
+// SMSC9118 FIFO status ports and peeks
+// (Reads on ports destructive, reads on peeks have no side effect)
+#define SMSC9118_RX_STAT_PORT   (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x40)
+#define SMSC9118_RX_STAT_PEEK   (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x44)
+
+#define SMSC9118_TX_STAT_PORT   (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x48)
+#define SMSC9118_TX_STAT_PEEK   (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x4C)
+
+
+// SMSC9118 Registers
+#define SMSC9118_ID_REV         (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x50)
+#define SMSC9118_IRQ_CFG        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x54)
+#define SMSC9118_INT_STS        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x58)
+#define SMSC9118_INT_EN         (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x5C)
+#define SMSC9118_RESERVED1      (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x60)
+#define SMSC9118_BYTE_TEST      (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x64)
+#define SMSC9118_FIFO_INT       (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x68)
+#define SMSC9118_RX_CFG	        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x6C)
+#define SMSC9118_TX_CFG	        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x70)
+#define SMSC9118_HW_CFG	        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x74)
+#define SMSC9118_RX_DP_CTL	(volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x78)
+#define SMSC9118_RX_FIFO_INF    (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x7C)
+#define SMSC9118_TX_FIFO_INF    (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x80)
+#define SMSC9118_PMT_CTRL       (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x84)
+#define SMSC9118_GPIO_CFG       (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x88)
+#define SMSC9118_GPT_CFG        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x8C)
+#define SMSC9118_GPT_CNT        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x90)
+#define SMSC9118_RESERVED2      (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x94)
+#define SMSC9118_ENDIAN	        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x98)
+#define SMSC9118_FREE_RUN       (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0x9C)
+#define SMSC9118_RX_DROP        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0xA0)
+#define SMSC9118_MAC_CSR_CMD    (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0xA4)
+#define SMSC9118_MAC_CSR_DATA   (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0xA8)
+#define SMSC9118_AFC_CFG        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0xAC)
+#define SMSC9118_E2P_CMD        (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0xB0)
+#define SMSC9118_E2P_DATA       (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0xB4)
+#define SMSC9118_RESERVED3      (volatile unsigned int *)(CONFIG_SMC_RV_BASE + 0xB8)
+
+
+// SMSC9118 MAC Registers       Indices
+#define SMSC9118_MAC_CR         0x1
+#define SMSC9118_MAC_ADDRH      0x2
+#define SMSC9118_MAC_ADDRL      0x3
+#define SMSC9118_MAC_HASHH      0x4
+#define SMSC9118_MAC_HASHL      0x5
+#define SMSC9118_MAC_MII_ACC    0x6
+#define SMSC9118_MAC_MII_DATA   0x7
+#define SMSC9118_MAC_FLOW       0x8
+#define SMSC9118_MAC_VLAN1      0x9
+#define SMSC9118_MAC_VLAN2      0xA
+#define SMSC9118_MAC_WUFF       0xB
+#define SMSC9118_MAC_WUCSR      0xC
+
+// SMSC9118 PHY Registers       Indices
+#define SMSC9118_PHY_BCONTROL   0x0
+#define SMSC9118_PHY_BSTATUS    0x1
+#define SMSC9118_PHY_ID1        0x2
+#define SMSC9118_PHY_ID2        0x3
+#define SMSC9118_PHY_ANEG_ADV   0x4
+#define SMSC9118_PHY_ANEG_LPA   0x5
+#define SMSC9118_PHY_ANEG_EXP   0x6
+#define SMSC9118_PHY_MCONTROL   0x17
+#define SMSC9118_PHY_MSTATUS    0x18
+#define SMSC9118_PHY_CSINDICATE 0x27
+#define SMSC9118_PHY_INTSRC     0x29
+#define SMSC9118_PHY_INTMASK    0x30
+#define SMSC9118_PHY_CS         0x31
+
+// 9118 End
+
+
+
+
+#endif  /* _SMC_RV_H_ */
diff --git a/examples/Makefile b/examples/Makefile
index dbcfa92..631034d 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -188,6 +188,15 @@ $(BIN):
 $(obj)%.bin:	$(obj)%
 		$(OBJCOPY) -O binary $< $@ 2>/dev/null
 
+# For some unknown reason a bsub job doesn't see the pre-requisites for the rule above
+# (? network writes ?, although just adding a delay rule doesn't work),
+# although running in interactive shell is OK.
+# This rule makes the overnight build work,
+# but does not build the example.....
+# ?? $(obj) ??
+$(obj)%::
+	@echo "examples/Makefile last resort rule"
+
 #########################################################################
 
 # defines $(obj).depend target
diff --git a/include/armcoremodule.h b/include/armcoremodule.h
index f1ded85..8b04796 100644
--- a/include/armcoremodule.h
+++ b/include/armcoremodule.h
@@ -72,7 +72,8 @@
 #endif
 
 /* Excalibur core module has reduced functionality */
-#ifndef	CONFIG_CM922T_XA10
+/* arm_intcm is basic				   */
+#if !defined (CONFIG_CM922T_XA10) && !defined (CONFIG_ARM_INTCM)
 #define CONFIG_CM_SPD_DETECT			/* CM supports SPD query      */
 #define OS_SPD			0x00000100	/* Address of SPD data        */
 #define CONFIG_CM_REMAP				/* CM supports remapping      */
diff --git a/include/armsupplied.h b/include/armsupplied.h
new file mode 100644
index 0000000..75196fe
--- /dev/null
+++ b/include/armsupplied.h
@@ -0,0 +1,41 @@
+/*
+ * (C) Copyright 2006
+ * ARM Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+
+#ifndef __ARMSUPPLIED_
+/* 
+ *MACROS common to all ARM supplied development boards 
+ */
+/*
+ *  Obtain board revision info from board register
+ */
+#define ARM_SUPPLIED_GET_BOARD_REV			\
+u32 get_board_rev(void){				\
+	u32 * rev_reg = (u32*)ARM_SUPPLIED_REVISION_REGISTER; \
+	return(*rev_reg);				\
+}
+#define CONFIG_REVISION_TAG
+#define __ARMSUPPLIED_
+#endif /* __ARMSUPPLIED_ */
+
diff --git a/include/asm-arm/mach-types.h b/include/asm-arm/mach-types.h
old mode 100644
new mode 100755
index 2c1e69b..f65a12a
--- a/include/asm-arm/mach-types.h
+++ b/include/asm-arm/mach-types.h
@@ -25723,7 +25723,6 @@ extern unsigned int __machine_arch_type;
 #  define machine_arch_type	MACH_TYPE_HTCVENUS
 # endif
 # define machine_is_htcvenus()	(machine_arch_type == MACH_TYPE_HTCVENUS)
-#else
 # define machine_is_htcvenus()	(0)
 #endif
 
diff --git a/include/configs/integratorap.h b/include/configs/integratorap.h
index 6ce3b4d..a8e84ba 100644
--- a/include/configs/integratorap.h
+++ b/include/configs/integratorap.h
@@ -31,12 +31,23 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 /*
+ *  Code, etc. common to all ARM supplied development boards
+ */
+#include <armsupplied.h>
+/*
+ * Board info register
+ */
+#define SC_ID  (0x11000000)
+#define ARM_SUPPLIED_REVISION_REGISTER SC_ID
+
+/*
  * High Level Configuration Options
  * (easy to change)
  */
 #define CONFIG_SYS_MEMTEST_START	0x100000
 #define CONFIG_SYS_MEMTEST_END		0x10000000
-#define CONFIG_SYS_HZ			1000
+#define CFG_HZ				1000
+#define CONFIG_SYS_HZ			CFG_HZ
 #define CONFIG_SYS_HZ_CLOCK		24000000	/* Timer 1 is clocked at 24Mhz */
 #define CONFIG_SYS_TIMERBASE		0x13000100	/* Timer1		       */
 
diff --git a/include/configs/integratorcp.h b/include/configs/integratorcp.h
index 5b4747a..8cb1c09 100644
--- a/include/configs/integratorcp.h
+++ b/include/configs/integratorcp.h
@@ -32,16 +32,29 @@
 #define __CONFIG_H
 
 /*
+ *  Code, etc. common to all ARM supplied development boards
+ */
+#include <armsupplied.h>
+/*
+ * Board info register
+ */
+#define CP_IDFIELD  (0xCB000000)
+#define ARM_SUPPLIED_REVISION_REGISTER CP_IDFIELD
+
+/*
  * High Level Configuration Options
  * (easy to change)
  */
 #define CONFIG_SYS_MEMTEST_START	0x100000
 #define CONFIG_SYS_MEMTEST_END		0x10000000
-#define CONFIG_SYS_HZ			1000
-#define CONFIG_SYS_HZ_CLOCK		1000000	/* Timer 1 is clocked at 1Mhz */
-#define CONFIG_SYS_TIMERBASE		0x13000100
-
-#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs  */
+#define CFG_HZ				1000	/* This NON CONFIGURABLE value 
+						 * is the number of timer ticks/sec 
+						 */
+#define CONFIG_SYS_HZ			CFG_HZ
+#define CONFIG_SYS_HZ_CLOCK		1000000		/* Integrator/CP Timer 1 is clocked at 1Mhz */
+#define CONFIG_SYS_TIMERBASE		0x13000100	/* Base address of Integrator/CP Timer 1 */
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs*/
 #define CONFIG_SETUP_MEMORY_TAGS	1
 #define CONFIG_MISC_INIT_R		1	/* call misc_init_r during start up */
 /*
@@ -55,7 +68,7 @@
  */
 #define CONFIG_DRIVER_SMC91111
 #define CONFIG_SMC_USE_32_BIT
-#define CONFIG_SMC91111_BASE    0xC8000000
+#define CONFIG_SMC91111_BASE	0xC8000000
 #undef CONFIG_SMC91111_EXT_PHY
 
 /*
@@ -95,19 +108,19 @@
 
 #if 0
 #define CONFIG_BOOTDELAY	2
-#define CONFIG_BOOTARGS	"root=/dev/nfs nfsroot=<IP address>:/<exported rootfs>  mem=128M ip=dhcp netdev=27,0,0xfc800000,0xfc800010,eth0 video=clcdfb:0"
+#define CONFIG_BOOTARGS	"root=/dev/nfs nfsroot=<IP address>:/<exported rootfs>	mem=128M ip=dhcp netdev=27,0,0xfc800000,0xfc800010,eth0 video=clcdfb:0"
 #define CONFIG_BOOTCOMMAND "bootp ; bootm"
 #endif
 /* The kernel command line & boot command below are for a platform flashed with afu.axf
 
-Image 666 Block  0 End Block  0 address 0x24000000 exec 0x24000000- name u-boot
-Image 667 Block  1 End Block 13 address 0x24040000 exec 0x24040000- name u-linux
+Image 666 Block	 0 End Block 00 address 0x24000000 exec 0x24000000- name u-boot
+Image 667 Block	 1 End Block 13 address 0x24040000 exec 0x24040000- name u-linux
 Image 668 Block 14 End Block 33 address 0x24380000 exec 0x24380000- name rootfs
 SIB at Block62 End Block62 address 0x24f80000
 
 */
 #define CONFIG_BOOTDELAY	2
-#define CONFIG_BOOTARGS	"root=/dev/mtdblock2 mem=128M ip=dhcp netdev=27,0,0xfc800000,0xfc800010,eth0 video=clcdfb:0 console=ttyAMA0"
+#define CONFIG_BOOTARGS	"root=/dev/mtdblock0 mem=128M ip=dhcp netdev=27,0,0xfc800000,0xfc800010,eth0 video=clcdfb:0 console=ttyAMA0 mtdparts=armflash.0:0x00540000@0x001c0000(root)"
 #define CONFIG_BOOTCOMMAND "cp 0x24080000 0x7fc0 0x100000; bootm"
 
 /*
@@ -146,52 +159,70 @@ SIB at Block62 End Block62 address 0x24f80000
  * FLASH and environment organization
 
  * Top varies according to amount fitted
- * Reserve top 4 blocks of flash
+ * Reserve top 2 blocks of flash
  * - ARM Boot Monitor
- * - Unused
- * - SIB block
  * - U-Boot environment
  *
- * Base is always 0x24000000
-
+ * - U-Boot code can be placed anywhere 
+ * above flash base & 
+ * below U-Boot environment
+ *
+ * Flash base is always 0x24000000
+ *
  */
+/*
+ * Use the CFI flash driver for ease of use
+ */
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_CFI_DRIVER
+
 #define CONFIG_SYS_FLASH_BASE		0x24000000
-#define CONFIG_SYS_MAX_FLASH_SECT	64
-#define CONFIG_SYS_MAX_FLASH_BANKS	1		/* max number of memory banks */
-#define PHYS_FLASH_SIZE		0x01000000	/* 16MB */
-#define CONFIG_SYS_FLASH_ERASE_TOUT	(2*CONFIG_SYS_HZ)	/* Timeout for Flash Erase */
-#define CONFIG_SYS_FLASH_WRITE_TOUT	(2*CONFIG_SYS_HZ)	/* Timeout for Flash Write */
+#define FLASH_SECTOR_SIZE	0x00040000	/* 256KB */
 
-#define CONFIG_SYS_MONITOR_LEN		0x00100000
-#define CONFIG_ENV_IS_IN_FLASH	1
+#ifdef ARM_1176_CP_RT
+# define CONFIG_SYS_MAX_FLASH_BANKS	2		/* max number of memory banks */
+# define PHYS_FLASH_SIZE 	0x02000000	/* 32MB */
+#else
+# define CONFIG_SYS_MAX_FLASH_BANKS	1		/* max number of memory banks */
+# define PHYS_FLASH_SIZE 	0x01000000	/* 16MBMay be:: 0x02000000 32MB, 0x04000000 64 MB */
+#endif
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2*CFG_HZ)	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(2*CFG_HZ)	/* Timeout for Flash Write */
 
 /*
- * Move up the U-Boot & monitor area if more flash is fitted.
+ * Move up the U-Boot environment & ARM Boot Monitor area if more flash is fitted.
+ * The ARM boot monitor is shipped in the top sector of flash.
  * If this U-Boot is to be run on Integrators with varying flash sizes,
  * drivers/mtd/cfi_flash.c::flash_init() can read the Integrator CP_FLASHPROG
  * register and dynamically assign CONFIG_ENV_ADDR & CONFIG_SYS_MONITOR_BASE
  * - CONFIG_SYS_MONITOR_BASE is set to indicate that the environment is not
  * embedded in the boot monitor(s) area
  */
-#if ( PHYS_FLASH_SIZE == 0x04000000 )
+// #define CONFIG_SYS_MONITOR_LEN	U-Boot code size is variable	
+// #define CONFIG_SYS_MONITOR_BASE	U-Boot code is relocatable in flash
+//					- only need be fixed at FLASH_BASE if switches
+//					are set for direct boot into U-Boot, rather 
+//					than boot into ARM Boot Monitor
 
-#define CONFIG_ENV_ADDR		0x27F00000
-#define CONFIG_SYS_MONITOR_BASE	0x27F40000
+#define CONFIG_ENV_IS_IN_FLASH	1
 
+#if ( PHYS_FLASH_SIZE == 0x04000000 )
+# define FLASH_TOP 0x28000000
+# define CONFIG_SYS_MAX_FLASH_SECT	256
 #elif (PHYS_FLASH_SIZE == 0x02000000 )
-
-#define CONFIG_ENV_ADDR		0x25F00000
-#define CONFIG_SYS_MONITOR_BASE	0x25F40000
-
+# define FLASH_TOP 0x26000000
+# define CONFIG_SYS_MAX_FLASH_SECT	128
 #else
+# define FLASH_TOP 0x25000000
+# define CONFIG_SYS_MAX_FLASH_SECT	 64
+#endif /* Flash size */
 
-#define CONFIG_ENV_ADDR		0x24F00000
-#define CONFIG_SYS_MONITOR_BASE	0x27F40000
-
-#endif
+#define ARM_BM_START		(FLASH_TOP - FLASH_SECTOR_SIZE)		/* One sector for ARM BM */
+#define CONFIG_ENV_ADDR		(ARM_BM_START - CONFIG_ENV_SECT_SIZE) 	/* One sector for environment*/
+#define CONFIG_ENV_OFFSET		(CONFIG_ENV_ADDR - CONFIG_SYS_FLASH_BASE)
+#define CONFIG_ENV_SECT_SIZE	FLASH_SECTOR_SIZE
+#define CONFIG_ENV_SIZE		8192			/* 8KB */
 
-#define CONFIG_ENV_SECT_SIZE	0x40000		/* 256KB */
-#define CONFIG_ENV_SIZE		8192		/* 8KB */
 /*-----------------------------------------------------------------------
  * CP control registers
  */
@@ -248,7 +279,7 @@ SIB at Block62 End Block62 address 0x24f80000
  * However it may be needed if Integrator/CP switch S2-1
  * is set OFF to boot direct into U-Boot.
  * In that case comment out the line below.
-#undef	CONFIG_CM_INIT
  */
+#undef	CONFIG_CM_INIT
 
 #endif /* __CONFIG_H */
diff --git a/include/configs/realview_eb.h b/include/configs/realview_eb.h
new file mode 100644
index 0000000..4581792
--- /dev/null
+++ b/include/configs/realview_eb.h
@@ -0,0 +1,273 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments.
+ * Kshitij Gupta <kshitij@ti.com>
+ * Configuation settings for the TI OMAP Innovator board.
+ *
+ * (C) Copyright 2004
+ * ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ * Configuration for Versatile PB.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ *  Code, etc. common to all ARM supplied development boards
+ */
+#include <armsupplied.h>
+/*
+ * Board info register
+ */
+#define SYS_ID  (0x10000000)
+#define ARM_SUPPLIED_REVISION_REGISTER SYS_ID
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARCH_REALVIEW_EB   1
+
+#define CONFIG_SYS_MEMTEST_START	0x100000
+#define CONFIG_SYS_MEMTEST_END		0x10000000
+#define CFG_HZ	       			(1000)
+#define CONFIG_SYS_HZ			CFG_HZ
+#define CONFIG_SYS_HZ_CLOCK		1000000		/* Timers clocked at 1Mhz */
+#define CONFIG_SYS_TIMERBASE		0x10011000	/* Timer 0 and 1 base	*/
+#define CONFIG_SYS_TIMER_RELOAD	0xFFFFFFFF
+#define TIMER_LOAD_VAL		CONFIG_SYS_TIMER_RELOAD
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_MISC_INIT_R		1	/* call misc_init_r during start up */
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN	(CONFIG_ENV_SIZE + 128*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#define REALVIEW_EB_SCTL_BASE	0x10001000	/* System controller */
+/*
+ * System controller (SP810) register offsets & bit assignment
+ */
+#define SP804_REFCLK	0
+#define SP804_TIMCLK	1
+#define SP804_TIMER0_EnSel	15
+#define SP804_TIMER1_EnSel	17
+#define SP804_TIMER2_EnSel	19
+#define SP804_TIMER3_EnSel	21
+#define SP810_OS_SCSYSSTAT	(0x00000004)	/* System status register */
+#define REALVIEW_EB_SYS_FLASH_OFFSET	(0x4C)
+#define REALVIEW_EB_FLASHCTRL	(REALVIEW_EB_SCTL_BASE + REALVIEW_EB_SYS_FLASH_OFFSET)
+#define REALVIEW_EB_FLASHPROG_FLVPPEN	(1 << 0)   /* Enable writing to flash */
+
+/* 
+ * Only one ethernet driver is incorporated (U-Boot policy is to reduce size)
+ * Because different revisions of RealView EB have different ethernet chips
+ * we use a driver containing merged smc91111,c && smc9118 code
+ * which autodetects the chip
+ *
+ * Rev A - C	: LAN91C111
+ * Rev D	: LAN9118
+ */
+#define CONFIG_DRIVER_SMC_RV
+#undef  CONFIG_DRIVER_SMC91111
+#undef  CONFIG_DRIVER_SMC9118
+
+
+#define CONFIG_SMC_RV_BASE	0x4E000000
+
+
+
+
+#define CONFIG_SMC91111_BASE	CONFIG_SMC_RV_BASE
+
+/*
+ * NS16550 Configuration
+ */
+#define CONFIG_PL011_SERIAL
+#define CONFIG_PL011_CLOCK	24000000
+#define CONFIG_PL01x_PORTS	{ (void *)CONFIG_SYS_SERIAL0, (void *)CONFIG_SYS_SERIAL1 }
+#define CONFIG_CONS_INDEX	0
+
+#define CONFIG_BAUDRATE		38400
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+
+#define CONFIG_SYS_SERIAL0		0x10009000
+#define CONFIG_SYS_SERIAL1		0x1000A000
+
+
+
+
+
+/*
+ * Command line configuration.
+ */
+#define CONFIG_CMD_BDI
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_IMI
+#define CONFIG_CMD_MEMORY
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_MASK	CONFIG_BOOTP_DEFAULT
+
+#define CONFIG_BOOTDELAY	2
+/* #define CONFIG_BOOTARGS "root=/dev/nfs mem=128M ip=dhcp netdev=25,0,0xf1010000,0xf1010010,eth0" */
+/*
+The kernel command line & boot command below are for a VersatilePB board flashed using Boot_Monitor.axf:-
+0x34000000  u-boot
+0x34040000  u-linux
+0x34380000  mtdroot
+
+Name: mtdroot
+Flash Address: 0x34380000
+Load Address : 0x00000000
+Entry Point  : 0x00000000
+Size         : 5012K
+Blocks Used  : 20
+
+and a VersatileAB board flashed using Boot_monitor.axf:-
+
+0x34000000  u-boot
+0x34020000  EMPTY_IMAGE
+0x34040000  u-linux
+0x34380000  mtdroot
+
+Name: mtdroot
+Flash Address: 0x34380000
+Load Address : 0x00000000
+Entry Point  : 0x00000000
+Size         : 5012K
+Blocks Used  : 40
+
+i.e despite the difference in flash block size the same command may be used.
+
+*/
+
+#define CONFIG_BOOTARGS "root=/dev/mtdblock0 mtdparts=armflash.0:7268k@0x02800000(cramfs) ip=dhcp mem=128M console=ttyAMA0 video=vc:1-2clcdfb:"
+#define CONFIG_BOOTCOMMAND "cp 0x42000000 0x7fc0 0x00200000 ; bootm"
+
+/*
+ * Static configuration when assigning fixed address
+ */
+/*#define CONFIG_NETMASK	255.255.255.0	/--* talk on MY local net */
+/*#define CONFIG_IPADDR		xx.xx.xx.xx	/--* static IP I currently own */
+/*#define CONFIG_SERVERIP	xx.xx.xx.xx	/--* current IP of my dev pc */
+#define CONFIG_BOOTFILE			"/tftpboot/uImage" /* file to load */
+
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP	/* undef to save memory		 */
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size	*/
+/* Monitor Command Prompt   */
+#define CONFIG_SYS_PROMPT	"RealView_EB # "
+#define CONFIG_IDENT_STRING "\n\n***  Auto-detects ethernet chip ***\n\n"
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args	 */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size		*/
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#define CONFIG_SYS_LOAD_ADDR	0x7fc0	/* default load address */
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS		1	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		       	0x00000000	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE		0x08000000	/* 128 MB */
+#define PHYS_FLASH_SIZE         (0x04000000)	/* 64MB */
+
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+/*
+ *  Use the CFI flash driver for ease of use
+ */
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_ENV_IS_IN_FLASH	1		/* env in flash */
+
+#define CONFIG_SYS_FLASH_BASE		0x40000000
+#define CONFIG_SYS_MAX_FLASH_BANKS	(1)		/* max number of memory banks */
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2*CFG_HZ)	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(2*CFG_HZ)	/* Timeout for Flash Write */
+
+#define CONFIG_SYS_MAX_FLASH_SECT	(259)		/* The maximum number of sectors we may need to hold data about */
+						/* 255 0x40000 sectors plus first or last sector may have 4 erase regions == 259 */
+#define FLASH_MAX_SECTOR_SIZE	(0x00040000)	/* 256 KB sectors */
+#define FLASH_MIN_SECTOR_SIZE	(0x00010000)	/*  64 KB sectors */
+
+/* Room required on the stack for the environment data */
+#define CONFIG_ENV_SIZE         8192
+/* 
+ * Since we don't know which end has the small erase blocks 
+ * or indeed whether they are present
+ * we use the penultimate full sector location
+ * for the environment - we save a full sector even tho 
+ * the real env size CONFIG_ENV_SIZE is probably less
+ * Maintain the distinction since we want to make stack size as small as possible 
+ */
+/* Amount of flash used for environment */
+#define CONFIG_ENV_SECT_SIZE	FLASH_MAX_SECTOR_SIZE 
+/* 
+ * Top of flash must NOT be defined using sectors
+ * Board variants may have differing flash components
+ */ 
+#define FLASH_TOP	(CONFIG_SYS_FLASH_BASE + PHYS_FLASH_SIZE)
+#define CONFIG_ENV_ADDR	(FLASH_TOP - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_OFFSET	(CONFIG_ENV_ADDR - CONFIG_SYS_FLASH_BASE)
+
+#define CONFIG_SYS_FLASH_PROTECTION	/* The devices have real protection */
+#define CONFIG_SYS_FLASH_EMPTY_INFO	/* flinfo indicates empty blocks */
+
+#endif							/* __CONFIG_H */
diff --git a/include/configs/realview_pb.h b/include/configs/realview_pb.h
new file mode 100644
index 0000000..6ccfc06
--- /dev/null
+++ b/include/configs/realview_pb.h
@@ -0,0 +1,286 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments.
+ * Kshitij Gupta <kshitij@ti.com>
+ * Configuation settings for the TI OMAP Innovator board.
+ *
+ * (C) Copyright 2004
+ * ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ * Configuration for Versatile PB.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ *  Code, etc. common to all ARM supplied development boards
+ */
+#include <armsupplied.h>
+/*
+ * Board info register
+ */
+#define SYS_ID  (0x10000000)
+#define ARM_SUPPLIED_REVISION_REGISTER SYS_ID
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARCH_REALVIEW_PB   1
+
+#define CONFIG_SYS_MEMTEST_START	0x100000
+#define CONFIG_SYS_MEMTEST_END		0x10000000
+#define CFG_HZ	       			(1000)
+#define CONFIG_SYS_HZ			CFG_HZ
+#define CONFIG_SYS_HZ_CLOCK		1000000		/* Timers clocked at 1Mhz */
+#define CONFIG_SYS_TIMERBASE		0x10011000	/* Timer 0 and 1 base	*/
+#define CONFIG_SYS_TIMER_RELOAD	0xFFFFFFFF
+#define TIMER_LOAD_VAL		CONFIG_SYS_TIMER_RELOAD
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_MISC_INIT_R		1	/* call misc_init_r during start up */
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN	(CONFIG_ENV_SIZE + 128*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#define REALVIEW_PB_SCTL_BASE	0x10001000	/* SP810 System controller */
+/*
+ * System controller (SP804) register offsets & bit assignment
+ */
+#define SP804_REFCLK	0
+#define SP804_TIMCLK	1
+#define SP804_TIMER0_EnSel	15
+#define SP804_TIMER1_EnSel	17
+#define SP804_TIMER2_EnSel	19
+#define SP804_TIMER3_EnSel	21
+#define SP810_OS_SCSYSSTAT	(0x00000004)	/* System status register */
+#define REALVIEW_PB_SYS_FLASH_OFFSET	(0x4C)
+#define REALVIEW_PB_FLASHCTRL	(REALVIEW_PB_SCTL_BASE + REALVIEW_PB_SYS_FLASH_OFFSET)
+#define REALVIEW_PB_FLASHPROG_FLVPPEN	(1 << 0)   /* Enable writing to flash */
+
+/* 
+ * Only one ethernet driver is incorporated (U-Boot policy is to reduce size)
+ * Because different revisions of RealView PB have different ethernet chips
+ * we use a driver containing merged smc91111,c && smc9118 code
+ * which autodetects the chip
+ *
+ * Rev A - C	: LAN91C111
+ * Rev D	: LAN9118
+ */
+#define CONFIG_DRIVER_SMC_RV
+#undef  CONFIG_DRIVER_SMC91111
+#undef  CONFIG_DRIVER_SMC9118
+
+#ifndef CONFIG_REALVIEW_PB1176
+# define CONFIG_SMC_RV_BASE	0x4E000000
+#else
+# define CONFIG_SMC_RV_BASE	0x3A000000
+#endif
+
+#define CONFIG_SMC91111_BASE	CONFIG_SMC_RV_BASE
+
+/*
+ * NS16550 Configuration
+ */
+#define CONFIG_PL011_SERIAL
+#define CONFIG_PL011_CLOCK	24000000
+#define CONFIG_PL01x_PORTS	{ (void *)CONFIG_SYS_SERIAL0, (void *)CONFIG_SYS_SERIAL1 }
+#define CONFIG_CONS_INDEX	0
+
+#define CONFIG_BAUDRATE		38400
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#ifndef CONFIG_REALVIEW_PB1176
+# define CONFIG_SYS_SERIAL0		0x10009000
+# define CONFIG_SYS_SERIAL1		0x1000A000
+#else
+# define CONFIG_SYS_SERIAL0		0x1010C000
+# define CONFIG_SYS_SERIAL1		0x1010D000
+#endif
+
+/*
+ * Command line configuration.
+ */
+#define CONFIG_CMD_BDI
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_IMI
+#define CONFIG_CMD_MEMORY
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_MASK	CONFIG_BOOTP_DEFAULT
+
+#define CONFIG_BOOTDELAY	2
+/* #define CONFIG_BOOTARGS "root=/dev/nfs mem=128M ip=dhcp netdev=25,0,0xf1010000,0xf1010010,eth0" */
+/*
+The kernel command line & boot command below are for a VersatilePB board flashed using Boot_Monitor.axf:-
+0x34000000  u-boot
+0x34040000  u-linux
+0x34380000  mtdroot
+
+Name: mtdroot
+Flash Address: 0x34380000
+Load Address : 0x00000000
+Entry Point  : 0x00000000
+Size         : 5012K
+Blocks Used  : 20
+
+and a VersatileAB board flashed using Boot_monitor.axf:-
+
+0x34000000  u-boot
+0x34020000  EMPTY_IMAGE
+0x34040000  u-linux
+0x34380000  mtdroot
+
+Name: mtdroot
+Flash Address: 0x34380000
+Load Address : 0x00000000
+Entry Point  : 0x00000000
+Size         : 5012K
+Blocks Used  : 40
+
+i.e despite the difference in flash block size the same command may be used.
+
+*/
+
+#ifndef CONFIG_REALVIEW_PB1176
+# define CONFIG_BOOTCOMMAND "cp 0x42000000 0x7fc0 0x00200000 ; bootm"
+#else
+# define CONFIG_BOOTCOMMAND "cp 0x32000000 0x7fc0 0x00200000 ; bootm"
+#endif
+
+# define CONFIG_BOOTARGS "root=/dev/mtdblock0 mtdparts=armflash.0:7268k@0x02800000(cramfs) ip=dhcp mem=128M console=ttyAMA0 video=vc:1-2clcdfb:"
+/*
+ * Static configuration when assigning fixed address
+ */
+/*#define CONFIG_NETMASK	255.255.255.0	/--* talk on MY local net */
+/*#define CONFIG_IPADDR		xx.xx.xx.xx	/--* static IP I currently own */
+/*#define CONFIG_SERVERIP	xx.xx.xx.xx	/--* current IP of my dev pc */
+#define CONFIG_BOOTFILE			"/tftpboot/uImage" /* file to load */
+
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP	/* undef to save memory		 */
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size	*/
+/* Monitor Command Prompt   */
+#define CONFIG_SYS_PROMPT	"RealView_PB # "
+#define CONFIG_IDENT_STRING "\n\n***  Auto-detects ethernet chip ***\n\n"
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args	 */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size		*/
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#define CONFIG_SYS_LOAD_ADDR	0x7fc0	/* default load address */
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS		1	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		       	0x00000000	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE		0x08000000	/* 128 MB */
+#define PHYS_FLASH_SIZE         (0x04000000)	/* 64MB */
+
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+/*
+ *  Use the CFI flash driver for ease of use
+ */
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_ENV_IS_IN_FLASH	1		/* env in flash */
+
+#ifndef CONFIG_REALVIEW_PB1176
+# define CONFIG_SYS_FLASH_BASE		0x40000000
+#else
+# define CONFIG_SYS_FLASH_BASE		0x30000000
+#endif
+#define CONFIG_SYS_MAX_FLASH_BANKS	(1)		/* max number of memory banks */
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2*CFG_HZ)	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(2*CFG_HZ)	/* Timeout for Flash Write */
+
+#define CONFIG_SYS_MAX_FLASH_SECT	(259)		/* The maximum number of sectors we may need to hold data about */
+						/* 255 0x40000 sectors plus first or last sector may have 4 erase regions == 259 */
+						/* Has room for pre-production boards which had 256 * 0x40000 sectors */
+#define FLASH_MAX_SECTOR_SIZE	(0x00040000)	/* 256 KB sectors */
+#define FLASH_MIN_SECTOR_SIZE	(0x00010000)	/*  64 KB sectors */
+
+/* Room required on the stack for the environment data */
+#define CONFIG_ENV_SIZE         8192
+/* 
+ * Since we don't know which end has the small erase blocks 
+ * or indeed whether they are present
+ * we use the penultimate full sector location
+ * for the environment - we save a full sector even tho 
+ * the real env size CONFIG_ENV_SIZE is probably less
+ * Maintain the distinction since we want to make stack size as small as possible 
+ */
+/* Amount of flash used for environment */
+#define CONFIG_ENV_SECT_SIZE	FLASH_MAX_SECTOR_SIZE 
+// #define CONFIG_SYS_MONITOR_LEN	       (4 * FLASH_SECTOR_SIZE)
+// #define ARM_BM_START		(CONFIG_SYS_FLASH_BASE)
+//
+/* 
+ * Top of flash must NOT be defined using sectors
+ * Board variants may have differing flash components
+ */ 
+#define FLASH_TOP		(CONFIG_SYS_FLASH_BASE + PHYS_FLASH_SIZE)
+
+#define CONFIG_ENV_ADDR		(FLASH_TOP - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_OFFSET	(CONFIG_ENV_ADDR - CONFIG_SYS_FLASH_BASE)
+
+#define CONFIG_SYS_FLASH_PROTECTION	/* The devices have real protection */
+#define CONFIG_SYS_FLASH_EMPTY_INFO	/* flinfo indicates empty blocks */
+
+#endif							/* __CONFIG_H */
diff --git a/include/configs/versatile.h b/include/configs/versatile.h
old mode 100644
new mode 100755
index 852becb..6c74c14
--- a/include/configs/versatile.h
+++ b/include/configs/versatile.h
@@ -32,27 +32,44 @@
 #define __CONFIG_H
 
 /*
+ *  Code, etc. common to all ARM supplied development boards
+ */
+#include <armsupplied.h>
+/*
+ * Board info register
+ */
+#define SYS_ID  (0x10000000)
+#define ARM_SUPPLIED_REVISION_REGISTER SYS_ID
+
+/*
  * High Level Configuration Options
  * (easy to change)
  */
-#define CONFIG_ARM926EJS	1	/* This is an arm926ejs CPU core  */
+#define CONFIG_ARM926EJS	1	/* This is an arm926ejs CPU core*/
 #define CONFIG_VERSATILE	1	/* in Versatile Platform Board	*/
-#define CONFIG_ARCH_VERSATILE   1	/* Specifically, a Versatile	*/
+#define CONFIG_ARCH_VERSATILE	1	/* Specifically, a Versatile	*/
+
+#ifndef CONFIG_ARCH_VERSATILE_AB	/* AB				*/
 
+#define CONFIG_ARCH_VERSATILE_PB	/* Versatile PB is default	*/
 
-#define CONFIG_SYS_MEMTEST_START       0x100000
-#define CONFIG_SYS_MEMTEST_END         0x10000000
-#define CONFIG_SYS_HZ                  (1000000 / 256)
-#define CONFIG_SYS_TIMERBASE           0x101E2000	/* Timer 0 and 1 base */
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x100000
+#define CONFIG_SYS_MEMTEST_END		0x10000000
+#define CFG_HZ				(1000)
+#define CONFIG_SYS_HZ			CFG_HZ
+#define CONFIG_SYS_TIMERBASE		0x101E2000	/* SP804 Timer 0 and 1 base */
 
-#define CONFIG_SYS_TIMER_INTERVAL	10000
-#define CONFIG_SYS_TIMER_RELOAD	(CONFIG_SYS_TIMER_INTERVAL >> 4)	/* Divide by 16 */
-#define CONFIG_SYS_TIMER_CTRL          0x84				/* Enable, Clock / 16 */
+#define CONFIG_SYS_TIMER_RELOAD	0xFFFFFFFF
+#define READ_TIMER		(*(volatile ulong *)(CONFIG_SYS_TIMERBASE+4))
+#define TIMER_LOAD_VAL		CONFIG_SYS_TIMER_RELOAD
 
 /*
  * control registers
  */
-#define VERSATILE_SCTL_BASE            0x101E0000	/* System controller */
+#define VERSATILE_SCTL_BASE	0x101E0000	/* System controller */
+#define SP810_OS_SCSYSSTAT	(0x00000004)	/* System status register */
 
 /*
  * System controller bit assignment
@@ -91,38 +108,69 @@
 #define CONFIG_PL01x_PORTS	{ (void *)CONFIG_SYS_SERIAL0, (void *)CONFIG_SYS_SERIAL1 }
 #define CONFIG_CONS_INDEX	0
 
-#define CONFIG_BAUDRATE         38400
-#define CONFIG_SYS_BAUDRATE_TABLE      { 9600, 19200, 38400, 57600, 115200 }
+#define CONFIG_BAUDRATE		38400
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
 #define CONFIG_SYS_SERIAL0		0x101F1000
 #define CONFIG_SYS_SERIAL1		0x101F2000
 
-
 /*
  * Command line configuration.
  */
-
+#define CONFIG_CMD_BDI
 #define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
+#define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_NET
 #define CONFIG_CMD_PING
-#define CONFIG_CMD_BDI
-#define CONFIG_CMD_MEMORY
-#define CONFIG_CMD_FLASH
 #define CONFIG_CMD_SAVEENV
 
-
 /*
  * BOOTP options
  */
-#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_BOOTPATH
 #define CONFIG_BOOTP_GATEWAY
 #define CONFIG_BOOTP_HOSTNAME
-#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_SUBNETMASK
 
 
 #define CONFIG_BOOTDELAY	2
-#define CONFIG_BOOTARGS "root=/dev/nfs mem=128M ip=dhcp netdev=25,0,0xf1010000,0xf1010010,eth0"
-/*#define CONFIG_BOOTCOMMAND "bootp ; bootm" */
+
+/* #define CONFIG_BOOTARGS "root=/dev/nfs mem=128M ip=dhcp netdev=25,0,0xf1010000,0xf1010010,eth0" */
+/*
+The kernel command line & boot command below are for a VersatilePB board flashed using Boot_Monitor.axf:-
+0x34000000	u-boot
+0x34040000	u-linux
+0x34380000	mtdroot
+
+Name: mtdroot
+Flash Address: 0x34380000
+Load Address : 0x00000000
+Entry Point	: 0x00000000
+Size				 : 5012K
+Blocks Used	: 20
+
+and a VersatileAB board flashed using Boot_monitor.axf:-
+
+0x34000000	u-boot
+0x34020000	EMPTY_IMAGE
+0x34040000	u-linux
+0x34380000	mtdroot
+
+Name: mtdroot
+Flash Address: 0x34380000
+Load Address : 0x00000000
+Entry Point	: 0x00000000
+Size				 : 5012K
+Blocks Used	: 40
+
+i.e despite the difference in flash block size the same command may be used.
+
+*/
+
+#define CONFIG_BOOTARGS "root=/dev/mtdblock0 mtdparts=armflash.0:7268k@0x02680000(cramfs) ip=dhcp mem=128M console=ttyAMA0 video=vc:1-2clcdfb:"
+#define CONFIG_BOOTCOMMAND "cp 0x36000000 0x7fc0 0x00200000 ; bootm"
 
 /*
  * Static configuration when assigning fixed address
@@ -130,19 +178,24 @@
 /*#define CONFIG_NETMASK	255.255.255.0	/--* talk on MY local net */
 /*#define CONFIG_IPADDR		xx.xx.xx.xx	/--* static IP I currently own */
 /*#define CONFIG_SERVERIP	xx.xx.xx.xx	/--* current IP of my dev pc */
-#define CONFIG_BOOTFILE	    "/tftpboot/uImage" /* file to load */
+#define CONFIG_BOOTFILE		"/tftpboot/uImage" /* file to load */
 
 
 /*
  * Miscellaneous configurable options
  */
-#define CONFIG_SYS_LONGHELP	/* undef to save memory     */
-#define CONFIG_SYS_PROMPT	"Versatile # "	/* Monitor Command Prompt   */
-#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size  */
+#define CONFIG_SYS_LONGHELP	/* undef to save memory		 */
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size	*/
+/* Monitor Command Prompt	 */
+#ifdef CONFIG_ARCH_VERSATILE_AB
+# define CONFIG_SYS_PROMPT	"VersatileAB # "
+#else
+# define CONFIG_SYS_PROMPT	"VersatilePB # "
+#endif
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
-#define CONFIG_SYS_MAXARGS	16		/* max number of command args   */
-#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size    */
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size */
 
 #undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
 #define CONFIG_SYS_LOAD_ADDR	0x7fc0	/* default load address */
@@ -161,34 +214,73 @@
 /*-----------------------------------------------------------------------
  * Physical Memory Map
  */
-#define CONFIG_NR_DRAM_BANKS    1	/* we have 1 bank of DRAM */
-#define PHYS_SDRAM_1            0x00000000	/* SDRAM Bank #1 */
-#define PHYS_SDRAM_1_SIZE       0x08000000	/* 128 MB */
-
-#define CONFIG_SYS_FLASH_BASE          0x34000000
+#define CONFIG_NR_DRAM_BANKS	1	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x00000000	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x08000000	/* 128 MB */
+#define PHYS_FLASH_SIZE		0x04000000	/* 64MB */
 
 /*-----------------------------------------------------------------------
  * FLASH and environment organization
  */
+/*
+ * Use the CFI flash driver for ease of use
+ */
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_ENV_IS_IN_FLASH	1
+/* 
+ *	System control register
+ */
+#define VERSATILE_SYS_BASE		0x10000000
+#define VERSATILE_SYS_FLASH_OFFSET	0x4C
+#define VERSATILE_FLASHCTRL		(VERSATILE_SYS_BASE + VERSATILE_SYS_FLASH_OFFSET)
+#define VERSATILE_FLASHPROG_FLVPPEN	(1 << 0)	/* Enable writing to flash */
 
-#define VERSATILE_SYS_BASE                    0x10000000
-#define VERSATILE_SYS_FLASH_OFFSET            0x4C
-#define VERSATILE_FLASHCTRL		      (VERSATILE_SYS_BASE + VERSATILE_SYS_FLASH_OFFSET)
-#define VERSATILE_FLASHPROG_FLVPPEN	      (1 << 0)	/* Enable writing to flash */
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2*CFG_HZ)	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(2*CFG_HZ)	/* Timeout for Flash Write */
 
+// #define PHYS_FLASH_1		(CONFIG_SYS_FLASH_BASE)
+
+/*
+ * Note that CONFIG_SYS_MAX_FLASH_SECT allows for a parameter block 
+ * i.e. the bottom "sector" (bottom boot), or top "sector" 
+ *      (top boot), is a seperate erase region divided into 
+ *      4 (equal) smaller sectors. This, notionally, allows
+ *      quicker erase/rewrire of the most frequently changed
+ *      area......
+ *      CONFIG_SYS_MAX_FLASH_SECT is padded up to a multiple of 4
+ */
+
+#ifdef CONFIG_ARCH_VERSATILE_AB	/* AB				*/
+# define FLASH_SECTOR_SIZE	0x00020000	/* 128 KB sectors */
+# define QUANTUM		(2 * FLASH_SECTOR_SIZE)
+#define CONFIG_SYS_MAX_FLASH_SECT	(520)
+#endif
+
+#ifdef CONFIG_ARCH_VERSATILE_PB	/* Versatile PB is default	*/
+# define FLASH_SECTOR_SIZE	0x00040000	/* 256 KB sectors */
+# define QUANTUM		FLASH_SECTOR_SIZE
+#define CONFIG_SYS_MAX_FLASH_SECT	(260)
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		0x34000000
 #define CONFIG_SYS_MAX_FLASH_BANKS	1		/* max number of memory banks */
-#define PHYS_FLASH_SIZE         0x34000000	/* 64MB */
-/* timeout values are in ticks */
-#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ)	/* Timeout for Flash Erase */
-#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ)	/* Timeout for Flash Write */
-#define CONFIG_SYS_MAX_FLASH_SECT	(256)
 
-#define PHYS_FLASH_1		(CONFIG_SYS_FLASH_BASE)
+#define CONFIG_ENV_SECT_SIZE	QUANTUM
+#define CONFIG_SYS_MONITOR_LEN	(4 * QUANTUM)
+
+/* The ARM Boot Monitor is shipped in the lowest sector of flash
+ * These values place U-Boot & its environment at the top of flash */
+#define ARM_BM_START		(CONFIG_SYS_FLASH_BASE)       
+
+#define FLASH_TOP		(CONFIG_SYS_FLASH_BASE + PHYS_FLASH_SIZE)
+#define CONFIG_ENV_SIZE            8192	
+#define CONFIG_ENV_ADDR            (FLASH_TOP - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_OFFSET		(CONFIG_ENV_ADDR - CONFIG_SYS_FLASH_BASE)          
+#define CONFIG_SYS_MONITOR_BASE	(CONFIG_ENV_ADDR - CONFIG_SYS_MONITOR_LEN)
 
-#define CONFIG_ENV_IS_IN_FLASH     1               /* env in flash instead of CONFIG_ENV_IS_NOWHERE */
-#define CONFIG_ENV_SECT_SIZE       0x00020000      /* 256 KB sectors (x2) */
-#define CONFIG_ENV_SIZE            0x10000         /* Total Size of Environment Sector */
-#define CONFIG_ENV_OFFSET          0x01f00000      /* environment starts here  */
-#define CONFIG_ENV_ADDR            (CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET)
+#define CONFIG_SYS_FLASH_PROTECTION	/* The devices have real protection */
+#define CONFIG_SYS_FLASH_EMPTY_INFO	/* flinfo indicates empty blocks */
 
-#endif							/* __CONFIG_H */
+#endif	/* __CONFIG_H */
diff --git a/lib_arm/Makefile b/lib_arm/Makefile
index c8795b2..2f03b44 100644
--- a/lib_arm/Makefile
+++ b/lib_arm/Makefile
@@ -31,6 +31,7 @@ SOBJS-y	+= _divsi3.o
 SOBJS-y	+= _modsi3.o
 SOBJS-y	+= _udivsi3.o
 SOBJS-y	+= _umodsi3.o
+SOBJS-y	+= div64.o
 
 COBJS-y	+= board.o
 COBJS-y	+= bootm.o
diff --git a/lib_arm/board.c b/lib_arm/board.c
index 09eaaf2..bc62d91 100644
--- a/lib_arm/board.c
+++ b/lib_arm/board.c
@@ -211,6 +211,11 @@ static void display_flash_config (ulong size)
 {
 	puts ("Flash: ");
 	print_size (size, "\n");
+#ifdef CONFIG_ENV_IS_IN_FLASH
+# ifdef CONFIG_ENV_ADDR
+	gd->bd->bi_env = (struct environment_s *)CONFIG_ENV_ADDR;
+# endif
+#endif
 }
 #endif /* CONFIG_SYS_NO_FLASH */
 
diff --git a/lib_arm/bootm.c b/lib_arm/bootm.c
index 7dbde7d..7586515 100644
--- a/lib_arm/bootm.c
+++ b/lib_arm/bootm.c
@@ -90,6 +90,17 @@ int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
     defined (CONFIG_REVISION_TAG) || \
     defined (CONFIG_LCD) || \
     defined (CONFIG_VFD)
+
+	/*
+	 * Allows kernel to be loaded other than at 0x00000000
+	 */
+	{
+		int tmp = bd->bi_boot_params;
+		bd->bi_boot_params = (images->ep & 0xF0000000) + 0x100;
+		if(tmp != bd->bi_boot_params)
+			printf("ARM internal:: Moved kernel boot params from 0x%08x to 0x%08x to match image header entry point 0x%08x\n", tmp, (int)bd->bi_boot_params, (int)images->ep);
+	}
+
 	setup_start_tag (bd);
 #ifdef CONFIG_SERIAL_TAG
 	setup_serial_tag (&params);
@@ -142,7 +153,6 @@ int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
 static void setup_start_tag (bd_t *bd)
 {
 	params = (struct tag *) bd->bi_boot_params;
-
 	params->hdr.tag = ATAG_CORE;
 	params->hdr.size = tag_size (tag_core);
 
diff --git a/lib_arm/div64.S b/lib_arm/div64.S
new file mode 100644
index 0000000..bc6dc0c
--- /dev/null
+++ b/lib_arm/div64.S
@@ -0,0 +1,201 @@
+/*
+ *  linux/arch/arm/lib/div64.S
+ *
+ *  Optimized computation of 64-bit dividend / 32-bit divisor
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Oct 5, 2003
+ *  Copyright:	Monta Vista Software, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+// PMP From linux kernel code 
+// #include <linux/linkage.h>
+
+#ifdef __ARMEB__
+#define xh r0
+#define xl r1
+#define yh r2
+#define yl r3
+#else
+#define xl r0
+#define xh r1
+#define yl r2
+#define yh r3
+#endif
+
+/*
+ * __do_div64: perform a division with 64-bit dividend and 32-bit divisor.
+ *
+ * Note: Calling convention is totally non standard for optimal code.
+ *       This is meant to be used by do_div() from include/asm/div64.h only.
+ *
+ * Input parameters:
+ * 	xh-xl	= dividend (clobbered)
+ * 	r4	= divisor (preserved)
+ *
+ * Output values:
+ * 	yh-yl	= result
+ * 	xh	= remainder
+ *
+ * Clobbered regs: xl, ip
+ */
+
+.globl __do_div64
+__do_div64:
+
+	@ Test for easy paths first.
+	subs	ip, r4, #1
+	bls	9f			@ divisor is 0 or 1
+	tst	ip, r4
+	beq	8f			@ divisor is power of 2
+
+	@ See if we need to handle upper 32-bit result.
+	cmp	xh, r4
+	mov	yh, #0
+	blo	3f
+
+	@ Align divisor with upper part of dividend.
+	@ The aligned divisor is stored in yl preserving the original.
+	@ The bit position is stored in ip.
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	yl, r4
+	clz	ip, xh
+	sub	yl, yl, ip
+	mov	ip, #1
+	mov	ip, ip, lsl yl
+	mov	yl, r4, lsl yl
+
+#else
+
+	mov	yl, r4
+	mov	ip, #1
+1:	cmp	yl, #0x80000000
+	cmpcc	yl, xh
+	movcc	yl, yl, lsl #1
+	movcc	ip, ip, lsl #1
+	bcc	1b
+
+#endif
+
+	@ The division loop for needed upper bit positions.
+ 	@ Break out early if dividend reaches 0.
+2:	cmp	xh, yl
+	orrcs	yh, yh, ip
+	subcss	xh, xh, yl
+	movnes	ip, ip, lsr #1
+	mov	yl, yl, lsr #1
+	bne	2b
+
+	@ See if we need to handle lower 32-bit result.
+3:	cmp	xh, #0
+	mov	yl, #0
+	cmpeq	xl, r4
+	movlo	xh, xl
+	movlo	pc, lr
+
+	@ The division loop for lower bit positions.
+	@ Here we shift remainer bits leftwards rather than moving the
+	@ divisor for comparisons, considering the carry-out bit as well.
+	mov	ip, #0x80000000
+4:	movs	xl, xl, lsl #1
+	adcs	xh, xh, xh
+	beq	6f
+	cmpcc	xh, r4
+5:	orrcs	yl, yl, ip
+	subcs	xh, xh, r4
+	movs	ip, ip, lsr #1
+	bne	4b
+	mov	pc, lr
+
+	@ The top part of remainder became zero.  If carry is set
+	@ (the 33th bit) this is a false positive so resume the loop.
+	@ Otherwise, if lower part is also null then we are done.
+6:	bcs	5b
+	cmp	xl, #0
+	moveq	pc, lr
+
+	@ We still have remainer bits in the low part.  Bring them up.
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	xh, xl			@ we know xh is zero here so...
+	add	xh, xh, #1
+	mov	xl, xl, lsl xh
+	mov	ip, ip, lsr xh
+
+#else
+
+7:	movs	xl, xl, lsl #1
+	mov	ip, ip, lsr #1
+	bcc	7b
+
+#endif
+
+	@ Current remainder is now 1.  It is worthless to compare with
+	@ divisor at this point since divisor can not be smaller than 3 here.
+	@ If possible, branch for another shift in the division loop.
+	@ If no bit position left then we are done.
+	movs	ip, ip, lsr #1
+	mov	xh, #1
+	bne	4b
+	mov	pc, lr
+
+8:	@ Division by a power of 2: determine what that divisor order is
+	@ then simply shift values around
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	ip, r4
+	rsb	ip, ip, #31
+
+#else
+
+	mov	yl, r4
+	cmp	r4, #(1 << 16)
+	mov	ip, #0
+	movhs	yl, yl, lsr #16
+	movhs	ip, #16
+
+	cmp	yl, #(1 << 8)
+	movhs	yl, yl, lsr #8
+	addhs	ip, ip, #8
+
+	cmp	yl, #(1 << 4)
+	movhs	yl, yl, lsr #4
+	addhs	ip, ip, #4
+
+	cmp	yl, #(1 << 2)
+	addhi	ip, ip, #3
+	addls	ip, ip, yl, lsr #1
+
+#endif
+
+	mov	yh, xh, lsr ip
+	mov	yl, xl, lsr ip
+	rsb	ip, ip, #32
+	orr	yl, yl, xh, lsl ip
+	mov	xh, xl, lsl ip
+	mov	xh, xh, lsr ip
+	mov	pc, lr
+
+	@ eq -> division by 1: obvious enough...
+9:	moveq	yl, xl
+	moveq	yh, xh
+	moveq	xh, #0
+	moveq	pc, lr
+
+	@ Division by 0:
+	str	lr, [sp, #-8]!
+	bl	__div0
+
+	@ as wrong as it could be...
+	mov	yl, #0
+	mov	yh, #0
+	mov	xh, #0
+	ldr	pc, [sp], #8
+
diff --git a/lib_generic/vsprintf.c b/lib_generic/vsprintf.c
index 767dde1..c847376 100644
--- a/lib_generic/vsprintf.c
+++ b/lib_generic/vsprintf.c
@@ -21,7 +21,8 @@
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
 #endif
 
-unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
+// PMP unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
+ulong simple_strtoul(const char *cp,char **endp,unsigned int base)
 {
 	unsigned long result = 0,value;
 
diff --git a/net/bootp.c b/net/bootp.c
index 83465e4..fd12eff 100644
--- a/net/bootp.c
+++ b/net/bootp.c
@@ -126,6 +126,10 @@ static void BootpCopyNetParams(Bootp_t *bp)
 		NetCopyIP(&NetServerIP, &bp->bp_siaddr);
 	memcpy (NetServerEther, ((Ethernet_t *)NetRxPkt)->et_src, 6);
 #endif
+#ifdef PRODUCTION_CODE
+	/*
+	 * Server overrides any target value to ensure the correct file is downloaded
+	 */
 	if (strlen(bp->bp_file) > 0)
 		copy_filename (BootFile, bp->bp_file, sizeof(BootFile));
 
@@ -138,6 +142,23 @@ static void BootpCopyNetParams(Bootp_t *bp)
 	if (*BootFile) {
 		setenv ("bootfile", BootFile);
 	}
+#else
+	/*
+	 * During development it is useful to be able to force the bootfile value from the
+	 * target, rather than allowing the server to override it.
+	 */
+	if (strlen(bp->bp_file) > 0 && !getenv("bootfile")) 
+	{
+		/* Propagate to environment:
+		 * Only set when BOOTP / DHCP reply contains a new value
+		 * and bootfile doesn't exist.
+		 */
+		copy_filename (BootFile, bp->bp_file, sizeof(BootFile));
+		setenv ("bootfile", BootFile);
+	}
+	debug ("Bootfile: %s\n", BootFile);
+	
+#endif
 }
 
 static int truncate_sz (const char *name, int maxlen, int curlen)
-- 
1.6.3.3

