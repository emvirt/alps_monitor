From 0cca79bf9891f67c80c5136fbb7e8153f22fb48a Mon Sep 17 00:00:00 2001
From: Keitaro Kitagawa <kita@kmckk.co.jp>
Date: Fri, 13 Nov 2009 19:13:23 +0900
Subject: [PATCH 43/46] a9tc: support KZM-CA9 by NECEL

---
 Makefile                         |    3 +
 board/a9tc/Makefile              |   47 ++++
 board/a9tc/a9tc.c                |  222 ++++++++++++++++++
 board/a9tc/boot.h                |   55 +++++
 board/a9tc/config.mk             |   27 +++
 board/a9tc/lowlevel_init.S       |  219 ++++++++++++++++++
 board/a9tc/u-boot.lds            |   55 +++++
 cpu/arm_cortexa9/Makefile        |   47 ++++
 cpu/arm_cortexa9/a9tc/Makefile   |   46 ++++
 cpu/arm_cortexa9/a9tc/dummy.c    |    3 +
 cpu/arm_cortexa9/config.mk       |   36 +++
 cpu/arm_cortexa9/cpu.c           |  185 +++++++++++++++
 cpu/arm_cortexa9/start.S         |  470 ++++++++++++++++++++++++++++++++++++++
 drivers/net/Makefile             |    1 +
 drivers/net/smc9118.c            |   14 +-
 include/asm-arm/arch-a9tc/a9tc.h |   94 ++++++++
 include/asm-arm/mach-types.h     |    2 +
 include/configs/a9tc.h           |  189 +++++++++++++++
 18 files changed, 1711 insertions(+), 4 deletions(-)
 create mode 100644 board/a9tc/Makefile
 create mode 100644 board/a9tc/a9tc.c
 create mode 100644 board/a9tc/boot.h
 create mode 100644 board/a9tc/config.mk
 create mode 100644 board/a9tc/lowlevel_init.S
 create mode 100644 board/a9tc/u-boot.lds
 create mode 100644 cpu/arm_cortexa9/Makefile
 create mode 100644 cpu/arm_cortexa9/a9tc/Makefile
 create mode 100644 cpu/arm_cortexa9/a9tc/dummy.c
 create mode 100644 cpu/arm_cortexa9/config.mk
 create mode 100644 cpu/arm_cortexa9/cpu.c
 create mode 100644 cpu/arm_cortexa9/start.S
 create mode 100644 include/asm-arm/arch-a9tc/a9tc.h
 create mode 100644 include/configs/a9tc.h

diff --git a/Makefile b/Makefile
index d5246e8..604689b 100755
--- a/Makefile
+++ b/Makefile
@@ -2995,6 +2995,9 @@ omap3_pandora_config :	unconfig
 omap3_zoom1_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 zoom1 omap3 omap3
 
+a9tc_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 a9tc NULL a9tc
+
 #########################################################################
 ## XScale Systems
 #########################################################################
diff --git a/board/a9tc/Makefile b/board/a9tc/Makefile
new file mode 100644
index 0000000..5a5e720
--- /dev/null
+++ b/board/a9tc/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= a9tc.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/a9tc/a9tc.c b/board/a9tc/a9tc.c
new file mode 100644
index 0000000..5605ed6
--- /dev/null
+++ b/board/a9tc/a9tc.c
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/arch/a9tc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static void flash__init(void);
+static void ether__init(void);
+static void timer_init(void);
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+    printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+#define COMP_MODE_ENABLE ((unsigned int)0x0000EAEF)
+
+static inline void delay (unsigned long loops)
+{
+    __asm__ volatile (
+        "1:\n"
+        "subs %0, %1, #1\n"
+        "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+    DECLARE_GLOBAL_DATA_PTR;
+
+    gd->bd->bi_arch_number = MACH_TYPE_A9TC;
+
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
+
+    gd->flags = 0;
+
+    icache_enable();
+    flash__init();
+    ether__init();
+    timer_init();
+
+    return 0;
+}
+
+int misc_init_r (void)
+{
+    setenv("verify", "n");
+    return (0);
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+void flash__init (void)
+{
+    /* !!! TODO: */
+}
+
+/*************************************************************
+ Routine:ether__init
+ Description: take the Ethernet controller out of reset and wait
+      		   for the EEPROM load to complete.
+*************************************************************/
+static void ether__init (void)
+{
+    /* !!! TODO */
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+int dram_init (void)
+{
+#if CONFIG_NR_DRAM_BANKS > 0
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size  = PHYS_SDRAM_1_SIZE;
+#if CONFIG_NR_DRAM_BANKS > 1
+    gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+    gd->bd->bi_dram[1].size  = PHYS_SDRAM_2_SIZE;
+#endif
+#endif
+    return 0;
+}
+
+/*******************************************************************************
+        Timer Routines
+
+    U-Boot expects a 32 bit timer, running at CFG_HZ (= 1000).
+    MPCore private timer is initialized as 1MHz Interval Timer.
+*******************************************************************************/
+
+#define PTMR_LOAD                       (CONFIG_SYS_TIMERBASE + 0x00U) /* Timer Load */
+#define PTMR_COUNTER                    (CONFIG_SYS_TIMERBASE + 0x04U) /* Timer Counter */
+#define PTMR_CONTROL                    (CONFIG_SYS_TIMERBASE + 0x08U) /* Timer Control */
+#define PTMR_INTERRUPT_STATUS           (CONFIG_SYS_TIMERBASE + 0x0cU) /* Timer Interrupt Status */
+
+#define PTMR_PRESCALER                  199U            /* Prescaler Value */
+#define PTMR_CPU_CLK_FREQ               400000000U      /* CPU Clock in Hz */
+
+static ulong timestamp;
+static ulong lastdec;                   /* last value of timer counter */
+
+static void timer_init(void)
+{
+    writel((PTMR_PRESCALER << 8), PTMR_CONTROL);
+    writel(CONFIG_SYS_TIMER_RELOAD, PTMR_LOAD);
+    /* timer enable, auto-reload and IT disable */
+    writel((PTMR_PRESCALER << 8) | 0x3, PTMR_CONTROL);
+}
+
+static ulong timer_read(void)
+{
+    return readl(PTMR_COUNTER);
+}
+
+ulong get_timer_masked(void)
+{
+    ulong now = timer_read() / 1000U;
+
+    if (lastdec >= now) {   /* auto-reload didn't have occurred */
+        timestamp += lastdec - now;
+    } else {			    /* auto-reload had occurred */
+        timestamp += lastdec + CONFIG_SYS_TIMER_RELOAD - now;
+    }
+    lastdec = now;
+
+    return timestamp;
+}
+
+void reset_timer_masked(void)
+{
+    timestamp = 0;	       	            /* clear timestanp */
+    lastdec = timer_read() /1000U;
+}
+
+ulong get_timer(ulong base)
+{
+    return get_timer_masked() - base;
+}
+
+int interrupt_init (void)
+{
+    return 0;
+}
+
+/*
+ * Write the system control status register to cause reset
+ */
+void reset_cpu(ulong addr)
+{
+    /* !!! TODO: */
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+/* ASSUMES timer is ticking at 1 msec			*/
+void udelay (unsigned long usec)
+{
+    ulong tmo, tmp;
+
+    tmo = usec/1000;
+
+    tmp = get_timer(0);		/* get current timestamp */
+
+    if( (tmo + tmp + 1) < tmp )	/* if setting this forward will roll time stamp */
+        reset_timer_masked ();	/* reset "advancing" timestamp to 0, set lastdec value */
+    else
+        tmo += tmp;		/* else, set advancing stamp wake up time */
+
+    while (get_timer_masked () < tmo)/* loop till event */
+        /*NOP*/;
+}
+
+#ifdef CONFIG_REVISION_TAG
+/*
+ *  u32 get_board_rev() for ARM supplied development boards
+ */
+uint32_t get_board_rev(void)
+{
+    return 0;
+}
+#endif
+
+
+#ifdef CONFIG_DISPLAY_BOARDINFO
+int checkboard(void)
+{
+	puts("Board: A9TC board\n");
+	return 0;
+}
+#endif
+
diff --git a/board/a9tc/boot.h b/board/a9tc/boot.h
new file mode 100644
index 0000000..60a4b95
--- /dev/null
+++ b/board/a9tc/boot.h
@@ -0,0 +1,55 @@
+/*
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _BOOT_H
+#define _BOOT_H
+
+#ifdef __ASSEMBLER__
+
+
+#define	SET_BASEREG(base_reg, VALUE)	\
+        ldr     base_reg, =VALUE
+
+#define	STORE_WORD(base_reg, OFFSET, VALUE, work_reg)	\
+        ldr     work_reg, =VALUE;		\
+        str     work_reg, [base_reg, #((OFFSET) & 0x00fff)];
+
+
+#define	STORE_HALF_WORD(base_reg, OFFSET, VALUE, work_reg)	\
+        MOV     work_reg, #((VALUE) & 0xff00);		\
+	.ifne ((VALUE) & 0x00ff); \
+        ADD     work_reg, work_reg, #((VALUE) & 0x00ff);	\
+	.endif; \
+        STRH     work_reg, [base_reg, #((OFFSET) & 0x00fff)];
+
+#define	LOAD_WORD(base_reg, OFFSET, work_reg)	\
+        LDR     work_reg, [base_reg, #((OFFSET) & 0x0fff)];
+
+#define	LOAD_HALF_WORD(base_reg, OFFSET, work_reg)	\
+        LDRH     work_reg, [base_reg, #((OFFSET) & 0x0fff)];
+
+#else /* __ASSEMBLER__ */
+#endif /* __ASSEMBLER__ */
+
+
+#endif /* _BOOT_H */
diff --git a/board/a9tc/config.mk b/board/a9tc/config.mk
new file mode 100644
index 0000000..d28807c
--- /dev/null
+++ b/board/a9tc/config.mk
@@ -0,0 +1,27 @@
+#
+# Copyright (C) NEC Electronics Corporation 2009
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# A9TC boards
+#
+
+TEXT_BASE = 0x6ff80000
diff --git a/board/a9tc/lowlevel_init.S b/board/a9tc/lowlevel_init.S
new file mode 100644
index 0000000..d07490b
--- /dev/null
+++ b/board/a9tc/lowlevel_init.S
@@ -0,0 +1,219 @@
+/*
+ * Board specific initialization for the A9TC and variants
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#include <asm/arch/a9tc.h>
+
+#include "boot.h"
+
+		.text
+        .globl lowlevel_init
+lowlevel_init:
+
+        ldr     r0, =A9TC_SRAM_BASE            @ Clear SRAM register (by all CPUs)
+        mov     r1, #0x0
+        str     r1, [r0]
+        str     r1, [r0, #4]
+
+        mrc     p15,0,r0,c0,c0,5                @ Check of CPU ID #
+        ands    r0, r0, #0xf
+        beq     do_lowlevel_init                @ CPI ID #0
+        b       do_wait_for_interrupt
+
+        .pool
+
+
+        /******************************************/
+        /* ----    CPU ID #1-#3 come here    ---- */
+        /******************************************/
+
+        .align  4
+do_wait_for_interrupt:
+        ldr     r1, =A9TC_GIC_CPU_BASE            @ Disable INTC CPU I/F
+        mov     r2, #0x0
+        str     r2, [r1, #GIC_CTRL]
+        mov     r2, #0xF0                        @ Set lowest priority
+        str     r2, [r1, #GIC_PRI_MASK]
+        mov     r2, #0x1                         @ Enable INTC CPU I/F
+        str     r2, [r1, #GIC_CTRL]
+
+wait_copy:
+        ldr r0, =A9TC_SRAM_BASE
+        ldr r2, [r0, #4]
+        cmp r2, #0
+        movne pc, r2
+        b wait_copy
+
+loop123:
+        mcr     p15,0,r0,c7,c0,4                @ Wait-For-Interrupt
+
+        ldr     r2, [r1, #0xC]
+
+        ldr     r0, =A9TC_SRAM_BASE            @ Check the return address
+        ldr     r2, [r0]
+        cmp     r2, #0
+        movne   pc, r2
+
+        b       loop123
+
+loop123_end:
+        .pool
+
+
+        /******************************************/
+        /* ----   Only CPU ID #0 comes here  ---- */
+        /******************************************/
+
+        .align  4
+do_lowlevel_init:
+        mov     r3,lr                           @ save lr
+
+        bl      dmc_init                        @ initialize DDR
+
+        bl      copy_wfi
+
+#if 0
+        adr     r0,init_intc_table
+        bl      do_init                         @ initialize INTC
+#endif
+        mov     lr,r3                           @ restore lr
+        bx      lr                              @ return to caller
+
+        .pool
+
+#if 0
+
+#define END_OF_TABLE            0
+#define DO_DELAY_LOOP           1
+
+        .align  4
+init_intc_table:
+        .long   0x00000000,(A9TC_GIC_DIST_BASE+GIC_DIC_CTRL)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_ENA+0x00)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_ENA+0x04)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_ENA+0x08)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_ENA+0x0C)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_ENA+0x10)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_ENA+0x14)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_ENA+0x18)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_ENA+0x1C)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_PND+0x00)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_PND+0x04)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_PND+0x08)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_PND+0x0C)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_PND+0x10)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_PND+0x14)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_PND+0x18)
+        .long   0xFFFFFFFF,(A9TC_GIC_DIST_BASE+GIC_DIC_PND+0x1C)
+        .long   0x00000001,(A9TC_GIC_DIST_BASE+GIC_DIC_CTRL)
+        .long   0         ,(END_OF_TABLE)
+
+        .align  4
+do_init:
+        ldmia   r0!,{r1,r2}
+        cmp     r2,#END_OF_TABLE
+        bxeq    lr
+        cmp     r2,#DO_DELAY_LOOP
+        beq     do_delay_loop
+        str     r1,[r2]
+        b       do_init
+do_delay_loop:
+        adds    r1,r1,#-1
+        nop
+        bne     do_delay_loop
+        b       do_init
+#endif
+
+        .align  4
+dmc_init:
+        SET_BASEREG(r0, A9TC_DMC_BASE)
+        STORE_WORD(r0, DMC_MEMC_CMD,    0x004, r1)
+        STORE_WORD(r0, DMC_ID_N_CFG,    0x003, r1)
+        STORE_WORD(r0, DMC_REFRESH_PRD, 0x3D0, r1)
+        STORE_WORD(r0, DMC_CAS_LATENCY, 0x00A, r1)
+        STORE_WORD(r0, DMC_T_MRD,  0x02, r1)
+        STORE_WORD(r0, DMC_T_TAS,  0x07, r1)
+        STORE_WORD(r0, DMC_T_RC,   0x0B, r1)
+        STORE_WORD(r0, DMC_T_RCD,  0x305, r1)
+        STORE_WORD(r0, DMC_T_RFC,  0x282A, r1)
+        STORE_WORD(r0, DMC_T_RP,   0x05, r1)
+        STORE_WORD(r0, DMC_T_RRD,  0x02, r1)
+        STORE_WORD(r0, DMC_T_WR,   0x04, r1)
+        STORE_WORD(r0, DMC_T_WTR,  0x03, r1)
+        STORE_WORD(r0, DMC_T_XP,   0x01, r1)
+        STORE_WORD(r0, DMC_T_XSR,  0xC8, r1)
+        STORE_WORD(r0, DMC_T_ESR,  0x14, r1)
+
+        STORE_WORD(r0, DMC_MEMORY_CFG, 0x1001A, r1)
+
+        STORE_WORD(r0, DMC_CHIP_CFG0, 0x100FC, r1)
+        STORE_WORD(r0, 0x310, 0x00, r1)
+        STORE_WORD(r0, 0x310, 0x7E000000, r1)
+        STORE_WORD(r0, 0x310, 0x00, r1)
+
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0xc0000, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0x00000, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0xA0000, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0xB0000, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0x90000, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0x80952, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0x00000, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0x40000, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0x40000, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0x80852, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0x90380, r1)
+        STORE_WORD(r0, DMC_DIRECT_CMD, 0x90004, r1)
+        STORE_WORD(r0, 0x310, 0x80000000, r1)
+
+        mov r2, #0
+dmc_loop1:
+        ldr r1, [r0]
+        add r2, r2, #1
+        cmp r2, #0x0A
+        bne dmc_loop1
+
+        STORE_WORD(r0, DMC_MEMC_CMD, 0x00, r1)
+dmc_loop2:
+        ldr r1, [r0]
+        and r1, r1, #0x3
+        cmp r1, #1
+        bne dmc_loop2
+        bx lr
+
+copy_wfi:
+       adr r0, loop123
+       adr r1, loop123_end
+       add r1, r1, #0x20
+       ldr r2, =A9TC_SRAM_WFI_ADDRESS
+1:
+       ldr r4, [r0], #4
+       str r4, [r2], #4
+       cmp r0, r1
+       blt 1b
+
+       ldr r0, =A9TC_SRAM_BASE
+       ldr r1, =A9TC_SRAM_WFI_ADDRESS
+       str r1, [r0, #4]
+       bx lr
+
+        .pool
+
diff --git a/board/a9tc/u-boot.lds b/board/a9tc/u-boot.lds
new file mode 100644
index 0000000..8c6dd75
--- /dev/null
+++ b/board/a9tc/u-boot.lds
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+    . = 0x00000000;
+    . = ALIGN(4);
+    .text :
+    {
+        cpu/arm_cortexa9/start.o (.text)
+        *(.text)
+    }
+    .rodata : { *(.rodata) }
+    . = ALIGN(4);
+    .data : { *(.data) }
+    . = ALIGN(4);
+    .got : { *(.got) }
+
+    . = .;
+    __u_boot_cmd_start = .;
+    .u_boot_cmd : { *(.u_boot_cmd) }
+    __u_boot_cmd_end = .;
+
+    . = ALIGN(4);
+    __bss_start = .;
+    .bss : { *(.bss) }
+    _end = .;
+}
diff --git a/cpu/arm_cortexa9/Makefile b/cpu/arm_cortexa9/Makefile
new file mode 100644
index 0000000..ae20299
--- /dev/null
+++ b/cpu/arm_cortexa9/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(CPU).a
+
+START	:= start.o
+COBJS	:= cpu.o
+
+SRCS	:= $(START:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(START) $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
\ No newline at end of file
diff --git a/cpu/arm_cortexa9/a9tc/Makefile b/cpu/arm_cortexa9/a9tc/Makefile
new file mode 100644
index 0000000..5b09b36
--- /dev/null
+++ b/cpu/arm_cortexa9/a9tc/Makefile
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= dummy.o
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/arm_cortexa9/a9tc/dummy.c b/cpu/arm_cortexa9/a9tc/dummy.c
new file mode 100644
index 0000000..4447f15
--- /dev/null
+++ b/cpu/arm_cortexa9/a9tc/dummy.c
@@ -0,0 +1,3 @@
+
+/* dummy file */
+
diff --git a/cpu/arm_cortexa9/config.mk b/cpu/arm_cortexa9/config.mk
new file mode 100644
index 0000000..b0bebd4
--- /dev/null
+++ b/cpu/arm_cortexa9/config.mk
@@ -0,0 +1,36 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+PLATFORM_RELFLAGS += -fno-strict-aliasing -fno-common -ffixed-r8 \
+		     -msoft-float
+
+# Make ARMv5 to allow more compilers to work, even though its v7a.
+PLATFORM_CPPFLAGS += -march=armv5
+# =========================================================================
+#
+# Supply options according to compiler version
+#
+# =========================================================================
+PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)
+PLATFORM_CPPFLAGS +=$(call cc-option,-mno-thumb-interwork,)
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,\
+		    $(call cc-option,-malignment-traps,))
\ No newline at end of file
diff --git a/cpu/arm_cortexa9/cpu.c b/cpu/arm_cortexa9/cpu.c
new file mode 100644
index 0000000..fdca47d
--- /dev/null
+++ b/cpu/arm_cortexa9/cpu.c
@@ -0,0 +1,185 @@
+/*
+ * (C) Copyright 2008 Texas Insturments
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * CPU specific code
+ */
+
+#include <common.h>
+#include <command.h>
+
+#ifdef CONFIG_USE_IRQ
+DECLARE_GLOBAL_DATA_PTR;
+#endif
+
+static void cache_flush(void);
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1(void)
+{
+	unsigned long value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 0\
+			     @ read control reg\n":"=r"(value)
+			     ::"memory");
+	return value;
+}
+
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1(unsigned long value)
+{
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 0\
+			     @ write it back\n"::"r"(value)
+			     : "memory");
+
+	read_p15_c1();
+}
+
+static void cp_delay(void)
+{
+	asm("nop");
+	asm("nop");
+}
+
+/* See also ARM Ref. Man. */
+#define C1_MMU		(1<<0)	/* mmu off/on */
+#define C1_ALIGN	(1<<1)	/* alignment faults off/on */
+#define C1_DC		(1<<2)	/* dcache off/on */
+#define C1_WB		(1<<3)	/* merging write buffer on/off */
+#define C1_BIG_ENDIAN	(1<<7)	/* big endian off/on */
+#define C1_SYS_PROT	(1<<8)	/* system protection */
+#define C1_ROM_PROT	(1<<9)	/* ROM protection */
+#define C1_IC		(1<<12)	/* icache off/on */
+#define C1_HIGH_VECTORS	(1<<13)	/* location of vectors: low/high addresses */
+#define RESERVED_1	(0xf << 3)	/* must be 111b for R/W */
+
+int cpu_init(void)
+{
+	/*
+	 * setup up stacks if necessary
+	 */
+#ifdef CONFIG_USE_IRQ
+	IRQ_STACK_START =
+	    _armboot_start - CONFIG_SYS_MALLOC_LEN - CONFIG_SYS_GBL_DATA_SIZE - 4;
+	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
+#endif
+	return 0;
+}
+
+int cleanup_before_linux(void)
+{
+	unsigned int i;
+
+	/*
+	 * this function is called just before we call linux
+	 * it prepares the processor for linux
+	 *
+	 * we turn off caches etc ...
+	 */
+	disable_interrupts();
+
+	/* turn off I/D-cache */
+	icache_disable();
+	dcache_disable();
+
+	/* invalidate I-cache */
+	cache_flush();
+
+	/* invalidate L2 cache also */
+	v7_flush_dcache_all();
+
+	i = 0;
+	/* mem barrier to sync up things */
+	asm("mcr p15, 0, %0, c7, c10, 4": :"r"(i));
+
+	return 0;
+}
+
+int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	disable_interrupts();
+	reset_cpu(0);
+
+	/* NOTREACHED */
+	return 0;
+}
+
+void icache_enable(void)
+{
+	ulong reg;
+
+	reg = read_p15_c1();	/* get control reg. */
+	cp_delay();
+	write_p15_c1(reg | C1_IC);
+}
+
+void icache_disable(void)
+{
+	ulong reg;
+
+	reg = read_p15_c1();
+	cp_delay();
+	write_p15_c1(reg & ~C1_IC);
+}
+
+int icache_status(void)
+{
+	return (read_p15_c1() & C1_IC) != 0;
+}
+
+
+void dcache_enable (void)
+{
+	ulong reg;
+
+	reg = read_p15_c1 ();
+	cp_delay ();
+	write_p15_c1 (reg | C1_DC);
+}
+
+void dcache_disable (void)
+{
+	ulong reg;
+
+	reg = read_p15_c1 ();
+	cp_delay ();
+	write_p15_c1 (reg & ~C1_DC);
+}
+
+int dcache_status (void)
+{
+	return (read_p15_c1 () & C1_DC) != 0;
+}
+
+
+
+static void cache_flush(void)
+{
+	asm ("mcr p15, 0, %0, c7, c5, 0": :"r" (0));
+}
diff --git a/cpu/arm_cortexa9/start.S b/cpu/arm_cortexa9/start.S
new file mode 100644
index 0000000..dc83ea8
--- /dev/null
+++ b/cpu/arm_cortexa9/start.S
@@ -0,0 +1,470 @@
+/*
+ * armboot - Startup Code for ARM Cortex CPU-core
+ *
+ * Copyright (c) 2004	Texas Instruments <r-woodruff2@ti.com>
+ *
+ * Copyright (c) 2001	Marius Gröger <mag@sysgo.de>
+ * Copyright (c) 2002	Alex Züpke <azu@sysgo.de>
+ * Copyright (c) 2002	Gary Jennejohn <gj@denx.de>
+ * Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
+ * Copyright (c) 2003	Kshitij <kshitij@ti.com>
+ * Copyright (c) 2006-2008 Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+.globl _start
+_start: b	reset
+	ldr	pc, _undefined_instruction
+	ldr	pc, _software_interrupt
+	ldr	pc, _prefetch_abort
+	ldr	pc, _data_abort
+	ldr	pc, _not_used
+	ldr	pc, _irq
+	ldr	pc, _fiq
+
+_undefined_instruction: .word undefined_instruction
+_software_interrupt:	.word software_interrupt
+_prefetch_abort:	.word prefetch_abort
+_data_abort:		.word data_abort
+_not_used:		.word not_used
+_irq:			.word irq
+_fiq:			.word fiq
+_pad:			.word 0x12345678 /* now 16*4=64 */
+.global _end_vect
+_end_vect:
+
+	.balignl 16,0xdeadbeef
+/*************************************************************************
+ *
+ * Startup Code (reset vector)
+ *
+ * do important init only if we don't start from memory!
+ * setup Memory and board specific bits prior to relocation.
+ * relocate armboot to ram
+ * setup stack
+ *
+ *************************************************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl _armboot_start
+_armboot_start:
+	.word _start
+
+/*
+ * These are defined in the board-specific linker script.
+ */
+.globl _bss_start
+_bss_start:
+	.word __bss_start
+
+.globl _bss_end
+_bss_end:
+	.word _end
+
+#ifdef CONFIG_USE_IRQ
+/* IRQ stack memory (calculated at run-time) */
+.globl IRQ_STACK_START
+IRQ_STACK_START:
+	.word	0x0badc0de
+
+/* IRQ stack memory (calculated at run-time) */
+.globl FIQ_STACK_START
+FIQ_STACK_START:
+	.word 0x0badc0de
+#endif
+
+/*
+ * the actual reset code
+ */
+
+reset:
+	/*
+	 * set the cpu to SVC32 mode
+	 */
+	mrs	r0, cpsr
+	bic	r0, r0, #0x1f
+	orr	r0, r0, #0xd3
+	msr	cpsr,r0
+
+	/* the mask ROM code should have PLL and others stable */
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+	bl	cpu_init_crit
+#endif
+
+#ifndef CONFIG_SKIP_RELOCATE_UBOOT
+relocate:				@ relocate U-Boot to RAM
+	adr	r0, _start		@ r0 <- current position of code
+	ldr	r1, _TEXT_BASE		@ test if we run from flash or RAM
+	cmp	r0, r1			@ don't reloc during debug
+	beq	stack_setup
+
+	ldr	r2, _armboot_start
+	ldr	r3, _bss_start
+	sub	r2, r3, r2		@ r2 <- size of armboot
+	add	r2, r0, r2		@ r2 <- source end address
+
+copy_loop:				@ copy 32 bytes at a time
+	ldmia	r0!, {r3 - r10}		@ copy from source address [r0]
+	stmia	r1!, {r3 - r10}		@ copy to   target address [r1]
+	cmp	r0, r2			@ until source end addreee [r2]
+	ble	copy_loop
+#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
+
+	/* Set up the stack */
+stack_setup:
+	ldr	r0, _TEXT_BASE		@ upper 128 KiB: relocated uboot
+	sub	r0, r0, #CONFIG_SYS_MALLOC_LEN @ malloc area
+	sub	r0, r0, #CONFIG_SYS_GBL_DATA_SIZE @ bdinfo
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ + CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		@ leave 3 words for abort-stack
+	and	sp, sp, #~7		@ 8 byte alinged for (ldr/str)d
+
+	/* Clear BSS (if any). Is below tx (watch load addr - need space) */
+clear_bss:
+	ldr	r0, _bss_start		@ find start of bss segment
+	ldr	r1, _bss_end		@ stop here
+	mov	r2, #0x00000000		@ clear value
+clbss_l:
+	str	r2, [r0]		@ clear BSS location
+	cmp	r0, r1			@ are we at the end yet
+	add	r0, r0, #4		@ increment clear index pointer
+	bne	clbss_l			@ keep clearing till at end
+
+	ldr	pc, _start_armboot	@ jump to C code
+
+_start_armboot: .word start_armboot
+
+
+/*************************************************************************
+ *
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************/
+cpu_init_crit:
+	/*
+	 * Invalidate L1 I/D
+	 */
+	mov	r0, #0			@ set up for MCR
+	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
+	orr	r0, r0, #0x00000800	@ set bit 12 (Z---) BTB
+	mcr	p15, 0, r0, c1, c0, 0
+
+	/*
+	 * Jump to board specific initialization...
+	 * The Mask ROM will have already initialized
+	 * basic memory. Go here to bump up clock rate and handle
+	 * wake up conditions.
+	 */
+	mov	ip, lr			@ persevere link reg across call
+	bl	lowlevel_init		@ go setup pll,mux,memory
+	mov	lr, ip			@ restore link
+	mov	pc, lr			@ back to my caller
+/*
+ *************************************************************************
+ *
+ * Interrupt handling
+ *
+ *************************************************************************
+ */
+@
+@ IRQ stack frame.
+@
+#define S_FRAME_SIZE	72
+
+#define S_OLD_R0	68
+#define S_PSR		64
+#define S_PC		60
+#define S_LR		56
+#define S_SP		52
+
+#define S_IP		48
+#define S_FP		44
+#define S_R10		40
+#define S_R9		36
+#define S_R8		32
+#define S_R7		28
+#define S_R6		24
+#define S_R5		20
+#define S_R4		16
+#define S_R3		12
+#define S_R2		8
+#define S_R1		4
+#define S_R0		0
+
+#define MODE_SVC 0x13
+#define I_BIT	 0x80
+
+/*
+ * use bad_save_user_regs for abort/prefetch/undef/swi ...
+ * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
+ */
+
+	.macro	bad_save_user_regs
+	sub	sp, sp, #S_FRAME_SIZE		@ carve out a frame on current
+						@ user stack
+	stmia	sp, {r0 - r12}			@ Save user registers (now in
+						@ svc mode) r0-r12
+
+	ldr	r2, _armboot_start
+	sub	r2, r2, #(CONFIG_SYS_MALLOC_LEN)
+	sub	r2, r2, #(CONFIG_SYS_GBL_DATA_SIZE + 8)	@ set base 2 words into abort
+						@ stack
+	ldmia	r2, {r2 - r3}			@ get values for "aborted" pc
+						@ and cpsr (into parm regs)
+	add	r0, sp, #S_FRAME_SIZE		@ grab pointer to old stack
+
+	add	r5, sp, #S_SP
+	mov	r1, lr
+	stmia	r5, {r0 - r3}			@ save sp_SVC, lr_SVC, pc, cpsr
+	mov	r0, sp				@ save current stack into r0
+						@ (param register)
+	.endm
+
+	.macro	irq_save_user_regs
+	sub	sp, sp, #S_FRAME_SIZE
+	stmia	sp, {r0 - r12}			@ Calling r0-r12
+	add	r8, sp, #S_PC			@ !! R8 NEEDS to be saved !!
+						@ a reserved stack spot would
+						@ be good.
+	stmdb	r8, {sp, lr}^			@ Calling SP, LR
+	str	lr, [r8, #0]			@ Save calling PC
+	mrs	r6, spsr
+	str	r6, [r8, #4]			@ Save CPSR
+	str	r0, [r8, #8]			@ Save OLD_R0
+	mov	r0, sp
+	.endm
+
+	.macro	irq_restore_user_regs
+	ldmia	sp, {r0 - lr}^			@ Calling r0 - lr
+	mov	r0, r0
+	ldr	lr, [sp, #S_PC]			@ Get PC
+	add	sp, sp, #S_FRAME_SIZE
+	subs	pc, lr, #4			@ return & move spsr_svc into
+						@ cpsr
+	.endm
+
+	.macro get_bad_stack
+	ldr	r13, _armboot_start		@ setup our mode stack (enter
+						@ in banked mode)
+	sub	r13, r13, #(CONFIG_SYS_MALLOC_LEN)	@ move past malloc pool
+	sub	r13, r13, #(CONFIG_SYS_GBL_DATA_SIZE + 8) @ move to reserved a couple
+						@ spots for abort stack
+
+	str	lr, [r13]			@ save caller lr in position 0
+						@ of saved stack
+	mrs	lr, spsr			@ get the spsr
+	str	lr, [r13, #4]			@ save spsr in position 1 of
+						@ saved stack
+
+	mov	r13, #MODE_SVC			@ prepare SVC-Mode
+	@ msr	spsr_c, r13
+	msr	spsr, r13			@ switch modes, make sure
+						@ moves will execute
+	mov	lr, pc				@ capture return pc
+	movs	pc, lr				@ jump to next instruction &
+						@ switch modes.
+	.endm
+
+	.macro get_bad_stack_swi
+	sub	r13, r13, #4			@ space on current stack for
+						@ scratch reg.
+	str	r0, [r13]			@ save R0's value.
+	ldr	r0, _armboot_start		@ get data regions start
+	sub	r0, r0, #(CONFIG_SYS_MALLOC_LEN)	@ move past malloc pool
+	sub	r0, r0, #(CONFIG_SYS_GBL_DATA_SIZE + 8)	@ move past gbl and a couple
+						@ spots for abort stack
+	str	lr, [r0]			@ save caller lr in position 0
+						@ of saved stack
+	mrs	r0, spsr			@ get the spsr
+	str	lr, [r0, #4]			@ save spsr in position 1 of
+						@ saved stack
+	ldr	r0, [r13]			@ restore r0
+	add	r13, r13, #4			@ pop stack entry
+	.endm
+
+	.macro get_irq_stack			@ setup IRQ stack
+	ldr	sp, IRQ_STACK_START
+	.endm
+
+	.macro get_fiq_stack			@ setup FIQ stack
+	ldr	sp, FIQ_STACK_START
+	.endm
+
+/*
+ * exception handlers
+ */
+	.align	5
+undefined_instruction:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_undefined_instruction
+
+	.align	5
+software_interrupt:
+	get_bad_stack_swi
+	bad_save_user_regs
+	bl	do_software_interrupt
+
+	.align	5
+prefetch_abort:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_prefetch_abort
+
+	.align	5
+data_abort:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_data_abort
+
+	.align	5
+not_used:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_not_used
+
+#ifdef CONFIG_USE_IRQ
+
+	.align	5
+irq:
+	get_irq_stack
+	irq_save_user_regs
+	bl	do_irq
+	irq_restore_user_regs
+
+	.align	5
+fiq:
+	get_fiq_stack
+	/* someone ought to write a more effective fiq_save_user_regs */
+	irq_save_user_regs
+	bl	do_fiq
+	irq_restore_user_regs
+
+#else
+
+	.align	5
+irq:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_irq
+
+	.align	5
+fiq:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_fiq
+
+#endif
+
+/*
+ *	v7_flush_dcache_all()
+ *
+ *	Flush the whole D-cache.
+ *
+ *	Corrupted registers: r0-r5, r7, r9-r11
+ *
+ *	- mm	- mm_struct describing address space
+ */
+	.align 5
+.global v7_flush_dcache_all
+v7_flush_dcache_all:
+	stmfd	r13!, {r0 - r5, r7, r9 - r12, r14}
+
+	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
+	ands	r3, r0, #0x7000000		@ extract loc from clidr
+	mov	r3, r3, lsr #23			@ left align loc bit field
+	beq	finished_inval			@ if loc is 0, then no need to
+						@ clean
+	mov	r10, #0				@ start clean at cache level 0
+inval_loop1:
+	add	r2, r10, r10, lsr #1		@ work out 3x current cache
+						@ level
+	mov	r1, r0, lsr r2			@ extract cache type bits from
+						@ clidr
+	and	r1, r1, #7			@ mask of the bits for current
+						@ cache only
+	cmp	r1, #2				@ see what cache we have at
+						@ this level
+	blt	skip_inval			@ skip if no cache, or just
+						@ i-cache
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
+						@ in cssr
+	mov	r2, #0				@ operand for mcr SBZ
+	mcr	p15, 0, r2, c7, c5, 4		@ flush prefetch buffer to
+						@ sych the new cssr&csidr,
+						@ with armv7 this is 'isb',
+						@ but we compile with armv5
+	mrc	p15, 1, r1, c0, c0, 0		@ read the new csidr
+	and	r2, r1, #7			@ extract the length of the
+						@ cache lines
+	add	r2, r2, #4			@ add 4 (line length offset)
+	ldr	r4, =0x3ff
+	ands	r4, r4, r1, lsr #3		@ find maximum number on the
+						@ way size
+	clz	r5, r4				@ find bit position of way
+						@ size increment
+	ldr	r7, =0x7fff
+	ands	r7, r7, r1, lsr #13		@ extract max number of the
+						@ index size
+inval_loop2:
+	mov	r9, r4				@ create working copy of max
+						@ way size
+inval_loop3:
+	orr	r11, r10, r9, lsl r5		@ factor way and cache number
+						@ into r11
+	orr	r11, r11, r7, lsl r2		@ factor index number into r11
+	mcr	p15, 0, r11, c7, c6, 2		@ invalidate by set/way
+	subs	r9, r9, #1			@ decrement the way
+	bge	inval_loop3
+	subs	r7, r7, #1			@ decrement the index
+	bge	inval_loop2
+skip_inval:
+	add	r10, r10, #2			@ increment cache number
+	cmp	r3, r10
+	bgt	inval_loop1
+finished_inval:
+	mov	r10, #0				@ swith back to cache level 0
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
+						@ in cssr
+	mcr	p15, 0, r10, c7, c5, 4		@ flush prefetch buffer,
+						@ with armv7 this is 'isb',
+						@ but we compile with armv5
+
+	ldmfd	r13!, {r0 - r5, r7, r9 - r12, pc}
+
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index f83d212..354ea2d 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -63,6 +63,7 @@ COBJS-$(CONFIG_DRIVER_S3C4510_ETH) += s3c4510b_eth.o
 COBJS-$(CONFIG_SH_ETHER) += sh_eth.o
 COBJS-$(CONFIG_DRIVER_SMC91111) += smc91111.o
 COBJS-$(CONFIG_DRIVER_SMC911X) += smc911x.o
+COBJS-$(CONFIG_DRIVER_SMC9118) += smc9118.o
 COBJS-$(CONFIG_DRIVER_SMC_RV) += smc_rv.o
 COBJS-$(CONFIG_TIGON3) += tigon3.o bcm570x_autoneg.o 5701rls.o
 COBJS-$(CONFIG_TSEC_ENET) += tsec.o
diff --git a/drivers/net/smc9118.c b/drivers/net/smc9118.c
index 6ac1018..181bc0d 100644
--- a/drivers/net/smc9118.c
+++ b/drivers/net/smc9118.c
@@ -521,10 +521,11 @@ int smc9118_set_valid_ethaddr(void){
 
 	/* Try for ethadd from environment */
 	env_size = getenv_r ("ethaddr", s_env_mac, sizeof (s_env_mac));
-	if ((env_size > 0) && (env_size != sizeof (dummy_mac))) {	/* exit if env is bad */
-		printf ("\n*** ERROR: ethaddr is not set properly!!\n");
-	} else {
+	if ((env_size > 0) && (env_size == sizeof (dummy_mac))) {	/* might have a valid env */
 		env_present = 1;
+	} else {
+		if (env_size > 0)	/* env size is invalid... */
+			printf ("\n*** ERROR: ethaddr is not set properly!!\n");
 	}
 
 	if (env_present) {
@@ -540,10 +541,15 @@ int smc9118_set_valid_ethaddr(void){
 		mac_low =  (mac[3] * 0x1000000) + (mac[2] * 0x10000) + (mac[1] * 0x100) + mac[0];
 	} else {
 		/* read from smc9118 */
-		if(*SMSC9118_E2P_CMD & 1) {
+//		if(*SMSC9118_E2P_CMD & 1) {
+		if(*SMSC9118_E2P_CMD & 0x100) {
         		// Read current auto-loaded mac address.
     			smsc9118_mac_regread(SMSC9118_MAC_ADDRH, &mac_high);
     			smsc9118_mac_regread(SMSC9118_MAC_ADDRL, &mac_low);
+			sprintf(dummy_mac, "%02x:%02x:%02x:%02x:%02x:%02x",
+				((mac_low >>  0) & 0xffU), ((mac_low >>  8) & 0xffU), ((mac_low >> 16) & 0xffU),
+				((mac_low >> 24) & 0xffU), ((mac_high >> 0) & 0xffU), ((mac_high >> 8) & 0xffU));
+			setenv("ethaddr", dummy_mac);
 			env_present = 1;
 		}
 	}
diff --git a/include/asm-arm/arch-a9tc/a9tc.h b/include/asm-arm/arch-a9tc/a9tc.h
new file mode 100644
index 0000000..18c4437
--- /dev/null
+++ b/include/asm-arm/arch-a9tc/a9tc.h
@@ -0,0 +1,94 @@
+/*
+ * I/O Base Address Definitions for NaviEngine SoC Processor
+ *
+ * Copyright (C) NEC Electronics Corporation 2007
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ARCH_NAVIENGINE_H
+#define __ARCH_NAVIENGINE_H
+
+
+/* -----------------------------------------------------------------------
+ * NaviEngine1 I/O Addresses
+ */
+
+#define A9TC_SCU_BASE           0x1E000000
+#define SCU_CPU_STATUS          0x008           /* CPU status */
+
+#define A9TC_GIC_CPU_BASE       0x1E000100
+#define GIC_CTRL                0x000          /* Control */
+#define GIC_PRI_MASK            0x004          /* Priority Mask */
+
+#define A9TC_GIC_DIST_BASE      0x1E001000
+#define GIC_DIC_CTRL            0x000          /* Control */
+#define GIC_DIC_ENA             0x180          /* Interrupt Set Enable */
+#define GIC_DIC_PND             0x280          /* Interrupt Set Pending */
+
+#define A9TC_DMC_BASE           0x100E0000
+#define DMC_MEMC_STATUS         0x000
+#define DMC_MEMC_CMD            0x004
+#define DMC_DIRECT_CMD          0x008
+#define DMC_MEMORY_CFG          0x00C
+#define DMC_REFRESH_PRD         0x010
+#define DMC_CAS_LATENCY         0x014
+#define DMC_WRITE_LATENCY       0x018
+#define DMC_T_MRD               0x01C
+#define DMC_T_TAS               0x020
+#define DMC_T_RC                0x024
+#define DMC_T_RCD               0x028
+#define DMC_T_RFC               0x02C
+#define DMC_T_RP                0x030
+#define DMC_T_RRD               0x034
+#define DMC_T_WR                0x038
+#define DMC_T_WTR               0x03C
+#define DMC_T_XP                0x040
+#define DMC_T_XSR               0x044
+#define DMC_T_ESR               0x048
+#define DMC_MEMORY_CFG2         0x04C
+#define DMC_MEMORT_CFG3         0x050
+#define DMC_T_FAW               0x054
+#define DMC_UPDATE_TYPE         0x058
+#define DMC_T_RDATA_EN          0x05C
+#define DMC_T_WRLAT_DIFF        0x060
+#define DMC_ID_N_CFG            0x100
+#define DMC_CHIP_CFG0           0x200
+#define DMC_CHIP_CFG1           0x204
+#define DMC_CHIP_CFG2           0x208
+#define DMC_CHIP_CFG3           0x20C
+#define DMC_USER_STATUS         0x300
+#define DMC_USER_CONFIG0        0x304
+#define DMC_USER_CONFIG1        0x308
+#define DMC_FEATURE_CTRL        0x30C
+#define DMC_ECC_CONTROL         0x500
+#define DMC_ECC_INT_CLR         0x504
+#define DMC_ECC_STATUS          0x508
+#define DMC_ECC_INFO            0x50C
+#define DMC_INT_CFG             0xE00
+#define DMC_INT_INPUTS          0xE04
+#define DMC_INT_OUTPUTS         0xE08
+#define DMC_PERIPH_ID_N         0xFE0
+#define DMC_PCELL_ID_N          0xFF0
+
+#define A9TC_SRAM_BASE          0x10060000
+#define A9TC_SRAM_WFI_ADDRESS   0x10060100
+
+#endif /* __ARCH_NAVIENGINE_H */
+
diff --git a/include/asm-arm/mach-types.h b/include/asm-arm/mach-types.h
index f65a12a..fe011ce 100755
--- a/include/asm-arm/mach-types.h
+++ b/include/asm-arm/mach-types.h
@@ -1991,6 +1991,8 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_LINKSTATION_LS_HGL   2005
 #define MACH_TYPE_HTCVENUS             2006
 
+#define MACH_TYPE_A9TC                 3000
+
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
 #  undef machine_arch_type
diff --git a/include/configs/a9tc.h b/include/configs/a9tc.h
new file mode 100644
index 0000000..fb12918
--- /dev/null
+++ b/include/configs/a9tc.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) NEC Electronics Corporation 2007
+ * Configuation settings for the NaviEngine1 NE1-TB board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+
+/* -----------------------------------------------------------------------*/
+#define CONFIG_A9TC
+
+
+#define LINUX_BOOT_PARAM_ADDR	0x60000100
+
+
+/* ---- Timer ---- */
+#define CFG_HZ                      (1000)
+#define CONFIG_SYS_HZ               CFG_HZ
+#define CONFIG_SYS_HZ_CLOCK         1000000 /* Timers clocked at 1Mhz */
+#define CONFIG_SYS_TIMERBASE        0x1E000600
+#define CONFIG_SYS_TIMER_RELOAD     0xfffffffeU
+#define TIMER_LOAD_VAL
+
+#define CONFIG_CMDLINE_TAG          1 /* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS    1
+#define CONFIG_MISC_INIT_R          1 /* call misc_init_r during start up */
+
+/* ---- Size of malloc() pool ---- */
+#define CONFIG_SYS_MALLOC_LEN       (CONFIG_ENV_SIZE + 128*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE    128 /* size in bytes reserved for initial data */
+
+/* ---- Stack sizes - The stack is setup in start.S ---- */
+#define CONFIG_STACKSIZE            (128 * 1024)    /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ        (4 * 1024)      /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ        (4 * 1024)      /* FIQ stack */
+#endif
+
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+// Add
+//#define CONFIG_CMD_ELF
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_PING
+
+// Del
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+//#undef CONFIG_CMD_IMI		/* iminfo			*/
+//#undef CONFIG_CMD_IMLS		/* List all found images	*/
+#undef CONFIG_CMD_NFS		/* NFS support			*/
+#undef CONFIG_CMD_SETGETDCR	/* DCR support on 4xx		*/
+
+
+#if 0
+#define CONFIG_CMD_DATE		/* support for RTC, date/time...*/
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support		*/
+#define CONFIG_CMD_FAT		/* FAT support		*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support	*/
+
+#define CONFIG_CMD_MMC		/* MMC support		*/
+#define CONFIG_CMD_NAND		/* NAND support		*/
+#endif
+
+
+#define	CONFIG_AUTO_COMPLETE /* enable auto-completion of commands using TAB */
+//#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+
+/* ---- FLASH and environment organization ---- */
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_ENV_IS_IN_FLASH          1 /* env in flash */
+
+//#define CONFIG_SYS_FLASH_BASE           0x00000000  /* FLASH Bank #1 */
+#define CONFIG_SYS_FLASH_BASE           0x40000000  /* FLASH Bank #1 */
+#define CONFIG_SYS_MAX_FLASH_BANKS      (1) /* max number of memory banks */
+
+#define CONFIG_SYS_FLASH_ERASE_TOUT     (2*CFG_HZ) /* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT     (2*CFG_HZ) /* Timeout for Flash Write */
+
+#define PHYS_FLASH_SIZE                 0x04000000  /* 64MB */
+#define FLASH_SECTOR_SIZE               0x00040000  /* 256 KB sectors */
+#define CONFIG_SYS_FLASH_CFI_WIDTH      FLASH_CFI_32BIT
+
+#define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
+
+#define CONFIG_SYS_MAX_FLASH_SECT       (512) /* 256KB * 256 sectors */
+
+#define CONFIG_SYS_MONITOR_BASE         (CONFIG_SYS_FLASH_BASE + 0x00000000U)
+//#define CFG_MONITOR_LEN                 (3 * FLASH_SECTOR_SIZE)
+
+#define CONFIG_ENV_SIZE                 8192
+#define CONFIG_ENV_SECT_SIZE            FLASH_SECTOR_SIZE
+#define CONFIG_ENV_OFFSET               FLASH_SECTOR_SIZE
+#define CONFIG_ENV_ADDR                 (CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET)
+
+#define CONFIG_SYS_FLASH_PROTECTION     /* The devices have real protection */
+#define CONFIG_SYS_FLASH_EMPTY_INFO     /* flinfo indicates empty blocks */
+
+
+/* ---- Configuration for the Ethernet Driver (LAN9118) ---- */
+#define CONFIG_DRIVER_SMC9118
+#define CONFIG_SMC9118_BASE             0x4C000000
+#define CONFIG_SMC_USE_32_BIT
+
+
+/* ---- Configuration for the Console Driver ---- */
+#define CONFIG_PL011_SERIAL
+#define CONFIG_PL011_CLOCK	7372800
+#define CONFIG_PL01x_PORTS	{ (void *)0x100E3000 }
+#define CONFIG_CONS_INDEX	0
+
+#define CONFIG_BAUDRATE                 38400
+#define CONFIG_SYS_BAUDRATE_TABLE       { 9600, 19200, 38400, 57600, 115200 }
+
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP             /* enable long help message */
+#define	CONFIG_SYS_HUSH_PARSER          /* enable the "hush" shell */
+#define	CONFIG_SYS_PROMPT_HUSH_PS2      "> " /* the secondary prompt string */
+#define CONFIG_SYS_PROMPT	            "$ " /* the primary prompt string */
+#define CONFIG_SYS_CBSIZE	            256	 /* Console I/O Buffer Size	*/
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE	            (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS	            16 /* max number of command args */
+#define CONFIG_SYS_BARGSIZE	            CONFIG_SYS_CBSIZE /* Boot Argument Buffer Size */
+
+#define CONFIG_SYS_MEMTEST_START        0x60008000
+#define CONFIG_SYS_MEMTEST_END          0x6ff00000
+
+#undef  CONFIG_SYS_CLKS_IN_HZ           /* everything, incl board info, in Hz */
+#define CONFIG_SYS_LOAD_ADDR            0x60007fc0 /* default load address */
+
+/* ---- Physical Memory Map ---- */
+#define CONFIG_NR_DRAM_BANKS            1          /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1                    0x60000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE               0x10000000 /* 256 MB */
+#define PHYS_SDRAM_2                    0x70000000 /* SDRAM Bank #2 */
+#define PHYS_SDRAM_2_SIZE               0x10000000 /* 256 MB */
+
+
+/* Environment information */
+#define CONFIG_BOOTDELAY                3
+
+#define CONFIG_BOOTARGS                 "root=/dev/null init=/linuxrc mem=192M console=ttyAMA0,115200 rootflags=physaddr=0x00400000"
+#define CONFIG_BOOTCOMMAND              "tftpboot; bootm"
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"" \
+	""
+
+/* ---- Static configuration when assigning fixed address ---- */
+
+#define CONFIG_IPADDR                   192.168.0.13		/* static IP I currently own */
+#define CONFIG_NETMASK                  255.255.255.0	/* talk on MY local net */
+#define CONFIG_SERVERIP                 192.168.0.1		/* current IP of my dev pc */
+#define CONFIG_BOOTFILE                 "uImage" /* file to load */
+#define	CONFIG_DIRECT_FLASH_TFTP        /* enable TFTP transfer directly to flash */
+
+#define CONFIG_ETHADDR                  00:11:22:33:44:55
+
+#endif /* __CONFIG_H */
-- 
1.6.3.3

