diff -Nur linux-2.6.28.orig/KMC/Kconfig_kmc linux-2.6.28/KMC/Kconfig_kmc
--- linux-2.6.28.orig/KMC/Kconfig_kmc	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/Kconfig_kmc	2009-11-26 15:15:13.000000000 +0900
@@ -0,0 +1,106 @@
+#
+# PARTNER-Jet Linux support patch by KMC
+#
+# Ver2.0	08.04.14
+# Ver2.01	08.07.22	depends keyword "on"
+#
+
+menu 'PARTNER Debugging'
+
+choice
+    prompt "Debug information type"
+    default CONFIG_DEBINFO_STABP
+    config DEBINFO_NONE
+        bool "NONE"
+    config DEBINFO_STAB
+        bool "STAB"
+    config DEBINFO_STABP
+        bool "extendedSTAB"
+    config DEBINFO_DWARF
+        bool "DWARF-1"
+    config DEBINFO_DWARFP
+        bool "extendDWARF-1"
+    config DEBINFO_DWARF2
+        bool "DWARF-2"
+endchoice
+
+config KMC_PATCH
+    bool "Enable patch for PARTNER debug"
+    default n
+
+config KMC_MODULE_DEBUG
+    bool "Loadable module debug by PARTNER-Jet"
+    default y
+    depends on KMC_PATCH
+
+choice
+    prompt "select module debug type"
+    depends on KMC_MODULE_DEBUG
+    default KMC_MODULE_DEBUG_NEW
+    config KMC_MODULE_AUTO
+        bool "debug hook in module side"
+    config KMC_MODULE_DEBUG_NEW
+        bool "debug hook in kernel side"
+endchoice
+
+config KMC_USE_BT
+    bool "use PARTNER GigaTrace(PARTNER-Jet M40, ...)"
+    default n
+    depends on KMC_PATCH
+
+config KMC_USE_BT_DATATRACE
+    bool "use CPU Data Trace"
+    default n
+    depends on KMC_USE_BT
+
+config KMC_EVENTTRACKER_SUPPORT
+    bool "enable PARNTER-Jet Event Tracker"
+    default n
+    depends on KMC_PATCH
+
+config KMC_EVENTTRACKER_RTM
+    bool "event data is only from CPU's trace"
+    default n
+    depends on KMC_EVENTTRACKER_SUPPORT && KMC_USE_BT
+
+config KMC_EVENTTRACKER_LOG_SIZE
+    int "max event count (x1024, set is 1, 2, 4, 8, 16, 32, 64, .....)"
+    depends on KMC_EVENTTRACKER_SUPPORT && !KMC_EVENTTRACKER_RTM
+    default 4
+
+config KMC_LINUX_PROFILE
+    bool "enable PARNTER-Jet Linux Process Trace(ARM V6 or V7 only)"
+    default n
+    select KMC_LINUX_ARMV6_EXT_PROFILE
+    depends on KMC_PATCH && (CPU_V6 || CPU_V7)
+
+config KMC_LINUX_ARMV6_EXT_PROFILE
+    bool
+
+    menu 'PARTNER Extend menu'
+        depends on KMC_PATCH
+
+        config KMC_PARTNER_AVAILABLE_OFF
+        bool "OFF:ICE AVAILABLE STATUS Support"
+        default n
+
+        config KMC_ICE_CHK_MOD_DEB
+        bool "ice check at module debug"
+        default n
+        depends on KMC_MODULE_AUTO && !KMC_PARTNER_AVAILABLE_OFF
+
+        config KMC_PARTNER_VIRTUAL_ICE_OFF
+        bool "OFF:PARTNER Virtual ICE Support"
+        default n
+
+        config KMC_PARTNER_COLLECT_THREAD_OFF
+        bool "OFF:PARTNER THREAD COLLECTING"
+        default n
+
+        config KMC_TRACE_EXT_OFF
+        bool "OFF:PROCESS TRACE ENHANCE"
+        default n
+
+    endmenu
+
+endmenu
diff -Nur linux-2.6.28.orig/KMC/Makefile_kmc linux-2.6.28/KMC/Makefile_kmc
--- linux-2.6.28.orig/KMC/Makefile_kmc	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/Makefile_kmc	2009-11-26 13:54:53.000000000 +0900
@@ -0,0 +1,55 @@
+#
+# PARTNER-Jet Linux support patch by KMC
+#
+# Ver2.0	08.04.14
+# Ver2.01	08.07.22	support 2.6.25 and 2.6.26
+# Ver2.02	08.12.08	support 2.6.27
+#
+
+OVER24 = $(shell expr $(SUBLEVEL) ">"= 24)
+
+ifeq ($(OVER24),1)
+tmpCF = $(KBUILD_CFLAGS)
+else
+tmpCF = $(CFLAGS)
+endif
+
+ifdef CONFIG_DEB_NO_OPTIMIZE
+tmpCF := $(filter-out -O2,$(tmpCF))
+tmpCF := $(filter-out -Os,$(tmpCF))
+endif
+
+ifndef CONFIG_DEBINFO_NONE
+tmpCF := $(filter-out -g,$(tmpCF))
+tmpCF := $(filter-out -ggdb,$(tmpCF))
+ifdef CONFIG_DEBINFO_STAB
+tmpCF += -gstabs
+else
+ifdef CONFIG_DEBINFO_STABP
+tmpCF += -gstabs+
+else
+ifdef CONFIG_DEBINFO_DWARF
+tmpCF += -gdwarf
+else
+ifdef CONFIG_DEBINFO_DWARFP
+tmpCF += -gdwarf+
+else
+ifdef CONFIG_DEBINFO_DWARF2
+tmpCF += -gdwarf-2
+else
+tmpCF += -g
+endif
+endif
+endif
+endif
+endif
+endif
+
+tmpCF	+= -I$(TOPDIR)/KMC
+
+
+ifeq ($(OVER24),1)
+KBUILD_CFLAGS := $(tmpCF)
+else
+CFLAGS := $(tmpCF)
+endif
diff -Nur linux-2.6.28.orig/KMC/Rules_kmc.make linux-2.6.28/KMC/Rules_kmc.make
--- linux-2.6.28.orig/KMC/Rules_kmc.make	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/Rules_kmc.make	2009-11-26 13:54:53.000000000 +0900
@@ -0,0 +1,46 @@
+#
+# PARTNER-Jet Linux support patch by KMC
+#
+# Ver2.0	08.04.14
+#
+
+ifeq ($(PATCHLEVEL),6)
+
+__KMC_MODULE_NAME = -D__KMC_OBJ_NAME=\"$(subst $(comma),_,/$(@D)/$(*F).ko)\"
+
+TEST_SUBLEVEL	=	`expr $(SUBLEVEL) \\>= 24`
+
+ifeq ($(TEST_SUBLEVEL),1)
+__KMC_TEMP_CFLAGS		:= $(ccflags-y)
+ccflags-y			=
+ccflags-y			= $(__KMC_MODULE_NAME)
+ccflags-y			+= $(__KMC_TEMP_CFLAGS)
+else
+__KMC_TEMP_CFLAGS		:= $(EXTRA_CFLAGS)
+EXTRA_CFLAGS			=
+EXTRA_CFLAGS			= $(__KMC_MODULE_NAME)
+EXTRA_CFLAGS			+= $(__KMC_TEMP_CFLAGS)
+endif
+
+else
+
+ifdef EXTRA_CFLAGS_nostdinc
+%.o: %.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS_nostdinc) -DKBUILD_BASENAME=$(subst $(comma),_,$(subst -,_,$(*F))) -D__KMC_OBJ_NAME=\"$(subst $(TOPDIR),,$(shell pwd)/$(@F))\" $(CFLAGS_$@) -c -o $@ $<
+	@ ( \
+	    echo 'ifeq ($(strip $(subst $(comma),:,$(CFLAGS) $(EXTRA_CFLAGS_nostdinc) $(CFLAGS_$@))),$$(strip $$(subst $$(comma),:,$$(CFLAGS) $$(EXTRA_CFLAGS_nostdinc) $$(CFLAGS_$@))))' ; \
+	    echo 'FILES_FLAGS_UP_TO_DATE += $@' ; \
+	    echo 'endif' \
+	) > $(dir $@)/.$(notdir $@).flags
+else
+%.o: %.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -DKBUILD_BASENAME=$(subst $(comma),_,$(subst -,_,$(*F))) -D__KMC_OBJ_NAME=\"$(subst $(TOPDIR),,$(shell pwd)/$(@F))\" $(CFLAGS_$@) -c -o $@ $<
+	@ ( \
+	    echo 'ifeq ($(strip $(subst $(comma),:,$(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$@))),$$(strip $$(subst $$(comma),:,$$(CFLAGS) $$(EXTRA_CFLAGS) -D__KMC_OBJ_NAME=\"$(subst $(TOPDIR),,$(shell pwd)/$(@F))\" $$(CFLAGS_$@))))' ; \
+	    echo 'FILES_FLAGS_UP_TO_DATE += $@' ; \
+	    echo 'endif' \
+	) > $(dir $@)/.$(notdir $@).flags
+endif
+
+endif
+
diff -Nur linux-2.6.28.orig/KMC/__brk_code.h linux-2.6.28/KMC/__brk_code.h
--- linux-2.6.28.orig/KMC/__brk_code.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/__brk_code.h	2009-11-26 14:11:06.000000000 +0900
@@ -0,0 +1,45 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * A definition of S/W break-point instruction
+ *
+ * Ver2.0	08.04.14
+ *
+ */
+
+#ifndef __BRK_CODE_H__
+#define __BRK_CODE_H__
+
+
+#ifdef CONFIG_ARM
+ #if defined(CONFIG_CPU_V6) || defined(CONFIG_CPU_V7)
+  #define	__KMC_BRK_CODE()	asm("	.long	0xe1200070")
+ #else
+  #define	__KMC_BRK_CODE()	asm("	.long	0xdeeedeee")
+ #endif
+#endif
+
+#ifdef CONFIG_MIPS
+ #if defined(CONFIG_CPU_TX49XX)
+  #define	__KMC_BRK_CODE()	asm("	.long	0x0000000e")
+ #else
+  #define	__KMC_BRK_CODE()	asm("	.long	0x7000003f")
+ #endif
+#endif
+
+#ifdef CONFIG_CPU_SH4
+ #define	__KMC_BRK_CODE()	asm("	.long	0x003b003b")
+#endif
+#ifdef CONFIG_CPU_SH3
+ #define	__KMC_BRK_CODE()	asm("	.long	0x00000000")
+#endif
+
+#ifdef CONFIG_MN10300
+ #define	__KMC_BRK_CODE()	asm("	.long	0xffffffff")
+#endif
+
+#ifndef __KMC_BRK_CODE
+ #error	!! __KMC_BRK_CODE is not defined !!
+#endif
+
+#endif
diff -Nur linux-2.6.28.orig/KMC/config_kmc.in linux-2.6.28/KMC/config_kmc.in
--- linux-2.6.28.orig/KMC/config_kmc.in	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/config_kmc.in	2009-11-26 13:54:53.000000000 +0900
@@ -0,0 +1,54 @@
+#
+# PARTNER-Jet Linux support patch by KMC
+#
+
+mainmenu_option next_comment
+
+comment 'PARTNER Debugging'
+   choice 'Debug information type'                              \
+   "NONE                CONFIG_DEBINFO_NONE                     \
+   STAB                 CONFIG_DEBINFO_STAB                     \
+   extendedSTAB         CONFIG_DEBINFO_STABP                    \
+   DWARF-1              CONFIG_DEBINFO_DWARF                    \
+   extenedDWARF-1       CONFIG_DEBINFO_DWARFP                   \
+   DWARF-2              CONFIG_DEBINFO_DWARF2" NONE
+
+   bool 'Enable patch for PARTNER debug' CONFIG_KMC_PATCH
+
+   if [ "$CONFIG_KMC_PATCH" = "y" ]; then
+
+
+      bool '  Loadable module auto attach' CONFIG_KMC_MODULE_AUTO
+
+      bool '  use PARTNER GigaTrace(PARTNER-Jet M40, ...)' CONFIG_KMC_USE_BT
+      if [ "$CONFIG_KMC_USE_BT" = "y" ]; then
+        bool '    use CPU Data Trace' CONFIG_KMC_USE_BT_DATATRACE $CONFIG_KMC_USE_BT
+      fi
+
+      bool '  enable PARNTER-Jet Event Tracker' CONFIG_KMC_EVENTTRACKER_SUPPORT
+      if [ "$CONFIG_KMC_EVENTTRACKER_SUPPORT" = "y" ]; then
+        if [ "$CONFIG_KMC_USE_BT" = "y" ]; then
+	  bool '    event data is only from CPUs trace' CONFIG_KMC_EVENTTRACKER_RTM
+	fi
+        if [ "$CONFIG_KMC_EVENTTRACKER_RTM" != "y" -o \
+	     "$CONFIG_KMC_USE_BT" != "y" ]; then
+          int '    max event count (x1024, set is 1, 2, 4, 8, 16, 32, 64, .....)' CONFIG_KMC_EVENTTRACKER_LOG_SIZE 4
+	fi
+      fi
+
+      mainmenu_option next_comment
+      comment 'PARTNER Extend menu'
+         bool 'OFF:ICE AVAILABLE STATUS Support' CONFIG_KMC_PARTNER_AVAILABLE_OFF
+         if [ "$CONFIG_KMC_MODULE_AUTO" = "y" -a "$CONFIG_KMC_PARTNER_AVAILABLE_OFF" = "n" ]; then
+            bool 'ice check at module debug' CONFIG_KMC_ICE_CHK_MOD_DEB
+         fi
+         bool 'OFF:PARTNER Virtual ICE Support' CONFIG_KMC_PARTNER_VIRTUAL_ICE_OFF
+         bool 'OFF:PARTNER THREAD COLLECTING' CONFIG_KMC_PARTNER_COLLECT_THREAD_OFF
+         bool 'OFF:PROCESS TRACE ENHANCE' CONFIG_KMC_TRACE_EXT_OFF
+      endmenu
+
+
+   fi
+
+endmenu
+
diff -Nur linux-2.6.28.orig/KMC/kmc-support.c linux-2.6.28/KMC/kmc-support.c
--- linux-2.6.28.orig/KMC/kmc-support.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/kmc-support.c	2009-11-26 13:54:53.000000000 +0900
@@ -0,0 +1,546 @@
+/*
+ * KMC PARTNER debug support file
+ */
+
+#include <asm/unistd.h>
+#include <stdlib.h>
+
+#define __val0(x)	#x
+#define __val1(x)	__val0(x)
+
+#if defined(__arm__)
+
+#if defined(__ARM_EABI__)			/* add 07.02.07 support eabi */
+ #define        __BL_SCHED_YIELD()                                      \
+		__asm__("       mov     r7,#" __val1(__NR_sched_yield));        \
+		__asm__("       swi     0")
+ #define        __BL_GETTID()                                           \
+		__asm__("       mov     r7,#" __val1(__NR_gettid));     \
+		__asm__("       swi     0")
+#else
+ #define	__BL_SCHED_YIELD()					\
+			__asm__("	swi	" __val1(__NR_sched_yield))
+ #define	__BL_GETTID()						\
+			__asm__("	swi	" __val1(__NR_gettid))
+#endif	// __ARM_EABI__
+
+
+
+// Select CPU type define
+//#define CPUTYPE_ARM11
+//#define CPUTYPE_ARM9
+//#define CPUTYPE_ARM7
+
+ #if defined(CPUTYPE_ARM11)
+  #define	__KMC_BRK_CODE__()	__asm__("	.long	0xe1200070")
+ #elif defined(CPUTYPE_ARM9) || defined(CPUTYPE_ARM7)
+  #define	__KMC_BRK_CODE__()	__asm__("	.long	0xdeeedeee")
+ #else
+  #error "Select Target CPU type"
+ #endif
+
+
+ #define	__KMC_ALIGN()		__asm__("	.align	4")
+ #define	__KMC_NOAT()
+
+ #define	__KMC_SLEEP_THREAD()					\
+	__asm__("	b	___ksup_sleep_thread");			\
+	__asm__("	b	___ksup_mem_hit");			\
+	__asm__("	b  	__kmc_start_debuger");			\
+	__asm__("	.long	0x014c434d")
+
+ #define	__KSUP_SLEEP_THREAD()					\
+	__asm__("	stmfd	sp!, {r0-r12,r14}");			\
+	__asm__("	mrs	r0,cpsr");				\
+	__asm__("	stmfd	sp!, {r0}");				\
+	__asm__(".L4_arm:");						\
+	__BL_SCHED_YIELD();						\
+	__BL_GETTID();							\
+	__asm__("	cmp	r4, r0");				\
+	__asm__("	bne	.L4_arm");				\
+	__asm__("	ldmfd	sp!, {r0}");				\
+	__asm__("	msr	cpsr, r0");				\
+	__asm__("	ldmfd	sp!, {r0-r12,r14}");			\
+	__asm__("	b	___ksup_sleep_thread_brk")
+
+ #define	__KSUP_MEM_HIT()					\
+	__asm__("	ldrb	r0, [r0, #0]");				\
+	__asm__("	b	___ksup_sleep_thread_brk")
+
+ #define	__KMC_START_DEBUGER()					\
+	__asm__("	stmfd	sp!, {r0, lr}");			\
+	__asm__("	bl	getpid");				\
+	__asm__("	ldmfd	sp!, {r1, lr}");			\
+	__asm__("	ldr	r2, .start");				\
+	__asm__("	b	___ksup_start_debuger_brk")
+
+#ifndef __KMC_STATIC_SUPPORT
+ #define	__KMC_START()						\
+	__asm__("	.align	4");					\
+	__asm__(".start:");						\
+	__asm__("	.long	0x0000849c")
+#else
+ #define	__KMC_START()						\
+	__asm__("	.align	4");					\
+	__asm__(".start:");						\
+	__asm__("	.long	_start")
+#endif
+
+
+
+#elif defined(__mips__)
+
+ #define	__BL_SCHED_YIELD()					\
+		__asm__("	li	$2,"__val1(__NR_sched_yield));	\
+		__asm__("	syscall")
+ #define	__BL_GETTID()						\
+		__asm__("	li	$2,"__val1(__NR_gettid));	\
+		__asm__("	syscall")
+
+// Select CPU type define
+//#define CPUTYPE_TX49XX
+
+ #if defined(CPUTYPE_TX49XX)
+  #define	__KMC_BRK_CODE__()	__asm__("	.long	0x0000000e")
+ #else
+  #define	__KMC_BRK_CODE__()	__asm__("	.long	0x7000003f")
+ #endif
+
+ #define	__KMC_ALIGN()		__asm__("	.align	2")
+ #define	__KMC_NOAT()		__asm__("	.set	noat")
+
+
+ #define	__KMC_SLEEP_THREAD()					\
+	__asm__("	b	___ksup_sleep_thread");			\
+	__asm__("	nop");						\
+	__asm__("	b	___ksup_mem_hit");			\
+	__asm__("	nop");						\
+	__asm__("	b  	__kmc_start_debuger");			\
+	__asm__("	nop");						\
+	__asm__("	.long	0x014c434d")
+
+ #define	__KSUP_SLEEP_THREAD()					\
+	__asm__("	addiu	$sp,$sp,-0x90");			\
+	__asm__("	sw	$1,0x4($sp)");				\
+	__asm__("	sw	$2,0x8($sp)");				\
+	__asm__("	sw	$3,0xc($sp)");				\
+	__asm__("	sw	$4,0x10($sp)");				\
+	__asm__("	sw	$5,0x14($sp)");				\
+	__asm__("	sw	$6,0x18($sp)");				\
+	__asm__("	sw	$7,0x1c($sp)");				\
+	__asm__("	sw	$8,0x20($sp)");				\
+	__asm__("	sw	$9,0x24($sp)");				\
+	__asm__("	sw	$10,0x28($sp)");			\
+	__asm__("	sw	$11,0x2c($sp)");			\
+	__asm__("	sw	$12,0x30($sp)");			\
+	__asm__("	sw	$13,0x34($sp)");			\
+	__asm__("	sw	$14,0x38($sp)");			\
+	__asm__("	sw	$15,0x3c($sp)");			\
+	__asm__("	sw	$16,0x40($sp)");			\
+	__asm__("	sw	$17,0x44($sp)");			\
+	__asm__("	sw	$18,0x48($sp)");			\
+	__asm__("	sw	$19,0x4c($sp)");			\
+	__asm__("	sw	$20,0x50($sp)");			\
+	__asm__("	sw	$21,0x54($sp)");			\
+	__asm__("	sw	$22,0x58($sp)");			\
+	__asm__("	sw	$23,0x5c($sp)");			\
+	__asm__("	sw	$24,0x60($sp)");			\
+	__asm__("	sw	$25,0x64($sp)");			\
+	__asm__("	sw	$26,0x68($sp)");			\
+	__asm__("	sw	$27,0x6c($sp)");			\
+	__asm__("	sw	$28,0x70($sp)");			\
+	__asm__("	sw	$30,0x74($sp)");			\
+	__asm__("	sw	$31,0x78($sp)");			\
+	__asm__("	mfhi	$1");					\
+	__asm__("	sw	$1,0x7c($sp)");				\
+	__asm__("	mflo	$1");					\
+	__asm__("	sw	$1,0x80($sp)");				\
+	__asm__(".L4_mips:");						\
+	__BL_SCHED_YIELD();						\
+	__BL_GETTID();							\
+	__asm__("	bne	$4,$2,.L4_mips");			\
+	__asm__("	nop");						\
+	__asm__("	lw	$2,0x8($sp)");				\
+	__asm__("	lw	$3,0xc($sp)");				\
+	__asm__("	lw	$4,0x10($sp)");				\
+	__asm__("	lw	$5,0x14($sp)");				\
+	__asm__("	lw	$6,0x18($sp)");				\
+	__asm__("	lw	$7,0x1c($sp)");				\
+	__asm__("	lw	$8,0x20($sp)");				\
+	__asm__("	lw	$9,0x24($sp)");				\
+	__asm__("	lw	$10,0x28($sp)");			\
+	__asm__("	lw	$11,0x2c($sp)");			\
+	__asm__("	lw	$12,0x30($sp)");			\
+	__asm__("	lw	$13,0x34($sp)");			\
+	__asm__("	lw	$14,0x38($sp)");			\
+	__asm__("	lw	$15,0x3c($sp)");			\
+	__asm__("	lw	$16,0x40($sp)");			\
+	__asm__("	lw	$17,0x44($sp)");			\
+	__asm__("	lw	$18,0x48($sp)");			\
+	__asm__("	lw	$19,0x4c($sp)");			\
+	__asm__("	lw	$20,0x50($sp)");			\
+	__asm__("	lw	$21,0x54($sp)");			\
+	__asm__("	lw	$22,0x58($sp)");			\
+	__asm__("	lw	$23,0x5c($sp)");			\
+	__asm__("	lw	$24,0x60($sp)");			\
+	__asm__("	lw	$25,0x64($sp)");			\
+	__asm__("	lw	$26,0x68($sp)");			\
+	__asm__("	lw	$27,0x6c($sp)");			\
+	__asm__("	lw	$28,0x70($sp)");			\
+	__asm__("	lw	$30,0x74($sp)");			\
+	__asm__("	lw	$31,0x78($sp)");			\
+	__asm__("	lw	$1,0x7c($sp)");				\
+	__asm__("	mthi	$1");					\
+	__asm__("	lw	$1,0x80($sp)");				\
+	__asm__("	mtlo	$1");					\
+	__asm__("	lw	$1,0x4($sp)");				\
+	__asm__("	addiu	$sp,$sp,0x90");				\
+	__asm__("	beq	$0,$0,___ksup_sleep_thread_brk");	\
+	__asm__("	nop")
+
+ #define	__KSUP_MEM_HIT()					\
+	__asm__("	lb	$1,0($1)");				\
+	__asm__("	beq	$0,$0,___ksup_sleep_thread_brk");	\
+	__asm__("	nop")
+
+ #define	__KMC_START_DEBUGER()					\
+	__asm__("	beq	$0,$0,___ksup_start_debuger_brk");	\
+	__asm__("	nop")
+
+ #define	__KMC_START()
+
+
+#elif defined(__sh__)
+
+ #define	__BL_SCHED_YIELD()					\
+	__asm__("	mov	#" __val1(__NR_sched_yield) ",r3");	\
+	__asm__("	extu.b	r3,r3");				\
+	__asm__("	trapa	#0x10")
+ #define	__BL_GETTID()						\
+	__asm__("	mov	#" __val1(__NR_gettid) ",r3");		\
+	__asm__("	extu.b	r3,r3");				\
+	__asm__("	trapa	#0x10");				\
+
+
+// Select CPU type define
+//#define CPUTYPE_SH4
+//#define CPUTYPE_SH3
+
+
+#if defined(__sh4__) || defined(CPUTYPE_SH4)
+ #define	__KMC_BRK_CODE__()	__asm__("	.long	0x003b003b")
+#elif defined(__sh3__) || defined(CPUTYPE_SH3)
+ #define	__KMC_BRK_CODE__()	__asm__("	.long	0x00000000")
+#else
+ #error	"unkown CPU"
+#endif
+ #define	__KMC_ALIGN()		__asm__("	.align	2")
+ #define	__KMC_NOAT()
+
+ #define	__KMC_SLEEP_THREAD()					\
+	__asm__("	bra	___ksup_sleep_thread");			\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	bra	___ksup_mem_hit");			\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	bra	__kmc_start_debuger");			\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	.long	0x014c434d")
+
+ #define	__KSUP_SLEEP_THREAD()					\
+	__asm__("	mov.l	r0,@-r15");				\
+	__asm__("	mov.l	r1,@-r15");				\
+	__asm__("	mov.l	r2,@-r15");				\
+	__asm__("	mov.l	r3,@-r15");				\
+	__asm__("	mov.l	r4,@-r15");				\
+	__asm__("	mov.l	r5,@-r15");				\
+	__asm__("	mov.l	r6,@-r15");				\
+	__asm__("	mov.l	r7,@-r15");				\
+	__asm__("	mov.l	r8,@-r15");				\
+	__asm__("	mov.l	r9,@-r15");				\
+	__asm__("	mov.l	r10,@-r15");				\
+	__asm__("	mov.l	r11,@-r15");				\
+	__asm__("	mov.l	r12,@-r15");				\
+	__asm__("	mov.l	r13,@-r15");				\
+	__asm__("	mov.l	r14,@-r15");				\
+	__asm__("	sts.l	pr,@-r15");				\
+	__asm__("	sts.l	macl,@-r15");				\
+	__asm__("	sts.l	mach,@-r15");				\
+	__asm__(".L4_sh:");						\
+	__BL_SCHED_YIELD();						\
+	__BL_GETTID();							\
+	__asm__("	cmp/eq	r4,r0");				\
+	__asm__("	bf	.L4_sh");				\
+	__asm__("	nop");						\
+	__asm__("	lds.l	@r15+,mach");				\
+	__asm__("	lds.l	@r15+,macl");				\
+	__asm__("	lds.l	@r15+,pr");				\
+	__asm__("	mov.l	@r15+,r14");				\
+	__asm__("	mov.l	@r15+,r13");				\
+	__asm__("	mov.l	@r15+,r12");				\
+	__asm__("	mov.l	@r15+,r11");				\
+	__asm__("	mov.l	@r15+,r10");				\
+	__asm__("	mov.l	@r15+,r9");				\
+	__asm__("	mov.l	@r15+,r8");				\
+	__asm__("	mov.l	@r15+,r7");				\
+	__asm__("	mov.l	@r15+,r6");				\
+	__asm__("	mov.l	@r15+,r5");				\
+	__asm__("	mov.l	@r15+,r4");				\
+	__asm__("	mov.l	@r15+,r3");				\
+	__asm__("	mov.l	@r15+,r2");				\
+	__asm__("	mov.l	@r15+,r1");				\
+	__asm__("	mov.l	@r15+,r0");				\
+	__asm__("	bra	___ksup_sleep_thread_brk");		\
+	__asm__("	nop")
+
+ #define	__KSUP_MEM_HIT()					\
+	__asm__("	mov.b	@r8,r9");				\
+	__asm__("	bra	___ksup_sleep_thread_brk");		\
+	__asm__("	nop")
+
+ #define	__KMC_START_DEBUGER()					\
+	__asm__("	mov.l	.start,r6");				\
+	__asm__("	bra	___ksup_start_debuger_brk");		\
+	__asm__("	nop")
+
+#ifndef __KMC_STATIC_SUPPORT
+ #define	__KMC_START()						\
+	__asm__("	.align	2");					\
+	__asm__(".start:");						\
+	__asm__("	.long	0x0000849c")
+#else
+ #define	__KMC_START()						\
+	__asm__("	.align	2");					\
+	__asm__(".start:");						\
+	__asm__("	.long	_start")
+#endif
+
+
+#elif defined(__mn10300__)
+
+ #define	__BL_SCHED_YIELD()					\
+	__asm__("	mov	" __val1(__NR_sched_yield) ",d0");	\
+	__asm__("	syscall 0")
+ #define	__BL_GETTID()						\
+	__asm__("	mov	" __val1(__NR_gettid) ",d0");		\
+	__asm__("	syscall 0")
+
+
+ #define	__KMC_BRK_CODE__()	__asm__("	.long	0xffffffff")
+ #define	__KMC_ALIGN()		__asm__("	.align	2")
+ #define	__KMC_NOAT()
+
+ #define	__KMC_SLEEP_THREAD()					\
+	__asm__("	jmp ___ksup_sleep_thread");			\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	jmp ___ksup_mem_hit");				\
+	__asm__("	nop");						\
+	__asm__("	nop")
+
+ #define	__KSUP_SLEEP_THREAD()					\
+	__asm__("	movm	[d2,d3,a2,a3,other,exreg0,exreg1,exother],(sp)");	\
+	__asm__(".L4_mn103:");						\
+	__BL_SCHED_YIELD();						\
+	__BL_GETTID();							\
+	__asm__("	cmp	d0,d3");				\
+	__asm__("	bne	.L4_mn103");				\
+	__asm__("	movm	(sp),[d2,d3,a2,a3,other,exreg0,exreg1,exother]");	\
+	__asm__("	jmp	___ksup_sleep_thread_brk")
+
+ #define	__KSUP_MEM_HIT()					\
+	__asm__("	movbu	(a0),d0");				\
+	__asm__("	jmp	___ksup_sleep_thread_brk")
+
+ #define	__KMC_START_DEBUGER()					\
+	__asm__("	mov	(.start),d2");				\
+	__asm__("	jmp	___ksup_start_debuger_brk")
+
+#ifndef __KMC_STATIC_SUPPORT
+ #define	__KMC_START()						\
+	__asm__("	.align	2");					\
+	__asm__(".start:");						\
+	__asm__("	.long	0x0000849c")
+#else
+ #define	__KMC_START()						\
+	__asm__("	.align	2");					\
+	__asm__(".start:");						\
+	__asm__("	.long	_start")
+#endif
+
+#else
+
+ #define	__KMC_BRK_CODE__()
+ #define	__KMC_ALIGN()
+ #define	__KMC_NOAT()
+
+ #define	__KMC_SLEEP_THREAD()
+ #define	__KSUP_SLEEP_THREAD()
+ #define	__KSUP_MEM_HIT()
+ #define	__KMC_START_DEBUGER()
+ #define	__KMC_START()
+
+ #error "not support CPU"
+#endif
+
+#ifdef CONFIG_NO_USER_PATCH
+__asm__("	.globl	__kmc_sup_start");
+__asm__("	.equ	__kmc_sup_start, __kmc_user_debug_end");
+
+__asm__("	.globl	__kmc_sup_size");
+__asm__("	.equ	__kmc_sup_size, __kmc_user_debug_end + 4");
+
+__asm__("	.globl	__kmc_sleep_thr_offs");
+__asm__("	.equ	__kmc_sleep_thr_offs, __kmc_user_debug_end + 8");
+#endif
+
+__asm__("	.text");
+__KMC_ALIGN();
+
+#ifdef CONFIG_NO_USER_PATCH
+__asm__("__kmc_user_debug:");
+#endif
+
+__asm__("	.long	0x4c434d02");	// magic code 'KMC' + function no
+
+__asm__("___ksup_start_debuger_brk:");
+__KMC_BRK_CODE__();			// r0.. pid , r1.. arg[0](app filename)
+__asm__("	.long	0x4c434d01");	// magic code 'KMC' + function no
+
+__asm__("___ksup_sleep_thread_brk:");
+__KMC_BRK_CODE__();			// r0.. pid , r1.. arg[0](app filename)
+__asm__("	.long	0x4c434d00");	// magic code 'KMC' + function no
+
+__KMC_NOAT();
+__asm__("	.global	__kmc_sleep_thread");
+__asm__("__kmc_sleep_thread:");
+__KMC_SLEEP_THREAD();
+
+__asm__("___ksup_sleep_thread:");
+__KSUP_SLEEP_THREAD();
+
+
+__asm__("___ksup_mem_hit:");
+__KSUP_MEM_HIT();
+
+#ifndef	__KMC_DYNAMIC_SUPPORT
+__asm__("	.global	__kmc_start_debuger");
+#endif
+__asm__("__kmc_start_debuger:");
+__KMC_START_DEBUGER();
+
+
+__KMC_START();
+
+
+#ifdef CONFIG_NO_USER_PATCH
+__asm__("__kmc_user_debug_end:");
+__asm__("	.long	__kmc_user_debug");	/* kmcsup code start address */
+__asm__("	.long	__kmc_user_debug_end - __kmc_user_debug"); /* kmcsup code size */
+__asm__("	.long	__kmc_sleep_thread - __kmc_user_debug"); /* __kmc_sleep_thread offset */
+__asm__("");
+#endif
+
+extern void __kmc_start_debuger(char *);
+
+void __kmc_start(char *appname)
+{
+    __kmc_start_debuger(appname);
+}
+
+#ifdef	__KMC_DYNAMIC_SUPPORT
+
+#include	<dlfcn.h>
+#include	<errno.h>
+#include	<pthread.h>
+
+#ifndef	RTLD_NEXT
+#define	RTLD_NEXT	((void *) -1l)
+#endif
+
+static volatile (*__kmc_ice_hook_thread)(char *) = 0;
+
+typedef struct {
+    void	*(*start_routine)(void *);
+    void	*__restrict arg;
+} __kmc_pthread_create;
+
+static int __kmc_thread_init = 0;
+static int (*__kmc_pthread_create_org)(pthread_t *, const pthread_attr_t *, void *(*)(void *), void *);
+
+void *__kmc_pthread_entry(void *arg)
+{
+    __kmc_pthread_create	*pthread_func = (__kmc_pthread_create *)arg;
+    void *ret;
+
+    {
+    	if (__kmc_ice_hook_thread) {
+      	    __kmc_ice_hook_thread(NULL);
+    	}
+    }
+
+    ret = pthread_func->start_routine(pthread_func->arg);
+    free(pthread_func);
+    return ret;
+}
+
+int pthread_create (pthread_t *__restrict __threadp,
+                           __const pthread_attr_t *__restrict __attr,
+                           void *(*__start_routine) (void *),
+                           void *__restrict __arg)
+{
+    __kmc_pthread_create	*pthread_func;
+
+    if (0 == __kmc_thread_init) {
+	__kmc_pthread_create_org = dlsym(RTLD_NEXT, "pthread_create");
+	if (NULL == __kmc_pthread_create_org) {
+	    return ENOMEM;
+	}
+	__kmc_thread_init = 1;
+    }
+
+    pthread_func = (__kmc_pthread_create *)malloc(sizeof(__kmc_pthread_create));
+    if (NULL == pthread_func) {
+	return ENOMEM;
+    }
+    pthread_func->start_routine = __start_routine;
+    pthread_func->arg = __arg;
+
+    return __kmc_pthread_create_org(__threadp, __attr, __kmc_pthread_entry, pthread_func);
+}
+
+static int __kmc_fork_init = 0;
+static int (*__kmc_fork_org)(void);
+
+int fork(void)
+{
+    int	ret;
+
+    if (0 == __kmc_fork_init) {
+	__kmc_fork_org = dlsym(RTLD_NEXT, "fork");
+	if (NULL == __kmc_fork_org) {
+	    return ENOMEM;
+	}
+	__kmc_fork_init = 1;
+    }
+
+    ret = __kmc_fork_org();
+
+    if (0 == ret) {
+	if (__kmc_ice_hook_thread) {
+      	    __kmc_ice_hook_thread(NULL);
+	}
+    }
+
+    return ret;
+}
+
+
+
+#endif	//__KMC_DYNAMIC_SUPPORT
+
diff -Nur linux-2.6.28.orig/KMC/kmc.c linux-2.6.28/KMC/kmc.c
--- linux-2.6.28.orig/KMC/kmc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/kmc.c	2009-11-26 17:00:49.000000000 +0900
@@ -0,0 +1,600 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * 2007.02.08 BUGFIX for Application-Mode Debug
+ * __kmc_sys_getpidi() and __kmc_do_exit(), changed Label to function
+ * 2007.04.20 change module debug(The addition of the new method)
+ * 2007.10.01 support SMP
+ * 2007.10.19 support Process Trace
+ * 2008.03.10 support PARTNER-Jet M40 & EventTracker
+ * Ver2.0	08.04.14
+ * 2008.07.02 support delayed attach
+ */
+
+#include "kmc.h"
+
+#ifdef CONFIG_KMC_PATCH
+
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT 
+
+#include <linux/spinlock.h>
+#include <linux/version.h>
+
+#define KMC_LINUX_EVENTLOG_VERSION	(0x00000002)
+
+#ifdef CONFIG_KMC_EVENTTRACKER_RTM
+#define	KMC_LINUX_EVENTLOG_MAXLOG	0
+#else
+#define KMC_LINUX_EVENTLOG_MAXLOG	(CONFIG_KMC_EVENTTRACKER_LOG_SIZE * 1024)	// must be 2^n
+#endif
+#define KMC_LINUX_EVENTLOG_MAXPNAME	(1024)
+#define KMC_LINUX_EVENTLOG_MAXPNAMELENGTH	(32)
+#define	KMC_LINUX_EVENTLOG_MAXTHREADINFO	(1024)	// must be 2^n
+
+typedef struct {
+	u64 evtTime;
+	int evtId;
+	int evtPid;
+	int evtParam;
+#ifdef CONFIG_SMP
+	int cpuId;
+#endif
+} T_KMC_LINUX_EVENTLOG;
+
+typedef struct {
+	int	pid;
+	char	name[KMC_LINUX_EVENTLOG_MAXPNAMELENGTH];
+} T_KMC_LINUX_PNAME;
+
+typedef struct {
+	unsigned short	thid;
+	unsigned short	pid;
+} T_KMC_LINUX_THINFO;
+
+typedef struct {
+	int	version;
+	int	ticks_per_10msec;
+
+	/* EventLog Info. */
+	int	log_offset;
+	int	log_max;
+	int	log_size;
+	int	log_index;
+
+	/* Process Name Table */
+	int	pname_offset;
+	int	pname_max;
+	int	pname_size;
+	int	pname_index;
+
+	/* Thread Info Table */
+	int	thinfo_offset;
+	int	thinfo_max;
+	int	thinfo_size;
+	int	thinfo_index;
+
+	/* EventLog */
+	T_KMC_LINUX_EVENTLOG	log[KMC_LINUX_EVENTLOG_MAXLOG];
+
+	/* Process Name Table */
+	T_KMC_LINUX_PNAME	pname[KMC_LINUX_EVENTLOG_MAXPNAME];
+
+	/* Thread Info Table */
+	T_KMC_LINUX_THINFO	thinfo[KMC_LINUX_EVENTLOG_MAXPNAME];
+} T_KMC_LINUX_LOGAREA;
+
+static spinlock_t __kmc_linux_event_lock = SPIN_LOCK_UNLOCKED;
+
+T_KMC_LINUX_LOGAREA	*__kmc_linux_event_data = NULL;
+unsigned long		__kmc_linux_event_data_size = sizeof(T_KMC_LINUX_LOGAREA);
+int __kmc_linux_event_errcount;
+
+#include <linux/vmalloc.h>
+
+void __kmc_linux_event_log_init(void)
+{
+#ifdef CONFIG_SMP
+	unsigned long flags;
+	spin_lock_irqsave(&__kmc_linux_event_lock, flags);
+	if (!__kmc_linux_event_data) {
+#endif
+
+	__kmc_linux_event_data = vmalloc(sizeof(T_KMC_LINUX_LOGAREA));
+	if (__kmc_linux_event_data) {
+		memset(__kmc_linux_event_data, 0, sizeof(T_KMC_LINUX_LOGAREA));
+		__kmc_linux_event_data->version = KMC_LINUX_EVENTLOG_VERSION;
+#ifdef CONFIG_MACH_MX3KZ
+		__kmc_linux_event_data->ticks_per_10msec = 105472;		/* LATCH */
+#else
+#ifdef CONFIG_HZ
+		__kmc_linux_event_data->ticks_per_10msec = CONFIG_HZ / 100;	/* jiffies */
+#else
+		__kmc_linux_event_data->ticks_per_10msec = 10;			/* jiffies */
+#endif
+#endif
+		__kmc_linux_event_data->log_offset 	= (int)&__kmc_linux_event_data->log[0] - (int)&__kmc_linux_event_data->version;
+		__kmc_linux_event_data->log_max		= KMC_LINUX_EVENTLOG_MAXLOG;
+		__kmc_linux_event_data->log_size	= (int)&__kmc_linux_event_data->log[1] - (int)&__kmc_linux_event_data->log[0];
+#ifdef CONFIG_KMC_EVENTTRACKER_RTM
+		__kmc_linux_event_data->log_index	= 1;
+#endif
+		__kmc_linux_event_data->pname_offset	= (int)&__kmc_linux_event_data->pname[0] - (int)&__kmc_linux_event_data->version;
+		__kmc_linux_event_data->pname_max	= KMC_LINUX_EVENTLOG_MAXPNAME;
+		__kmc_linux_event_data->pname_size	= (int)&__kmc_linux_event_data->pname[1] - (int)&__kmc_linux_event_data->pname[0];
+
+		__kmc_linux_event_data->thinfo_offset	= (int)&__kmc_linux_event_data->thinfo[0] - (int)&__kmc_linux_event_data->version;
+		__kmc_linux_event_data->thinfo_max	= KMC_LINUX_EVENTLOG_MAXTHREADINFO;
+		__kmc_linux_event_data->thinfo_size	= (int)&__kmc_linux_event_data->thinfo[1] - (int)&__kmc_linux_event_data->thinfo[0];
+	}
+
+#ifdef CONFIG_SMP
+	}
+	spin_unlock_irqrestore(&__kmc_linux_event_lock, flags);
+#endif
+
+	return;
+}
+
+#ifdef CONFIG_KMC_EVENTTRACKER_RTM
+void __kmc_linux_event_set_logI(int evtid, int pid, int param)
+{
+	if (!__kmc_linux_event_data) __kmc_linux_event_log_init();
+
+	if ((__kmc_linux_event_data)&&(evtid == KMC_LINUX_EVENTID_NEWTHREAD)) {
+		unsigned long flags;
+		int thindex;
+
+		spin_lock_irqsave(&__kmc_linux_event_lock, flags);
+		thindex = (__kmc_linux_event_data->thinfo_index++) & (KMC_LINUX_EVENTLOG_MAXTHREADINFO - 1);
+		spin_unlock_irqrestore(&__kmc_linux_event_lock, flags);
+		__kmc_linux_event_data->thinfo[thindex].thid = (unsigned short)pid;
+		__kmc_linux_event_data->thinfo[thindex].pid  = (unsigned short)param;
+	}
+}
+#else
+void __kmc_linux_event_set_logI(int evtid, int pid, int param)
+{
+	if (!__kmc_linux_event_data) __kmc_linux_event_log_init();
+
+	if (__kmc_linux_event_data) {
+		T_KMC_LINUX_EVENTLOG *pLog;
+		unsigned long flags;
+		int	index;
+		u64	evtTime;
+		int	thindex;
+
+		thindex = KMC_LINUX_EVENTLOG_MAXTHREADINFO;
+
+		spin_lock_irqsave(&__kmc_linux_event_lock, flags);
+
+#ifdef CONFIG_MACH_MX3KZ
+		evtTime = __raw_readl(MXC_GPT_GPTCNT);
+#else
+#if LINUX_VERSION_CODE >= 0x020600
+		evtTime = jiffies_64;
+#else
+		evtTime = jiffies;
+#endif
+#endif
+		index = (__kmc_linux_event_data->log_index++) & (KMC_LINUX_EVENTLOG_MAXLOG - 1);
+		if (evtid == KMC_LINUX_EVENTID_NEWTHREAD) {
+			thindex = (__kmc_linux_event_data->thinfo_index++) & (KMC_LINUX_EVENTLOG_MAXTHREADINFO - 1);
+		}
+
+		spin_unlock_irqrestore(&__kmc_linux_event_lock, flags);
+
+		pLog = &(__kmc_linux_event_data->log[index]);
+
+		pLog->evtTime = evtTime;
+		pLog->evtId = evtid;
+		pLog->evtPid = pid;
+		pLog->evtParam = param;
+#ifdef CONFIG_SMP
+		pLog->cpuId = smp_processor_id();
+#endif
+		if (thindex < KMC_LINUX_EVENTLOG_MAXTHREADINFO) {
+			__kmc_linux_event_data->thinfo[thindex].thid = (unsigned short)pid;
+			__kmc_linux_event_data->thinfo[thindex].pid  = (unsigned short)param;
+		}
+	}
+}
+#endif
+
+static int RegisterPname(int pid, const char *pname)
+{
+	int ret = -1;
+
+	if (!__kmc_linux_event_data) __kmc_linux_event_log_init();
+
+	if (__kmc_linux_event_data) {
+		int i;
+		unsigned long flags;
+
+		spin_lock_irqsave(&__kmc_linux_event_lock, flags);
+
+		//search slot
+		for (i = 0; i < KMC_LINUX_EVENTLOG_MAXPNAME; i++) {
+			int ppid = __kmc_linux_event_data->pname[i].pid;
+			if (ppid == 0) {
+				i = KMC_LINUX_EVENTLOG_MAXPNAME;
+				break;
+			} else if (ppid == pid) {
+				break;
+			}
+		}
+		if (i >= KMC_LINUX_EVENTLOG_MAXPNAME) {
+			// overwrite slot
+			i = __kmc_linux_event_data->pname_index++ & (KMC_LINUX_EVENTLOG_MAXPNAME - 1);
+			__kmc_linux_event_data->pname[i].pid = pid;
+		}
+
+		spin_unlock_irqrestore(&__kmc_linux_event_lock, flags);
+
+		strncpy(__kmc_linux_event_data->pname[i].name, pname, KMC_LINUX_EVENTLOG_MAXPNAMELENGTH-1);
+		ret = i;
+	}
+	return ret;
+}
+
+void __kmc_linux_event_set_logS(int evtid, int pid, const char* pname)
+{
+	__kmc_linux_event_set_logI(evtid, pid, RegisterPname(pid, pname));
+}
+
+void __kmc_linux_event_set_logT(int evtid, struct task_struct* t)
+{
+	__kmc_linux_event_set_logI(evtid, t->pid, 0);
+}
+
+asmlinkage void __kmc_event_post(int id, int param1, int param2)
+{
+	__kmc_linux_event_set_logI(id, param1, param2);
+}
+#endif 
+
+// Add 2007.02.08
+/* ########## kernel/exit.c { ########## */
+#ifdef noinline
+#undef noinline
+#define noinline	noinline
+#endif
+__attribute__ ((noinline))
+void __kmc_do_exit(void)
+{
+	__asm__("nop");
+
+}
+/* ########## kernel/exit.c } ########## */
+
+#ifdef CONFIG_KMC_PARTNER_COLLECT_THREAD_OFF /* { */
+struct task_struct *__kmc_tss_list[__KMC_MAX_PT_COUNT + 1];
+#else /* }{ !CONFIG_KMC_PARTNER_COLLECT_THREAD_OFF */
+struct task_struct *__kmc_tss_list_array[__KMC_MAX_PT_COUNT + 1][__KMC_MAX_THREAD_COUNT];
+#endif /* } CONFIG_KMC_PARTNER_COLLECT_THREAD_OFF */
+
+#ifndef CONFIG_KMC_PARTNER_VIRTUAL_ICE_OFF /* { */
+int __kmc_sys_getpid_flag;
+// Add 2007.02.08
+/* ########## kernel/timer.c { ########## */
+__attribute__ ((noinline))
+void __kmc_sys_getpid(void)
+{
+	__asm__("nop");
+}
+/* ########## kernel/timer.c } ########## */
+#endif /* } CONFIG_KMC_PARTNER_VIRTUAL_ICE_OFF */
+
+#ifdef CONFIG_KMC_LINUX_PROFILE
+#ifdef CONFIG_KMC_LINUX_ARMV6_EXT_PROFILE
+unsigned int    pid_err_count;
+
+static inline unsigned int jtag_com_stat11(void)
+{
+	unsigned int    stat;
+	__asm__("mrc p14,0,%0,c0,c1":"=r"(stat));
+	return stat;
+}
+
+static inline void jtag_com_put11(unsigned int data)
+{
+	__asm__("mcr p14,0,%0,c0,c5"::"r"(data));
+	return;
+}
+#endif
+#endif  // LINUX_PROFILE(ARM)
+
+/* ########## kernel/sched.c { ########## */
+#ifndef CONFIG_KMC_TRACE_EXT_OFF /* { */
+
+#ifdef CONFIG_SMP
+
+#define	CORE_SMP_NUMBER	CONFIG_NR_CPUS
+int __kmc_schedules_list_pid_smp[CORE_SMP_NUMBER][KMC_MAX_SHEDULE_LIST];
+int __kmc_schedules_index_smp[CORE_SMP_NUMBER];
+int __kmc_schedules_index_max=KMC_MAX_SHEDULE_LIST;
+
+#else
+
+int __kmc_schedules_index_max=KMC_MAX_SHEDULE_LIST;
+int __kmc_schedules_index;
+int __kmc_schedules_list_pid[KMC_MAX_SHEDULE_LIST];
+
+#endif
+
+#ifdef CONFIG_MN10300
+int __kmc_am33_trace=0;
+#endif	// CONFIG_MN10300
+
+#ifdef CONFIG_KMC_USE_BT
+int  __kmc_schedule_trace_point;
+void __kmc_code_data(int);
+#ifdef CONFIG_ARM
+#include	"kmc_dt_arm.c"
+#endif
+#ifdef  CONFIG_MIPS
+#include	"kmc_dt_mips.c"
+#endif
+#ifdef CONFIG_SUPERH
+#include	"kmc_dt_sh.c"
+#endif
+#ifdef CONFIG_MN10300
+#include	"kmc_dt_am33.c"
+#endif
+#endif	// CONFIG_KMC_USE_BT
+
+#ifdef CONFIG_KMC_USE_BT
+static spinlock_t __kmc_linux_schedule_lock = SPIN_LOCK_UNLOCKED;
+#endif
+void __kmc_schedule(struct task_struct *prev,struct task_struct *next)
+{
+    unsigned long flags;
+    int index_next;
+#ifdef CONFIG_KMC_LINUX_PROFILE
+#ifdef CONFIG_KMC_LINUX_ARMV6_EXT_PROFILE
+    int i = 200;
+#endif
+#endif
+#ifdef CONFIG_KMC_USE_BT
+    spin_lock_irqsave(&__kmc_linux_schedule_lock, flags);
+#endif
+#ifdef CONFIG_SMP
+    int	cpu;
+
+    cpu = smp_processor_id();
+    index_next=__kmc_schedules_index_smp[cpu] & (KMC_MAX_SHEDULE_LIST-1);
+    ++__kmc_schedules_index_smp[cpu];
+    __kmc_schedules_list_pid_smp[cpu][index_next]=next->pid;
+#else   // CONFIG_SMP
+	index_next=__kmc_schedules_index & (KMC_MAX_SHEDULE_LIST-1);
+	++__kmc_schedules_index;
+
+	#ifdef CONFIG_KMC_USE_BT
+		/* giga trace (P-Jet M40) mode */
+
+		#ifdef CONFIG_KMC_USR_BT_DATA_TRACE
+    			/* use Data Trace */
+    			__kmc_schedule_trace_point=__kmc_schedules_list_pid[index_next]=next->pid;
+		#else	// CONFIG_KMC_USR_BT_DATA_TRACE
+    			/* PC Trace Only */
+    			__kmc_code_data(__kmc_schedule_trace_point=__kmc_schedules_list_pid[index_next]=next->pid);
+		#endif	// CONFIG_KMC_USR_BT_DATA_TRACE
+
+	#else	// CONFIG_KMC_USE_BT
+		/* normal mode */
+		__kmc_schedules_list_pid[index_next]=next->pid;
+	#endif	// !CONFIG_KMC_USE_BT
+#endif	// CONFIG_SMP
+#ifdef CONFIG_MN10300
+	if(__kmc_am33_trace==7){
+		*(char *)(0xC00001C3) |= 0x01;
+	}
+#endif	// CONFIG_MN10300
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT
+    __kmc_linux_event_set_logI( KMC_LINUX_EVENTID_TASKSWITCH, prev->pid, next->pid );
+#endif	// CONFIG_KMC_EVENTTRACKER_SUPPORT
+
+#ifdef CONFIG_KMC_LINUX_PROFILE
+#ifdef CONFIG_KMC_LINUX_ARMV6_EXT_PROFILE
+    while (0 != (jtag_com_stat11() & 0x20000000) && i > 0) {
+	i--;
+    }
+    if ((jtag_com_stat11() & 0x20000000)==0) {
+	jtag_com_put11((next->pid << 1) | 1);
+    } else {
+	++pid_err_count;
+    }
+#endif  // CONFIG_KMC_LINUX_ARMV6_EXT_PROFILE
+#endif	// CONFIG_KMC_LINUX_PROFILE
+#ifdef CONFIG_KMC_USE_BT
+    spin_unlock_irqrestore(&__kmc_linux_schedule_lock, flags);
+#endif
+}
+
+
+void (*__kmc_schedule_call)(struct task_struct *,struct task_struct *)=__kmc_schedule;
+#endif /* CONFIG_KMC_TRACE_EXT_OFF } */
+/* ########## kernel/sched.c } ########## */
+
+/* ########## arch/XXX/kernel/ptrace.c { ########## */
+#ifndef CONFIG_KMC_PARTNER_AVAILABLE_OFF /* { */
+int __kmc_available_ice = 0;
+#endif /* } CONFIG_KMC_PARTNER_AVAILABLE_OFF */
+/* ########## arch/XXX/kernel/ptrace.c } ########## */
+
+/* This code is for thread debugging to realize delayed attach */
+void __kmc_delayed_attach(void) {
+	asm(".global __kmc_thr_debug_area");
+	asm("__kmc_thr_debug_area:");
+	__KMC_BRK_CODE();
+	asm (" .long  0x4c434dad");
+}
+volatile void (*__kmc_delayed_attach_tmp)(void) = __kmc_delayed_attach;
+
+#ifdef CONFIG_KMC_MODULE_DEBUG_NEW
+char __kmc_debug_module_name[8][64];
+struct module *__kmc_debug_module[8];
+void *__kmc_tmp_mod_array[7];
+
+__attribute__ ((noinline))
+void __kmc_mod_init_brfore(struct module *mod, int index) {
+	__KMC_BRK_CODE();
+	asm("   .long   0x4c434d88");
+}
+
+__attribute__ ((noinline))
+void __kmc_mod_init_after(struct module *mod) {
+	__KMC_BRK_CODE();
+	asm("   .long   0x4c434d89");
+}
+
+__attribute__ ((noinline))
+void __kmc_mod_exit(struct module *mod) {
+	__KMC_BRK_CODE();
+	asm("   .long   0x4c434d8a");
+}
+#endif
+
+#if defined(CONFIG_KMC_LINUX_PROFILE) || defined(CONFIG_KMC_EVENTTRACKER_SUPPORT) 
+#ifdef CONFIG_KMC_LINUX_ARMV6_EXT_PROFILE
+
+#define KMC_FORK_NAME_MAX	16
+struct KMC_FORK_TBL{
+int pid;
+char name[KMC_FORK_NAME_MAX];
+};
+#define KMC_FORK_TBL_MAX	256
+struct KMC_FORK_TBL __kmc_fork_tbl[KMC_FORK_TBL_MAX];
+int __kmc_fork_tbl_index;
+
+void *__kmc_prof_info[]={
+__kmc_fork_tbl,
+&__kmc_fork_tbl_index,
+(void *)KMC_FORK_TBL_MAX,
+0
+};
+#endif
+
+#ifdef CONFIG_NO_USER_PATCH
+#define TARGET_TABLE_MAX	16+1
+char __kmc_target_process_name[TARGET_TABLE_MAX][128];
+
+__attribute__ ((noinline))
+void ___kmc_exec(char *comm, struct task_struct *taskp) {
+	__KMC_BRK_CODE();
+	asm (" .long  0x4c434daa");
+	asm (" nop");
+}
+
+void __kmc_exec(char *comm, struct task_struct *taskp, int isthread)
+{
+    int i;
+    for (i = 0; i < TARGET_TABLE_MAX; i++) {
+        if (strncmp(__kmc_target_process_name[i], comm, strlen(comm)) == 0) {
+            /* libkmcsup code will be copied to user space where we expanded */
+            if (isthread) {
+                ___kmc_exec(comm, taskp);
+            } else {
+                volatile char __user *memhit = (char *)taskp->mm->start_code;
+                char dummy;
+                dummy = *memhit;
+                dummy = *(memhit + PAGE_SIZE);
+                ___kmc_exec(comm, taskp);
+                break;
+            }
+        }
+    }
+}
+#endif // CONFIG_NO_USER_PATCH
+
+void __kmc_make_fork_tbl(struct task_struct *task_p, int mode, unsigned long param)
+// struct task_struct *task_p;
+// int mode;		/* 0.. fork,clone , 1... execv */
+// unsigned long param;		/* modo = 0, clone_flags, mode = 1, filename */
+{
+#ifdef CONFIG_KMC_LINUX_ARMV6_EXT_PROFILE
+    struct KMC_FORK_TBL *fork_tp;
+    char *p,*q;
+    int i;
+#endif
+
+    if(mode==0){
+/* fork,clone */
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT
+	if (task_p->mm == 0) {
+	    // kernel thread
+	    __kmc_linux_event_set_logI( KMC_LINUX_EVENTID_NEWTHREAD, task_p->pid, 0 );
+	} else if ((param & CSIGNAL) != SIGCHLD) {
+	    // user thread
+#if LINUX_VERSION_CODE >= 0x020600
+	    if (task_p == task_p->group_leader) {
+		// linuxthreads
+		__kmc_linux_event_set_logI( KMC_LINUX_EVENTID_NEWTHREAD, task_p->pid, task_p->parent->pid );
+	    } else {
+		// NPTL
+		__kmc_linux_event_set_logI( KMC_LINUX_EVENTID_NEWTHREAD, task_p->pid, task_p->group_leader->pid );
+	    }
+#else
+	    __kmc_linux_event_set_logI( KMC_LINUX_EVENTID_NEWTHREAD, task_p->pid, task_p->p_pptr->pid );
+#endif
+
+#ifdef CONFIG_NO_USER_PATCH
+		__kmc_exec(task_p->comm, task_p, 1);
+#endif
+	} else {
+	    // user process
+	    __kmc_linux_event_set_logS( KMC_LINUX_EVENTID_FORK, task_p->pid, task_p->comm );
+	}
+#endif
+#ifdef CONFIG_KMC_LINUX_ARMV6_EXT_PROFILE
+	fork_tp=&__kmc_fork_tbl[__kmc_fork_tbl_index];
+	if(++__kmc_fork_tbl_index>=KMC_FORK_TBL_MAX) __kmc_fork_tbl_index=0;
+	fork_tp->pid=task_p->pid;
+#endif
+    }
+    else{
+/* execv */
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT
+	__kmc_linux_event_set_logS( KMC_LINUX_EVENTID_EXEC, current->pid, (char *)param);
+#endif
+
+#ifdef CONFIG_NO_USER_PATCH
+		__kmc_exec(task_p->comm, task_p, 0);
+#endif
+
+#ifdef CONFIG_KMC_LINUX_ARMV6_EXT_PROFILE
+	fork_tp=&__kmc_fork_tbl[i=__kmc_fork_tbl_index];
+	do{
+	    if(i==0){
+		fork_tp=&__kmc_fork_tbl[KMC_FORK_TBL_MAX-1];
+		i=KMC_FORK_TBL_MAX-1;
+	    }
+	    else{
+		--i;
+		--fork_tp;
+	    }
+	    if(fork_tp->pid==task_p->pid) goto found;
+	}while(i!=__kmc_fork_tbl_index) ;
+/* not found */
+	return;
+#endif
+    }
+#ifdef CONFIG_KMC_LINUX_ARMV6_EXT_PROFILE
+found:
+    q=task_p->comm;
+    p=fork_tp->name;
+    for(i=0;i<KMC_FORK_NAME_MAX;++i){
+	*(p++)=*q;
+	if(*(q++)=='\0') break;
+    }
+    fork_tp->name[KMC_FORK_NAME_MAX-1] = 0;
+#endif
+}
+
+#endif	// CONFIG_KMC_LINUX_PROFILE , CONFIG_KMC_EVENTTRACKER_SUPPORT
+
+#ifdef CONFIG_NO_USER_PATCH
+#include "kmc-support.c"
+#endif
+
+#endif
+
diff -Nur linux-2.6.28.orig/KMC/kmc.h linux-2.6.28/KMC/kmc.h
--- linux-2.6.28.orig/KMC/kmc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/kmc.h	2009-11-26 13:54:53.000000000 +0900
@@ -0,0 +1,551 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * 2007.02.08 BUGFIX for Application-Mode Debug
+ * __kmc_sys_getpidi() and __kmc_do_exit(), changed Label to function
+ * 2007.10.01 support SMP
+ *            change __KMC_CHECK_PTRACE_REQUEST, specified for ARM-V6
+ * 2007.10.19 support Process Trace
+ * Ver2.0	08.04.14
+ *
+ */
+
+
+#ifndef	__KMC_H__ /* { */
+#define	__KMC_H__
+
+#include "__brk_code.h"
+
+#ifdef CONFIG_KMC_PATCH /* { */
+
+// Add 2007.10.12
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT /* { */		// 2007/10/19 Support Process Trace
+#define KMC_LINUX_EVENTID_NONE		(0)
+#define KMC_LINUX_EVENTID_TASKSWITCH	(1)
+#define KMC_LINUX_EVENTID_FORK		(2)
+#define KMC_LINUX_EVENTID_EXEC		(3)
+#define KMC_LINUX_EVENTID_NEWTHREAD	(4)
+#define KMC_LINUX_EVENTID_EXIT		(5)
+
+struct task_struct;
+
+void __kmc_linux_event_set_logI(int evtid, int pid, int param);
+void __kmc_linux_event_set_logS(int evtid, int pid, const char* pname);
+void __kmc_linux_event_set_logT(int evtid, struct task_struct* t);
+
+#endif /* } CONFIG_KMC_EVENTTRACKER_SUPPORT */
+
+#if defined(CONFIG_KMC_LINUX_PROFILE) || defined(CONFIG_KMC_EVENTTRACKER_SUPPORT) /* { */
+void __kmc_make_fork_tbl(struct task_struct *task_p, int mode, unsigned long param);
+#define	__KMC_MAKE_FORK_TBL(cur,n,fn)	__kmc_make_fork_tbl(cur,n,fn)
+#else /* }{ */
+#define	__KMC_MAKE_FORK_TBL(cur,n,fn)
+#endif /* } */
+
+#if defined(CONFIG_KMC_MODULE_DEBUG_NEW) /* { */
+#define	__KMC_MODULE_DEBUG_NEW()					\
+		void	*__kmc_mod_text;				\
+		void	*__kmc_mod_data;				\
+		void	*__kmc_mod_bss;					\
+		void	*__kmc_mod_exit_text;				\
+		void	*__kmc_mod_exit_data;				\
+		void	*__kmc_mod_init_text;				\
+		void	*__kmc_mod_init_data;				\
+
+#else /* }{ !CONFIG_KMC_MODULE_DEBUG_NEW */
+#define	__KMC_MODULE_DEBUG_NEW()
+#endif /* } CONFIG_KMC_MODULE_DEBUG_NEW */
+
+#ifdef MODULE /* { */
+#if !defined(CONFIG_KMC_MODULE_DEBUG_NEW) /* { */
+// When warning is given, please define '__KMC_UNDEF_MODULE_INIT__'
+#define __KMC_UNDEF_MODULE_INIT__
+
+// Please define '__KMC_DUMMY_KMC_DRIVER' to evade deletion by optimization 
+#define	__KMC_DUMMY_KMC_DRIVER
+
+#if !defined(NULL)
+#define	NULL	0
+#endif
+
+#if defined(CONFIG_KMC_MODULE_AUTO) && defined(__KMC_MODULE_DEBUG) /* { */
+
+#include <linux/version.h>
+
+void __kmc_module_debug_start(void);
+void __kmc_module_debug_end(void);
+
+void __kmc_driver_start(void);
+void __kmc_driver_end(void);
+void __kmc_driver_init_end(void);
+
+char __kmc_driver_tmp __attribute__ ((section (".bss"))) ;
+
+#if defined(__KMC_MODULE_NAME) /* { */
+static char __kmc_driver_name[] = __KMC_MODULE_NAME;
+#else /* }{ */
+static char __kmc_driver_name[] = __KMC_OBJ_NAME;
+#endif /* } defined(__KMC_MODULE_NAME) */
+
+#ifdef CONFIG_KMC_ICE_CHK_MOD_DEB /* { */
+ #define __KMC_ICE_CHK()						\
+    {int ret;								\
+    extern asmlinkage int sys_ptrace(long request, long pid, long addr, long data);									\
+    if(0x434D4B00 != (0xffffff00&(ret=sys_ptrace(0x4B4D4300,0,0,0)))){	\
+	return;								\
+    }									\
+    if(0 == (0x000000ff&ret)){						\
+	return;								\
+    }									\
+    }
+#else /* }{ !CONFIG_KMC_ICE_CHK_MOD_DEB */
+ #define __KMC_ICE_CHK()
+#endif /* } CONFIG_KMC_ICE_CHK_MOD_DEB */
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) /* { */
+static void __kmc_driver(void)
+{
+    asm("   .text");
+    asm("   .global   __kmc_driver_end");
+    asm("   .long   0x4c434d83");
+    asm("__kmc_driver_init_end:");
+    __KMC_BRK_CODE();
+    asm("   .long   0x4c434d82");
+    asm("__kmc_driver_end:");
+    __KMC_BRK_CODE();
+    asm("   .long   0x4c434d81");
+    asm("__kmc_driver_start:");
+    __KMC_BRK_CODE();
+    asm("   .long   0x4c434d80");
+    asm("   .long   __kmc_driver_name");
+    asm("   .long   __kmc_driver_tmp");
+    asm("   .long   0x4c434d8f");
+    asm("   .long   __kmc_init_text");
+    asm("   .long   __kmc_exit_text");
+    asm("   .long   __kmc_init_data");
+    asm("   .long   __kmc_exit_data");
+
+#ifdef __KMC_DUMMY_KMC_DRIVER
+    {
+	volatile static char *__kmc_dummy_2 = __kmc_driver_name;
+	while (NULL != __kmc_dummy_2);
+    }
+#endif
+
+}
+
+__exitdata int __kmc_exit_data;
+__initdata int __kmc_init_data;
+
+void __init __kmc_init_text(void)
+{
+    __KMC_ICE_CHK();
+    __kmc_driver_start();
+}
+
+void __init __kmc_init_text_finish(void)
+{
+    __kmc_driver_init_end();
+}
+
+void __exit __kmc_exit_text(void)
+{
+    __KMC_ICE_CHK();
+    __kmc_driver_end();
+}
+
+#define	__kmc_module_debug_start	__kmc_init_text
+#define	__kmc_module_debug_end		__kmc_exit_text
+
+#else /* }{ LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) */
+static void __kmc_driver(void)
+{
+    asm("   .text");
+    asm("   .long   0x4c434d82");
+    asm("__kmc_driver_end:");
+    __KMC_BRK_CODE();
+    asm("   .long   0x4c434d81");
+    asm("__kmc_driver_start:");
+    __KMC_BRK_CODE();
+    asm("   .long   0x4c434d80");
+    asm("   .long   __kmc_driver_name");
+    asm("   .long   __kmc_driver_tmp");
+}
+
+void
+__kmc_module_debug_start(void)
+{
+    __KMC_ICE_CHK();
+    __kmc_driver_start();
+}
+
+void
+__kmc_module_debug_end(void)
+{
+    __KMC_ICE_CHK();
+    __kmc_driver_end();
+}
+#endif /* } LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) */
+
+#ifdef __KMC_UNDEF_MODULE_INIT__
+#undef	module_init
+#undef	module_exit
+#endif
+#ifdef __KMC_DUMMY_KMC_DRIVER
+void (*__kmc_dummy_1)(void) =__kmc_driver;
+#endif
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) /* { */
+#define module_init(initfn)						\
+	int init_module(void)						\
+	{int ret; __kmc_init_text(); ret = initfn();			\
+	__kmc_init_text_finish(); return ret;}
+#define module_exit(exitfn)						\
+	void cleanup_module(void)					\
+	{ exitfn(); __kmc_exit_text(); }
+
+#else /* }{ LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) */
+#define module_init(x)							\
+	int init_module(void)						\
+	{ __kmc_module_debug_start(); return x(); }			\
+	static inline __init_module_func_t __init_module_inline(void)	\
+	{ return x; }
+#define module_exit(x)							\
+	void cleanup_module(void)					\
+	{ x(); __kmc_module_debug_end(); }				\
+	static inline __cleanup_module_func_t __cleanup_module_inline(void) \
+	{ return x; }
+#endif /* } LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) */
+
+#endif /* } defined(CONFIG_KMC_MODULE_AUTO) && defined(__KMC_MODULE_DEBUG) */
+
+#endif	/* } !CONFIG_KMC_MODULE_DEBUG_NEW */
+#else /* }{ !MODULE */
+
+/* ########## kernel/exit.c { ########## */
+extern void __kmc_do_exit(void);
+extern void __kmc_sys_getpid(void);
+
+#ifdef CONFIG_KMC_PARTNER_COLLECT_THREAD_OFF /* { */
+#define	__KMC_MAX_PT_COUNT	32
+
+extern struct task_struct *__kmc_tss_list[__KMC_MAX_PT_COUNT + 1];
+
+static inline void __kmc_do_exit__(struct task_struct *tsk)
+{
+    int i;
+    extern void __kmc_do_exit(void);
+
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT
+    __kmc_linux_event_set_logT(KMC_LINUX_EVENTID_EXIT, tsk);
+#endif
+
+    if(__kmc_tss_list[0]!=0){
+	for(i=1;i<(__KMC_MAX_PT_COUNT + 1);++i){
+	    if(__kmc_tss_list[i]==tsk){
+		__kmc_tss_list[0]=(struct task_struct *)i;
+// Change 2007.02.08
+//		  asm("__kmc_do_exit:");
+//		  asm("    nop");
+		__kmc_do_exit();
+	    }
+	}
+    }
+}
+#else /* }{ !CONFIG_KMC_PARTNER_COLLECT_THREAD_OFF */
+#define	__KMC_MAX_THREAD_COUNT	256
+#define	__KMC_MAX_PT_COUNT	4
+
+extern struct task_struct *__kmc_tss_list_array[__KMC_MAX_PT_COUNT + 1][__KMC_MAX_THREAD_COUNT];
+
+#ifdef  CONFIG_SMP
+#include        <linux/spinlock.h>
+#endif
+
+static inline void __kmc_do_exit__(struct task_struct *tsk)
+{
+    int i;
+    extern void __kmc_do_exit(void);
+
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT
+    __kmc_linux_event_set_logT(KMC_LINUX_EVENTID_EXIT, tsk);
+#endif
+
+    if(__kmc_tss_list_array[0][0] != 0){
+#ifdef CONFIG_SMP
+        static spinlock_t __kmc_do_exit_lock=SPIN_LOCK_UNLOCKED;
+        spin_lock(&__kmc_do_exit_lock);
+#endif
+	for(i = 1; i < (__KMC_MAX_PT_COUNT + 1); ++i){
+	    int j;
+	    struct task_struct **tpp;
+	    struct task_struct *tp;
+
+	    tpp = __kmc_tss_list_array[i];
+	    for(j = 0; j < __KMC_MAX_THREAD_COUNT; ++j){
+		tp = *(tpp++);
+		if(tp == 0) break;
+		if(tp == tsk){
+		    while(j < (__KMC_MAX_THREAD_COUNT - 1)){
+			if(*tpp == 0) break;
+			*(tpp -1 ) = *tpp;
+			*tpp = tsk;
+			++tpp; ++j;
+		    }
+		    __kmc_tss_list_array[0][0] = (struct task_struct *)i;
+		    __kmc_tss_list_array[0][1] = (struct task_struct *)j;
+// Change 2007.02.08
+//		    asm("__kmc_do_exit:");
+//		    asm("    nop");
+		    __kmc_do_exit();
+		    i = (__KMC_MAX_PT_COUNT + 1);
+		    break;
+		}
+	    }
+	}
+#ifdef CONFIG_SMP
+        spin_unlock(&__kmc_do_exit_lock);
+#endif
+    }
+}
+#endif /* } CONFIG_KMC_PARTNER_COLLECT_THREAD_OFF */
+#define	__KMC_DO_EXIT(t)	__kmc_do_exit__(t)
+/* ########## kernel/exit.c } ########## */
+
+/* ########## kernel/timer.c { ########## */
+#ifdef CONFIG_KMC_PARTNER_VIRTUAL_ICE_OFF /* { */
+#define	__KMC_SYS_GETPID()
+#else /* }{ !CONFIG_KMC_PARTNER_VIRTUAL_ICE_OFF */
+// Change 2007.02.08
+/*
+#define	__KMC_SYS_GETPID()					\
+	{							\
+		extern int __kmc_sys_getpid_flag;		\
+		extern void __kmc_sys_getpid(void);		\
+		if (__kmc_sys_getpid_flag) {			\
+		    asm("__kmc_sys_getpid:");			\
+		    asm("    nop");				\
+		}						\
+	}
+*/
+#ifdef  CONFIG_SMP
+#define __KMC_SYS_GETPID()                                              \
+        {                                                               \
+                extern int __kmc_sys_getpid_flag;                       \
+                extern void __kmc_sys_getpid(void);                     \
+                if (__kmc_sys_getpid_flag==(*(int *)(&current->cpus_allowed))) {        \
+                        __kmc_sys_getpid();                             \
+                }                                                       \
+        }
+#else
+#define	__KMC_SYS_GETPID()						\
+	{								\
+		extern int __kmc_sys_getpid_flag;			\
+		extern void __kmc_sys_getpid(void);			\
+		if (__kmc_sys_getpid_flag) {				\
+			__kmc_sys_getpid();				\
+		}							\
+	}
+#endif
+#endif /* } CONFIG_KMC_PARTNER_VIRTUAL_ICE_OFF */
+/* ########## kernel/timer.c } ########## */
+
+/* ########## kernel/sched.c { ########## */
+#ifdef CONFIG_KMC_TRACE_EXT_OFF /* { */
+#define	__KMC_SCHED_CALL(p,n)
+#else /* }{ !CONFIG_KMC_TRACE_EXT_OFF */
+#define KMC_MAX_SHEDULE_LIST    1024
+#ifdef CONFIG_MN10300 /* { */
+#define	__KMC_SCHED_CALL(p,n)						\
+	{								\
+		extern void (*__kmc_schedule_call)(struct task_struct *,struct task_struct *);								\
+		*(long *)(0xC00001C0) |= 0x01000000;			\
+		__kmc_schedule_call(p,n);				\
+	}
+#else /* }{ !CONFIG_MN10300 */
+#define	__KMC_SCHED_CALL(p,n)						\
+	{								\
+		extern void (*__kmc_schedule_call)(struct task_struct *,struct task_struct *);								\
+		__kmc_schedule_call(p,n);				\
+	}
+#endif /* } CONFIG_MN10300 */
+#endif /* CONFIG_KMC_TRACE_EXT_OFF } */
+/* ########## kernel/sched.c } ########## */
+
+/* ########## kernel/ksyms.c { ########## */
+#ifdef CONFIG_KMC_ICE_CHK_MOD_DEB /* { */
+#define	__KMC_EXPORT_SYMBOL_PTRACE()					\
+	extern asmlinkage int sys_ptrace(long request, long pid, long addr, long data);									\
+	EXPORT_SYMBOL(sys_ptrace)
+#else /* }{ !CONFIG_KMC_ICE_CHK_MOD_DEB */
+#define	__KMC_EXPORT_SYMBOL_PTRACE()
+#endif /* } CONFIG_KMC_ICE_CHK_MOD_DEB */
+/* ########## kernel/ksyms.c } ########## */
+
+/* ########## arch/XXX/kernel/ptrace.c { ########## */
+#ifdef CONFIG_KMC_PARTNER_AVAILABLE_OFF /* { */
+#define	__KMC_CHECK_PTRACE_REQUEST(req,r)
+#else /* }{ !CONFIG_KMC_PARTNER_AVAILABLE_OFF */
+#if defined(CONFIG_ARM) && defined(CONFIG_CPU_V6)
+#define __KMC_CHECK_PTRACE_REQUEST(req,r)		\
+		if(req == 0x4B4D4300){			\
+			__asm__ __volatile__("mrc p14, 0, %0, c0, c1, 0": "=r" (r) : : "cc"); \
+			ret = (ret & 0x4000) ? 1 : 0;	\
+			goto out;			\
+		}
+#else
+#define	__KMC_CHECK_PTRACE_REQUEST(req,r)		\
+		if(req == 0x4B4D4300){			\
+			extern int __kmc_available_ice;	\
+			r = __kmc_available_ice;	\
+			goto out;			\
+		}
+#endif
+#endif /* } CONFIG_KMC_PARTNER_AVAILABLE_OFF */
+/* ########## arch/XXX/kernel/ptrace.c } ########## */
+
+/* ########## init/main.c { ########## */
+#ifdef CONFIG_MN10300 /* { */
+#define __KMC_CHECK_AVAILABLE_ICE()			\
+{							\
+	extern int __kmc_available_ice;			\
+	if(*(unsigned int *)(0xc00001a0) & 0x00080000)	\
+		__kmc_available_ice = 1;		\
+}
+#else /* }{ !CONFIG_MN10300 */
+#define __KMC_CHECK_AVAILABLE_ICE()
+#endif /* } CONFIG_MN10300 */
+/* ########## init/main.c } ########## */
+
+/* ########## kernel/module.c ########## */
+#ifdef CONFIG_KMC_MODULE_DEBUG_NEW
+extern char __kmc_debug_module_name[8][64];
+extern struct module *__kmc_debug_module[8];
+extern void *__kmc_tmp_mod_array[7];
+
+void __kmc_mod_init_brfore(struct module *mod, int index);
+void __kmc_mod_init_after(struct module *mod);
+void __kmc_mod_exit(struct module *mod);
+
+
+#define	__KMC_MOD_INIT_BEFORE(mod)								\
+	{											\
+		int	_i, _st;								\
+		for (_i = 0; _i < 8; _i++) {							\
+			_st = strnicmp(mod->name, __kmc_debug_module_name[_i], 64);		\
+			if (0 == _st) {								\
+				__kmc_debug_module[_i] = mod;					\
+				__kmc_mod_init_brfore(mod, _i);					\
+				break;								\
+			} else {								\
+				if (strchr(__kmc_debug_module_name[_i], '-')) {			\
+					char	__tmp_name[64], *__p;				\
+					__p = strcpy(__tmp_name, __kmc_debug_module_name[_i]);	\
+					while (__p = strchr(__p, '-')) {			\
+						*__p = '_';					\
+					}							\
+					_st = strnicmp(mod->name, __tmp_name, 64);		\
+					if (0 == _st) {         				\
+						__kmc_debug_module[_i] = mod;   		\
+						__kmc_mod_init_brfore(mod, _i); 		\
+						break;						\
+					}							\
+				} 								\
+			}									\
+		} 										\
+	} 
+
+#define	__KMC_MOD_INIT_AFTER(mod, ret)	\
+	{	\
+		int	_i;	\
+		for (_i = 0; _i < 8; _i++) {	\
+			if (__kmc_debug_module[_i] == mod) {	\
+				__kmc_mod_init_after(mod);	\
+				if (0 != ret) {			\
+					__kmc_mod_exit(mod);	\
+					__kmc_debug_module[_i] = (void *)0;	\
+				}				\
+				break;				\
+			}					\
+		}	\
+	}
+
+#define	__KMC_MOD_EXIT(mod)	\
+	{	\
+		int	_i;	\
+		for (_i = 0; _i < 8; _i++) {	\
+			if (__kmc_debug_module[_i] == mod) {	\
+				__kmc_mod_exit(mod);	\
+				__kmc_debug_module[_i] = (void *)0;	\
+				break;				\
+			}					\
+		}	\
+	}
+
+#define	__KMC_CHK_MOD_SEC(mod, secstrings, sechdrs) \
+	if (0 == strnicmp(".text", secstrings + sechdrs[i].sh_name, sizeof(".text"))) { \
+	 	__kmc_tmp_mod_array[0] = dest; \
+	} \
+	if (0 == strnicmp(".data", secstrings + sechdrs[i].sh_name, sizeof(".data"))) { \
+		__kmc_tmp_mod_array[1] = dest; \
+	} \
+	if (0 == strnicmp(".bss", secstrings + sechdrs[i].sh_name, sizeof(".bss"))) { \
+		__kmc_tmp_mod_array[2] = dest; \
+	} \
+	if (0 == strnicmp(".exit.text", secstrings + sechdrs[i].sh_name, sizeof(".exit.text"))) { \
+		__kmc_tmp_mod_array[3] = dest; \
+	} \
+	if (0 == strnicmp(".exit.data", secstrings + sechdrs[i].sh_name, sizeof(".exit.data"))) { \
+		__kmc_tmp_mod_array[4] = dest; \
+	} \
+	if (0 == strnicmp(".init.text", secstrings + sechdrs[i].sh_name, sizeof(".init.text"))) { \
+		__kmc_tmp_mod_array[5] = dest; \
+	} \
+	if (0 == strnicmp(".init.data", secstrings + sechdrs[i].sh_name, sizeof(".init.data"))) { \
+		__kmc_tmp_mod_array[6] = dest; \
+	}
+
+#define	__KMC_SET_MOD_SEC(mod) \
+	mod->__kmc_mod_text = __kmc_tmp_mod_array[0]; \
+	mod->__kmc_mod_data = __kmc_tmp_mod_array[1]; \
+	mod->__kmc_mod_bss = __kmc_tmp_mod_array[2]; \
+	mod->__kmc_mod_exit_text = __kmc_tmp_mod_array[3]; \
+	mod->__kmc_mod_exit_data = __kmc_tmp_mod_array[4]; \
+	mod->__kmc_mod_init_text = __kmc_tmp_mod_array[5]; \
+	mod->__kmc_mod_init_data = __kmc_tmp_mod_array[6];
+
+#else
+#define	__KMC_MOD_EXIT(mod)
+#define	__KMC_MOD_INIT_BEFORE(mod)
+#define	__KMC_MOD_INIT_AFTER(mod, ret)
+#define	__KMC_CHK_MOD_SEC(mod, secstrings, sechdrs)
+#define	__KMC_SET_MOD_SEC(mod)
+#endif
+
+#endif /* } MODULE */
+#else /* }{ !CONFIG_KMC_PATCH */
+
+#define	__KMC_SCHED_CALL(p,n)
+#define	__KMC_DO_EXIT(t)
+#define	__KMC_SYS_GETPID()
+#define	__KMC_EXPORT_SYMBOL_PTRACE()
+#define	__KMC_CHECK_PTRACE_REQUEST(req,r)
+
+#define	__KMC_MOD_EXIT(mod)
+#define	__KMC_MOD_INIT_BEFORE(mod)
+#define	__KMC_MOD_INIT_AFTER(mod, ret)
+#define	__KMC_CHK_MOD_SEC(mod, secstrings, sechdrs)
+#define	__KMC_SET_MOD_SEC(mod)
+
+#define	__KMC_MAKE_FORK_TBL(cur,n,fn)
+
+#define	__KMC_CHECK_AVAILABLE_ICE()
+
+#define	__KMC_MODULE_DEBUG_NEW()
+
+#endif /* } CONFIG_KMC_PATCH */
+
+
+#endif /* } __KMC_H__ */
diff -Nur linux-2.6.28.orig/KMC/kmc_dt_am33.c linux-2.6.28/KMC/kmc_dt_am33.c
--- linux-2.6.28.orig/KMC/kmc_dt_am33.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/kmc_dt_am33.c	2009-11-26 13:54:53.000000000 +0900
@@ -0,0 +1,550 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * Ver2.0	08.04.14
+ *
+ */
+
+
+
+    asm("	.text");
+    asm("	.align	2");
+    asm("	.global	__kmc_code_data");
+    asm("__kmc_code_data:");
+    asm("	movm	[other],(sp)");
+    asm("	mov	__kmc_code_data_table,a1");
+    asm("	mov	4,d1");
+    asm("	mov	d0,a0");
+    asm("	and	0xff,a0");
+    asm("	asl2	a0");
+    asm("	add	a1,a0");
+    asm("	jmp	(a0)");
+    asm("	nop");
+    asm("	.align	2");
+    asm("__kmc_code_data_table:");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("jmp_end:");
+    asm("	add	-1,d1");
+    asm("	beq	jmp_end1");
+    asm("	lsr     8,d0");
+    asm("	mov	d0,a0");
+    asm("	and	0xff,a0");
+    asm("	asl2	a0");
+    asm("	add	a1,a0");
+    asm("	jmp	(a0)");
+    asm("jmp_end1:");
+    asm("	movm    (sp),[other]");
+    asm("	ret    [],0");
+
+
diff -Nur linux-2.6.28.orig/KMC/kmc_dt_arm.c linux-2.6.28/KMC/kmc_dt_arm.c
--- linux-2.6.28.orig/KMC/kmc_dt_arm.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/kmc_dt_arm.c	2009-11-26 13:54:53.000000000 +0900
@@ -0,0 +1,285 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * Ver2.0	08.04.14
+ *
+ */
+
+
+
+    asm("	.text");
+    asm("	.align	2");
+    asm("	.global	__kmc_code_data");
+    asm("__kmc_code_data:");
+    asm("	ldr	r3, __kmc_code_data_tableX");
+    asm("	mov	r2, #4");
+    asm("loop:");
+    asm("	and	r1, r0, #0xff");
+    asm("	add	pc, r3, r1, asl #2");
+    asm("__kmc_code_data_table:");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("jmp_end:");
+    asm("	mov	r0, r0, lsr #8");
+    asm("	subs	r2, r2, #1");
+    asm("	bne	loop");
+    asm("	mov	pc,lr");
+    asm("	.align	2");
+    asm("__kmc_code_data_tableX:");
+    asm("	.word	__kmc_code_data_table");
+
+
diff -Nur linux-2.6.28.orig/KMC/kmc_dt_mips.c linux-2.6.28/KMC/kmc_dt_mips.c
--- linux-2.6.28.orig/KMC/kmc_dt_mips.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/kmc_dt_mips.c	2009-11-26 13:54:53.000000000 +0900
@@ -0,0 +1,558 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * Ver2.0	08.04.14
+ *
+ */
+
+
+
+
+
+asm("	.text");
+asm("	.align	2");
+asm("	.global	__kmc_code_data");
+asm("__kmc_code_data:");
+asm("	la	$5, __kmc_code_data_table");
+asm("	li	$6, 4");
+asm("	rol	$4, $4, 3");
+asm("	andi	$7, $4, 0x7f8");
+asm("loop:");
+asm("	addu	$7, $7, $5");
+asm("	jr	$7");
+asm("__kmc_code_data_table:");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("jmp_end:");
+asm("	ror	$4, $4, 8");
+asm("	andi	$7, $4, 0x7f8");
+asm("	bne	$6, $0, loop");
+asm("	jr	$31");
+
+
+
diff -Nur linux-2.6.28.orig/KMC/kmc_dt_sh.c linux-2.6.28/KMC/kmc_dt_sh.c
--- linux-2.6.28.orig/KMC/kmc_dt_sh.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.28/KMC/kmc_dt_sh.c	2009-11-26 13:54:53.000000000 +0900
@@ -0,0 +1,555 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * Ver2.0	08.04.14
+ *
+ */
+
+
+
+
+
+    asm("	.text");
+    asm("	.align	2");
+    asm("	.global	__kmc_code_data");
+    asm("__kmc_code_data:");
+    asm("	mova	__kmc_code_data_table,r0");
+    asm("	mov	r0,r1");
+    asm("	mov	#4,r2");
+    asm("	mov	#0xff,r3");
+    asm("	extu.b	r3,r3");
+    asm("	mov	r4,r0");
+    asm("	and	r3,r0");
+    asm("	shll2	r0");
+    asm("	add	r1,r0");
+    asm("	jmp	@r0");
+    asm("	nop");
+    asm("	.align	2");
+    asm("__kmc_code_data_table:");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("jmp_end:");
+    asm("	add	#0xff,r2");
+    asm("	tst	r2,r2");
+    asm("	bt	jmp_end1");
+    asm("	mov	r4,r0");
+    asm("	and	r3,r0");
+    asm("	shll2	r0");
+    asm("	add	r1,r0");
+    asm("	jmp	@r0");
+    asm("	nop");
+    asm("jmp_end1:");
+    asm("	rts");
+    asm("	nop");
+
+
diff -Nur linux-2.6.28.orig/Makefile linux-2.6.28/Makefile
--- linux-2.6.28.orig/Makefile	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/Makefile	2009-11-26 18:06:27.000000000 +0900
@@ -517,6 +517,9 @@
 
 include $(srctree)/arch/$(SRCARCH)/Makefile
 
+# @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ {
+include $(TOPDIR)/KMC/Makefile_kmc
+# @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ }
 ifneq (CONFIG_FRAME_WARN,0)
 KBUILD_CFLAGS += $(call cc-option,-Wframe-larger-than=${CONFIG_FRAME_WARN})
 endif
diff -Nur linux-2.6.28.orig/fs/exec.c linux-2.6.28/fs/exec.c
--- linux-2.6.28.orig/fs/exec.c	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/fs/exec.c	2009-11-26 18:06:27.000000000 +0900
@@ -1343,6 +1343,10 @@
 	retval = search_binary_handler(bprm,regs);
 	if (retval >= 0) {
 		/* execve success */
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+__KMC_MAKE_FORK_TBL(current,1,(unsigned long)filename);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 		security_bprm_free(bprm);
 		acct_update_integrals(current);
 		free_bprm(bprm);
diff -Nur linux-2.6.28.orig/include/linux/init.h linux-2.6.28/include/linux/init.h
--- linux-2.6.28.orig/include/linux/init.h	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/include/linux/init.h	2009-11-26 18:06:27.000000000 +0900
@@ -331,4 +331,9 @@
 #define __exit_p(x) NULL
 #endif
 
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#ifndef __ASSEMBLY__
+#include "kmc.h"
+#endif /* __ASSEMBLY__ */
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 #endif /* _LINUX_INIT_H */
diff -Nur linux-2.6.28.orig/include/linux/module.h linux-2.6.28/include/linux/module.h
--- linux-2.6.28.orig/include/linux/module.h	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/include/linux/module.h	2009-11-26 18:06:27.000000000 +0900
@@ -231,6 +231,9 @@
 	MODULE_STATE_GOING,
 };
 
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 struct module
 {
 	enum module_state state;
@@ -322,6 +325,9 @@
 	struct module_notes_attrs *notes_attrs;
 #endif
 
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+__KMC_MODULE_DEBUG_NEW();
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 	/* Per-cpu data. */
 	void *percpu;
 
diff -Nur linux-2.6.28.orig/kernel/exit.c linux-2.6.28/kernel/exit.c
--- linux-2.6.28.orig/kernel/exit.c	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/kernel/exit.c	2009-11-26 18:06:27.000000000 +0900
@@ -1001,6 +1001,10 @@
 	int group_dead;
 
 	profile_task_exit(tsk);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+__KMC_DO_EXIT(tsk);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 
 	WARN_ON(atomic_read(&tsk->fs_excl));
 
@@ -1838,3 +1842,7 @@
 }
 
 #endif
+
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.c"
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
diff -Nur linux-2.6.28.orig/kernel/fork.c linux-2.6.28/kernel/fork.c
--- linux-2.6.28.orig/kernel/fork.c	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/kernel/fork.c	2009-11-26 18:06:27.000000000 +0900
@@ -1272,6 +1272,10 @@
 	write_unlock_irq(&tasklist_lock);
 	proc_fork_connector(p);
 	cgroup_post_fork(p);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+__KMC_MAKE_FORK_TBL(p,0,clone_flags);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 	return p;
 
 bad_fork_free_pid:
diff -Nur linux-2.6.28.orig/kernel/module.c linux-2.6.28/kernel/module.c
--- linux-2.6.28.orig/kernel/module.c	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/kernel/module.c	2009-11-26 18:06:27.000000000 +0900
@@ -805,6 +805,10 @@
 
 	mutex_unlock(&module_mutex);
 	/* Final destruction now noone is using it. */
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+__KMC_MOD_EXIT(mod);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 	if (mod->exit != NULL)
 		mod->exit();
 	blocking_notifier_call_chain(&module_notify_list,
@@ -2045,11 +2049,19 @@
 			       sechdrs[i].sh_size);
 		/* Update sh_addr to point to copy in image. */
 		sechdrs[i].sh_addr = (unsigned long)dest;
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+__KMC_CHK_MOD_SEC(mod,secstrings,sechdrs);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 		DEBUGP("\t0x%lx %s\n", sechdrs[i].sh_addr, secstrings + sechdrs[i].sh_name);
 	}
 	/* Module has been moved. */
 	mod = (void *)sechdrs[modindex].sh_addr;
 
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+__KMC_SET_MOD_SEC(mod);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 	/* Now we've moved module, initialize linked lists, etc. */
 	module_unload_init(mod);
 
@@ -2319,7 +2331,16 @@
 
 	/* Start the module */
 	if (mod->init != NULL)
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+{
+#include "kmc.h"
+__KMC_MOD_INIT_BEFORE(mod);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 		ret = do_one_initcall(mod->init);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+__KMC_MOD_INIT_AFTER(mod,ret);
+}
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 	if (ret < 0) {
 		/* Init routine failed: abort.  Try to protect us from
                    buggy refcounters. */
diff -Nur linux-2.6.28.orig/kernel/ptrace.c linux-2.6.28/kernel/ptrace.c
--- linux-2.6.28.orig/kernel/ptrace.c	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/kernel/ptrace.c	2009-11-26 18:06:27.000000000 +0900
@@ -682,6 +682,10 @@
 		goto out;
 	}
 
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+__KMC_CHECK_PTRACE_REQUEST(request,ret);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 	child = ptrace_get_task_struct(pid);
 	if (IS_ERR(child)) {
 		ret = PTR_ERR(child);
diff -Nur linux-2.6.28.orig/kernel/sched.c linux-2.6.28/kernel/sched.c
--- linux-2.6.28.orig/kernel/sched.c	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/kernel/sched.c	2009-11-26 18:06:27.000000000 +0900
@@ -2654,6 +2654,10 @@
 #endif
 
 	/* Here we just switch the register state and the stack. */
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+__KMC_SCHED_CALL(prev,next);
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 	switch_to(prev, next, prev);
 
 	barrier();
diff -Nur linux-2.6.28.orig/kernel/timer.c linux-2.6.28/kernel/timer.c
--- linux-2.6.28.orig/kernel/timer.c	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/kernel/timer.c	2009-11-26 18:06:27.000000000 +0900
@@ -1325,6 +1325,10 @@
 /* Thread ID - the internal kernel "pid" */
 asmlinkage long sys_gettid(void)
 {
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ { */
+#include "kmc.h"
+__KMC_SYS_GETPID();
+/* @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ } */
 	return task_pid_vnr(current);
 }
 
diff -Nur linux-2.6.28.orig/lib/Kconfig.debug linux-2.6.28/lib/Kconfig.debug
--- linux-2.6.28.orig/lib/Kconfig.debug	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/lib/Kconfig.debug	2009-11-26 18:06:27.000000000 +0900
@@ -870,3 +870,7 @@
 source "samples/Kconfig"
 
 source "lib/Kconfig.kgdb"
+
+# @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ {
+source KMC/Kconfig_kmc
+# @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ }
diff -Nur linux-2.6.28.orig/scripts/Makefile.lib linux-2.6.28/scripts/Makefile.lib
--- linux-2.6.28.orig/scripts/Makefile.lib	2008-12-25 08:26:37.000000000 +0900
+++ linux-2.6.28/scripts/Makefile.lib	2009-11-26 18:06:27.000000000 +0900
@@ -104,6 +104,9 @@
 debug_flags =
 endif
 
+# @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ {
+include $(TOPDIR)/KMC/Rules_kmc.make
+# @@@ KMC_PARTNER_LINUX_SUPPORT_MODIFY @@@ }
 orig_c_flags   = $(KBUILD_CFLAGS) $(ccflags-y) $(CFLAGS_$(basetarget).o)
 _c_flags       = $(filter-out $(CFLAGS_REMOVE_$(basetarget).o), $(orig_c_flags))
 _a_flags       = $(KBUILD_AFLAGS) $(asflags-y) $(AFLAGS_$(basetarget).o)
