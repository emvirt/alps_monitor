---
 ipc/mqueue.c           |  286 ++++++++++++++++++++++++++++++++++++++++++++++
 ipc/msgutil.c          |   85 +++++++++++++
 safeg/README.OLD       |   69 +++++++++++
 safeg/safeg-debugfs.c  |   84 +++++++++++++
 safeg/safeg-fifo.c     |  175 ++++++++++++++++++++++++++++
 safeg/safeg-mmap.c     |  125 ++++++++++++++++++++
 safeg/safeg-mqueue.c   |  124 ++++++++++++++++++++
 safeg/safeg-mqueue2.c  |  132 +++++++++++++++++++++
 safeg/safeg-panic.c    |   76 ++++++++++++
 safeg/safeg-ring.c     |  300 +++++++++++++++++++++++++++++++++++++++++++++++++
 safeg/safeg-rtasks.c   |  193 +++++++++++++++++++++++++++++++
 safeg/safeg-rtasks2.c  |   34 +++++
 safeg/safeg-shvar.c    |  210 ++++++++++++++++++++++++++++++++++
 safeg/safeg_latency.c  |  253 +++++++++++++++++++++++++++++++++++++++++
 safeg/safeg_latency.h  |   71 +++++++++++
 safeg/safeg_latency2.c |   93 +++++++++++++++
 safeg/safeg_latency2.h |    6 
 17 files changed, 2316 insertions(+)

--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -47,6 +47,10 @@
 #define STATE_PENDING	1
 #define STATE_READY	2
 
+#define MQ_ENABLE_DEBUG false
+#define DEBUG(enable,x,args...)  \
+	if(enable) printk(KERN_INFO "%s: " x, __func__ , ##args)
+
 struct ext_wait_queue {		/* queue of sleeping tasks */
 	struct task_struct *task;
 	struct list_head list;
@@ -72,6 +76,7 @@ struct mqueue_inode_info {
 	struct ext_wait_queue e_wait_q[2];
 
 	unsigned long qsize; /* size of queue in memory (sum of all msgs) */
+	int is_safeg_mq;
 };
 
 static const struct inode_operations mqueue_dir_inode_operations;
@@ -113,6 +118,8 @@ static struct inode *mqueue_get_inode(st
 	struct user_struct *u = current_user();
 	struct inode *inode;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	inode = new_inode(sb);
 	if (inode) {
 		inode->i_mode = mode;
@@ -141,6 +148,8 @@ static struct inode *mqueue_get_inode(st
 			memset(&info->attr, 0, sizeof(info->attr));
 			info->attr.mq_maxmsg = ipc_ns->mq_msg_max;
 			info->attr.mq_msgsize = ipc_ns->mq_msgsize_max;
+			DEBUG(true, "inode default (not safeg node)\n");
+			info->is_safeg_mq = 0;
 			if (attr) {
 				info->attr.mq_maxmsg = attr->mq_maxmsg;
 				info->attr.mq_msgsize = attr->mq_msgsize;
@@ -189,6 +198,8 @@ static int mqueue_fill_super(struct supe
 	struct ipc_namespace *ns = data;
 	int error = 0;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = MQUEUE_MAGIC;
@@ -224,6 +235,7 @@ static void init_once(void *foo)
 {
 	struct mqueue_inode_info *p = (struct mqueue_inode_info *) foo;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	inode_init_once(&p->vfs_inode);
 }
 
@@ -231,6 +243,7 @@ static struct inode *mqueue_alloc_inode(
 {
 	struct mqueue_inode_info *ei;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	ei = kmem_cache_alloc(mqueue_inode_cachep, GFP_KERNEL);
 	if (!ei)
 		return NULL;
@@ -250,6 +263,8 @@ static void mqueue_delete_inode(struct i
 	int i;
 	struct ipc_namespace *ipc_ns;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	if (S_ISDIR(inode->i_mode)) {
 		clear_inode(inode);
 		return;
@@ -293,6 +308,8 @@ static int mqueue_create(struct inode *d
 	int error;
 	struct ipc_namespace *ipc_ns;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	spin_lock(&mq_lock);
 	ipc_ns = __get_ns_from_inode(dir);
 	if (!ipc_ns) {
@@ -333,6 +350,8 @@ static int mqueue_unlink(struct inode *d
 {
   	struct inode *inode = dentry->d_inode;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	dir->i_ctime = dir->i_mtime = dir->i_atime = CURRENT_TIME;
 	dir->i_size -= DIRENT_SIZE;
   	drop_nlink(inode);
@@ -354,6 +373,8 @@ static ssize_t mqueue_read_file(struct f
 	char buffer[FILENT_SIZE];
 	ssize_t ret;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	spin_lock(&info->lock);
 	snprintf(buffer, sizeof(buffer),
 			"QSIZE:%-10lu NOTIFY:%-5d SIGNO:%-5d NOTIFY_PID:%-6d\n",
@@ -379,6 +400,8 @@ static int mqueue_flush_file(struct file
 {
 	struct mqueue_inode_info *info = MQUEUE_I(filp->f_path.dentry->d_inode);
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	spin_lock(&info->lock);
 	if (task_tgid(current) == info->notify_owner)
 		remove_notification(info);
@@ -392,6 +415,8 @@ static unsigned int mqueue_poll_file(str
 	struct mqueue_inode_info *info = MQUEUE_I(filp->f_path.dentry->d_inode);
 	int retval = 0;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	poll_wait(filp, &info->wait_q, poll_tab);
 
 	spin_lock(&info->lock);
@@ -411,6 +436,8 @@ static void wq_add(struct mqueue_inode_i
 {
 	struct ext_wait_queue *walk;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	ewp->task = current;
 
 	list_for_each_entry(walk, &info->e_wait_q[sr].list, list) {
@@ -433,6 +460,8 @@ static int wq_sleep(struct mqueue_inode_
 	int retval;
 	signed long time;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	wq_add(info, sr, ewp);
 
 	for (;;) {
@@ -488,6 +517,8 @@ static void msg_insert(struct msg_msg *p
 {
 	int k;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	k = info->attr.mq_curmsgs - 1;
 	while (k >= 0 && info->messages[k]->m_type >= ptr->m_type) {
 		info->messages[k + 1] = info->messages[k];
@@ -500,12 +531,14 @@ static void msg_insert(struct msg_msg *p
 
 static inline struct msg_msg *msg_get(struct mqueue_inode_info *info)
 {
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	info->qsize -= info->messages[--info->attr.mq_curmsgs]->m_ts;
 	return info->messages[info->attr.mq_curmsgs];
 }
 
 static inline void set_cookie(struct sk_buff *skb, char code)
 {
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	((char*)skb->data)[NOTIFY_COOKIE_LEN-1] = code;
 }
 
@@ -514,6 +547,7 @@ static inline void set_cookie(struct sk_
  */
 static void __do_notify(struct mqueue_inode_info *info)
 {
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	/* notification
 	 * invoked when there is registered process and there isn't process
 	 * waiting synchronously for message AND state of queue changed from
@@ -556,6 +590,7 @@ static long prepare_timeout(struct times
 	struct timespec nowts;
 	long timeout;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	if (p) {
 		if (unlikely(p->tv_nsec < 0 || p->tv_sec < 0
 			|| p->tv_nsec >= NSEC_PER_SEC))
@@ -580,6 +615,7 @@ static long prepare_timeout(struct times
 
 static void remove_notification(struct mqueue_inode_info *info)
 {
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	if (info->notify_owner != NULL &&
 	    info->notify.sigev_notify == SIGEV_THREAD) {
 		set_cookie(info->notify_cookie, NOTIFY_REMOVED);
@@ -591,6 +627,7 @@ static void remove_notification(struct m
 
 static int mq_attr_ok(struct ipc_namespace *ipc_ns, struct mq_attr *attr)
 {
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	if (attr->mq_maxmsg <= 0 || attr->mq_msgsize <= 0)
 		return 0;
 	if (capable(CAP_SYS_RESOURCE)) {
@@ -622,6 +659,7 @@ static struct file *do_create(struct ipc
 	struct file *result;
 	int ret;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	if (attr) {
 		ret = -EINVAL;
 		if (!mq_attr_ok(ipc_ns, attr))
@@ -689,6 +727,8 @@ SYSCALL_DEFINE4(mq_open, const char __us
 	int fd, error;
 	struct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	if (u_attr && copy_from_user(&attr, u_attr, sizeof(struct mq_attr)))
 		return -EFAULT;
 
@@ -711,17 +751,20 @@ SYSCALL_DEFINE4(mq_open, const char __us
 
 	if (oflag & O_CREAT) {
 		if (dentry->d_inode) {	/* entry already exists */
+			DEBUG(MQ_ENABLE_DEBUG, "exists");
 			audit_inode(name, dentry);
 			error = -EEXIST;
 			if (oflag & O_EXCL)
 				goto out;
 			filp = do_open(ipc_ns, dentry, oflag);
 		} else {
+			DEBUG(MQ_ENABLE_DEBUG, "create");
 			filp = do_create(ipc_ns, ipc_ns->mq_mnt->mnt_root,
 						dentry, oflag, mode,
 						u_attr ? &attr : NULL);
 		}
 	} else {
+		DEBUG(MQ_ENABLE_DEBUG, "open");
 		error = -ENOENT;
 		if (!dentry->d_inode)
 			goto out;
@@ -751,6 +794,60 @@ out_putname:
 	return fd;
 }
 
+int safeg_mq_create(char *name)
+{
+	struct dentry *dentry;
+	struct file *filp;
+	int fd, error;
+	struct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;
+	struct mqueue_inode_info *info;
+
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
+	/* obtain a free file descriptor */
+	fd = get_unused_fd_flags(O_CLOEXEC);
+	if (fd < 0)
+		goto out_putname;
+
+	/* create a dentry in the mqueue filesystem with a name */
+	mutex_lock(&ipc_ns->mq_mnt->mnt_root->d_inode->i_mutex);
+	dentry = lookup_one_len(name, ipc_ns->mq_mnt->mnt_root, strlen(name));
+	if (IS_ERR(dentry)) {
+		error = PTR_ERR(dentry);
+		goto out_err;
+	}
+	mntget(ipc_ns->mq_mnt);
+
+	filp = do_create(ipc_ns, ipc_ns->mq_mnt->mnt_root,
+			 dentry, O_RDWR | O_CREAT, 0666, NULL);
+
+	if (IS_ERR(filp)) {
+		error = PTR_ERR(filp);
+		goto out_putfd;
+	}
+
+	fd_install(fd, filp);
+
+	DEBUG(true, "inode = safeg node\n");
+	info = MQUEUE_I(filp->f_path.dentry->d_inode);
+	info->is_safeg_mq = 1;
+
+	goto out_upsem;
+
+	dput(dentry);
+	mntput(ipc_ns->mq_mnt);
+out_putfd:
+	put_unused_fd(fd);
+out_err:
+	fd = error;
+out_upsem:
+	mutex_unlock(&ipc_ns->mq_mnt->mnt_root->d_inode->i_mutex);
+out_putname:
+	putname(name);
+	return fd;
+}
+EXPORT_SYMBOL(safeg_mq_create);
+
 SYSCALL_DEFINE1(mq_unlink, const char __user *, u_name)
 {
 	int err;
@@ -759,6 +856,8 @@ SYSCALL_DEFINE1(mq_unlink, const char __
 	struct inode *inode = NULL;
 	struct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	name = getname(u_name);
 	if (IS_ERR(name))
 		return PTR_ERR(name);
@@ -818,6 +917,7 @@ static inline void pipelined_send(struct
 				  struct msg_msg *message,
 				  struct ext_wait_queue *receiver)
 {
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	receiver->msg = message;
 	list_del(&receiver->list);
 	receiver->state = STATE_PENDING;
@@ -832,8 +932,10 @@ static inline void pipelined_receive(str
 {
 	struct ext_wait_queue *sender = wq_get_first_waiter(info, SEND);
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	if (!sender) {
 		/* for poll */
+		DEBUG(MQ_ENABLE_DEBUG, "wake_up_interruptible");
 		wake_up_interruptible(&info->wait_q);
 		return;
 	}
@@ -859,6 +961,7 @@ SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqd
 	long timeout;
 	int ret;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
 	if (u_abs_timeout) {
 		if (copy_from_user(&ts, u_abs_timeout, 
 					sizeof(struct timespec)))
@@ -891,6 +994,12 @@ SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqd
 		goto out_fput;
 	}
 
+	if (info->is_safeg_mq) {
+		DEBUG(true, "send through a safeg mq (%d)\n", info->is_safeg_mq);
+	} else {
+		DEBUG(true, "send through a not safeg mq (%d)\n", info->is_safeg_mq);
+	}
+
 	/* First try to allocate memory, before doing anything with
 	 * existing queues. */
 	msg_ptr = load_msg(u_msg_ptr, msg_len);
@@ -911,6 +1020,7 @@ SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqd
 			spin_unlock(&info->lock);
 			ret = timeout;
 		} else {
+			DEBUG(MQ_ENABLE_DEBUG, "full");
 			wait.task = current;
 			wait.msg = (void *) msg_ptr;
 			wait.state = STATE_NONE;
@@ -923,6 +1033,89 @@ SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqd
 		if (receiver) {
 			pipelined_send(info, msg_ptr, receiver);
 		} else {
+			DEBUG(MQ_ENABLE_DEBUG, "add to queue");
+			/* adds message to the queue */
+			msg_insert(msg_ptr, info);
+			__do_notify(info);
+		}
+		inode->i_atime = inode->i_mtime = inode->i_ctime =
+				CURRENT_TIME;
+		spin_unlock(&info->lock);
+		ret = 0;
+	}
+out_fput:
+	fput(filp);
+out:
+	return ret;
+}
+
+extern struct msg_msg *safeg_load_msg(const void *src, int len);
+
+int safeg_mq_send(mqd_t mqdes,
+		  const char *u_msg_ptr,
+		  size_t msg_len,
+		  unsigned int msg_prio)
+{
+	struct file *filp;
+	struct inode *inode;
+	struct ext_wait_queue wait;
+	struct ext_wait_queue *receiver;
+	struct msg_msg *msg_ptr;
+	struct mqueue_inode_info *info;
+	int ret;
+
+	if (unlikely(msg_prio >= (unsigned long) MQ_PRIO_MAX))
+		return -EINVAL;
+
+	ret = -EBADF;
+	filp = fget(mqdes);
+	if (unlikely(!filp))
+		goto out;
+
+	inode = filp->f_path.dentry->d_inode;
+	if (unlikely(filp->f_op != &mqueue_file_operations))
+		goto out_fput;
+	info = MQUEUE_I(inode);
+
+	if (unlikely(!(filp->f_mode & FMODE_WRITE)))
+		goto out_fput;
+
+	if (unlikely(msg_len > info->attr.mq_msgsize)) {
+		ret = -EMSGSIZE;
+		goto out_fput;
+	}
+
+	/* First try to allocate memory, before doing anything with
+	 * existing queues. */
+	msg_ptr = safeg_load_msg(u_msg_ptr, msg_len);
+	if (IS_ERR(msg_ptr)) {
+		ret = PTR_ERR(msg_ptr);
+		goto out_fput;
+	}
+	msg_ptr->m_ts = msg_len;
+	msg_ptr->m_type = msg_prio;
+
+	spin_lock(&info->lock);
+
+	if (info->attr.mq_curmsgs == info->attr.mq_maxmsg) {
+		if (filp->f_flags & O_NONBLOCK) {
+			spin_unlock(&info->lock);
+			ret = -EAGAIN;
+		} else {
+			DEBUG(MQ_ENABLE_DEBUG, "full");
+			wait.task = current;
+			wait.msg = (void *) msg_ptr;
+			wait.state = STATE_NONE;
+			ret = wq_sleep(info, SEND, MAX_SCHEDULE_TIMEOUT, &wait);
+		}
+		if (ret < 0)
+			free_msg(msg_ptr);
+	} else {
+		receiver = wq_get_first_waiter(info, RECV);
+		if (receiver) {
+			pipelined_send(info, msg_ptr, receiver);
+		} else {
+			DEBUG(MQ_ENABLE_DEBUG, "add to queue");
 			/* adds message to the queue */
 			msg_insert(msg_ptr, info);
 			__do_notify(info);
@@ -951,6 +1144,8 @@ SYSCALL_DEFINE5(mq_timedreceive, mqd_t, 
 	struct ext_wait_queue wait;
 	struct timespec ts, *p = NULL;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	if (u_abs_timeout) {
 		if (copy_from_user(&ts, u_abs_timeout, 
 					sizeof(struct timespec)))
@@ -992,6 +1187,7 @@ SYSCALL_DEFINE5(mq_timedreceive, mqd_t, 
 			ret = timeout;
 			msg_ptr = NULL;
 		} else {
+			DEBUG(MQ_ENABLE_DEBUG, "block");
 			wait.task = current;
 			wait.state = STATE_NONE;
 			ret = wq_sleep(info, RECV, timeout, &wait);
@@ -1010,6 +1206,7 @@ SYSCALL_DEFINE5(mq_timedreceive, mqd_t, 
 	}
 	if (ret == 0) {
 		ret = msg_ptr->m_ts;
+		DEBUG(MQ_ENABLE_DEBUG, "store msg");
 
 		if ((u_msg_prio && put_user(msg_ptr->m_type, u_msg_prio)) ||
 			store_msg(u_msg_ptr, msg_ptr, msg_ptr->m_ts)) {
@@ -1023,6 +1220,89 @@ out:
 	return ret;
 }
 
+extern int safeg_store_msg(void *dest, struct msg_msg *msg, int len);
+
+int safeg_mq_receive(mqd_t mqdes,
+		     char *u_msg_ptr,
+		     size_t msg_len,
+		     unsigned int *msg_prio)
+{
+	ssize_t ret;
+	struct msg_msg *msg_ptr;
+	struct file *filp;
+	struct inode *inode;
+	struct mqueue_inode_info *info;
+	struct ext_wait_queue wait;
+
+	/* Obtain file associated to the queue descriptor */
+	ret = -EBADF;
+	filp = fget(mqdes);
+	if (unlikely(!filp))
+		goto out;
+
+	/* Obtain the mqueue information */
+	inode = filp->f_path.dentry->d_inode;
+	if (unlikely(filp->f_op != &mqueue_file_operations))
+		goto out_fput;
+	info = MQUEUE_I(inode);
+
+	if (unlikely(!(filp->f_mode & FMODE_READ)))
+		goto out_fput;
+
+	/* checks if buffer is big enough */
+	if (unlikely(msg_len < info->attr.mq_msgsize)) {
+		ret = -EMSGSIZE;
+		goto out_fput;
+	}
+
+	/* check for a message */
+	spin_lock(&info->lock);
+	if (info->attr.mq_curmsgs == 0) {
+		/* no messages */
+		if (filp->f_flags & O_NONBLOCK) {
+			DEBUG(MQ_ENABLE_DEBUG, "non-block");
+			spin_unlock(&info->lock);
+			ret = -EAGAIN;
+			msg_ptr = NULL;
+		} else {
+			DEBUG(MQ_ENABLE_DEBUG, "block");
+			wait.task = current;
+			wait.state = STATE_NONE;
+			ret = wq_sleep(info, RECV, MAX_SCHEDULE_TIMEOUT, &wait);
+			msg_ptr = wait.msg;
+		}
+	} else {
+		/* message available! */
+		msg_ptr = msg_get(info);
+
+		inode->i_atime = inode->i_mtime = inode->i_ctime =
+				CURRENT_TIME;
+
+		/* There is now free space in queue. */
+		pipelined_receive(info);
+		spin_unlock(&info->lock);
+		ret = 0;
+	}
+
+	/* save the message */
+	if (ret == 0) {
+		ret = msg_ptr->m_ts; /* message text size */
+		DEBUG(MQ_ENABLE_DEBUG, "store msg (size:%d)", msg_ptr->m_ts);
+
+		*msg_prio = msg_ptr->m_type;
+		if (safeg_store_msg(u_msg_ptr, msg_ptr, msg_ptr->m_ts)) {
+			DEBUG(MQ_ENABLE_DEBUG, "efault error");
+			ret = -EFAULT;
+		}
+		free_msg(msg_ptr);
+	}
+out_fput:
+	fput(filp);
+out:
+	return ret;
+}
+EXPORT_SYMBOL(safeg_mq_receive);
+
 /*
  * Notes: the case when user wants us to deregister (with NULL as pointer)
  * and he isn't currently owner of notification, will be silently discarded.
@@ -1039,6 +1319,8 @@ SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes,
 	struct mqueue_inode_info *info;
 	struct sk_buff *nc;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	if (u_notification) {
 		if (copy_from_user(&notification, u_notification,
 					sizeof(struct sigevent)))
@@ -1164,6 +1446,8 @@ SYSCALL_DEFINE3(mq_getsetattr, mqd_t, mq
 	struct inode *inode;
 	struct mqueue_inode_info *info;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	if (u_mqstat != NULL) {
 		if (copy_from_user(&mqstat, u_mqstat, sizeof(struct mq_attr)))
 			return -EFAULT;
@@ -1266,6 +1550,8 @@ static int __init init_mqueue_fs(void)
 {
 	int error;
 
+	DEBUG(MQ_ENABLE_DEBUG, "");
+
 	mqueue_inode_cachep = kmem_cache_create("mqueue_inode_cache",
 				sizeof(struct mqueue_inode_info), 0,
 				SLAB_HWCACHE_ALIGN, init_once);
--- a/ipc/msgutil.c
+++ b/ipc/msgutil.c
@@ -103,6 +103,64 @@ out_err:
 	return ERR_PTR(err);
 }
 
+struct msg_msg *safeg_load_msg(const void *src, int len)
+{
+	struct msg_msg *msg;
+	struct msg_msgseg **pseg;
+	int err;
+	int alen;
+
+	alen = len;
+	if (alen > DATALEN_MSG)
+		alen = DATALEN_MSG;
+
+	msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL);
+	if (msg == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	msg->next = NULL;
+	msg->security = NULL;
+
+	if (memcpy(msg + 1, src, alen) == NULL){
+		err = -EFAULT;
+		goto out_err;
+	}
+
+	len -= alen;
+	src = ((char *)src) + alen;
+	pseg = &msg->next;
+	while (len > 0) {
+		struct msg_msgseg *seg;
+		alen = len;
+		if (alen > DATALEN_SEG)
+			alen = DATALEN_SEG;
+		seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL);
+		if (seg == NULL) {
+			err = -ENOMEM;
+			goto out_err;
+		}
+		*pseg = seg;
+		seg->next = NULL;
+		if (memcpy(seg + 1, src, alen)) {
+			err = -EFAULT;
+			goto out_err;
+		}
+		pseg = &seg->next;
+		len -= alen;
+		src = ((char *)src) + alen;
+	}
+
+	err = security_msg_msg_alloc(msg);
+	if (err)
+		goto out_err;
+
+	return msg;
+
+	out_err:
+	free_msg(msg);
+	return ERR_PTR(err);
+}
+
 int store_msg(void __user *dest, struct msg_msg *msg, int len)
 {
 	int alen;
@@ -130,6 +188,33 @@ int store_msg(void __user *dest, struct 
 	return 0;
 }
 
+int safeg_store_msg(void *dest, struct msg_msg *msg, int len)
+{
+	int alen;
+	struct msg_msgseg *seg;
+
+	alen = len;
+	if (alen > DATALEN_MSG)
+		alen = DATALEN_MSG;
+	if (memcpy(dest, msg + 1, alen) == NULL)
+		return -1;
+
+	len -= alen;
+	dest = ((char *)dest) + alen;
+	seg = msg->next;
+	while (len > 0) {
+		alen = len;
+		if (alen > DATALEN_SEG)
+			alen = DATALEN_SEG;
+		if (memcpy(dest, seg + 1, alen) == NULL)
+			return -1;
+		len -= alen;
+		dest = ((char *)dest) + alen;
+		seg = seg->next;
+	}
+	return 0;
+}
+
 void free_msg(struct msg_msg *msg)
 {
 	struct msg_msgseg *seg;
--- /dev/null
+++ b/safeg/README.OLD
@@ -0,0 +1,69 @@
+README
+
+This directory contains code for the voluntary return integrated scheduling
+framework.
+
+
+MAIN FILES
+
+        Kconfig
+                Configuration options and help
+
+        Makefile
+                Links the modules 'safeg.o' and 'safeg_latency.o' (if
+                voluntary return is configured) with the Linux kernel.
+                The module 'safeg.o' corresponds to one of the appli-
+                cations 'safeg-xxxx.c' that must be linked to the file
+                name 'safeg.c'
+
+        safeg_latency.[h,c]
+                Files containing the switch_hook() function to perform
+                the voluntary return through SafeG
+
+        safeg_syscalls.h
+                Definition of the function safeg_switch_to_t()
+
+EXAMPLES
+
+
+        safeg-debugfs.c
+                Simple application that just creates a boolean value in
+                the debugfs filesystem. It does not need SafeG or ASP
+                actually. It was just created as a test to use a boolean
+                value to activate/deactivate the voluntary return from
+                user space (root privileges)
+
+        safeg-rtasks.c
+                Simple application that just creates a group of periodic
+                tasks with real-time priority. In the Trust world, use
+                the 'obj_safeg_btask application'. By enabling 'DBG_VOL_RET'
+                in safeg_latency.h, it is possible to see more or less
+                that the framework is working.
+
+        safeg-shvar.c
+                Simple application that shares data with Trust world. In
+                the Trust world, use 'obj_safeg_smc_shvar'. The data is
+                shared in different ways to solve the problem of synonyms
+                in virtual caches: invalidate dcache; change to uncached;
+                use dma_alloc_consistent; invalidate cache lines;
+
+BUILD
+
+        First, configure the kernel with support for SafeG and Voluntary
+        Return:
+
+        $ make ARCH=arm \
+        CROSS_COMPILE=/home/dsl/app/arm-none-eabi-2007q1-21/bin/arm-none-eabi- \
+        O=/home/dsl/kernels/linux-2.6.24-working/build/ menuconfig
+
+        Then, select the application you want to compile:
+
+        $ ln -s safeg-xxxx.c safeg.c
+
+        Alternatively, build user-space applications as in the directory
+        rt-tests of safeg repository. Finally, compile the Linux kernel:
+
+        $ make ARCH=arm \
+        CROSS_COMPILE=/home/dsl/app/arm-none-eabi-2007q1-21/bin/arm-none-eabi- \
+        O=/home/dsl/kernels/linux-2.6.24-working/build/ uImage
+
--- /dev/null
+++ b/safeg/safeg-debugfs.c
@@ -0,0 +1,84 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+#include <asm/io.h>         /* for virt_to_phys */
+#include <linux/kthread.h>  /* for kthreads */
+#include <linux/delay.h>    /* for msleep */
+#include <linux/sched.h>
+#include <linux/debugfs.h>
+
+#define TASK_PRIORITY   12
+#define PERIOD_MS      1000
+
+static struct dentry *safeg_debugfs_dir, *safeg_debugfs_activate;
+static u32 safeg_vret_active = 0;
+
+static int the_task(void *arg)
+{
+	int n = 0;
+	struct sched_param schedpar;
+
+	printk(KERN_INFO "Task starts\n");
+
+	schedpar.sched_priority = TASK_PRIORITY;
+	sched_setscheduler(current, SCHED_FIFO, &schedpar);
+
+	while (1) {
+		schedule_timeout_interruptible
+			(msecs_to_jiffies(PERIOD_MS));
+		if (safeg_vret_active)
+			printk(KERN_INFO "task bool:%d (%d)\n",
+				safeg_vret_active, n++);
+	}
+
+	return 0;
+}
+
+static int __init safeg_init(void)
+{
+	printk(KERN_INFO "SAFEG driver initialization\n");
+
+	safeg_debugfs_dir = debugfs_create_dir("safeg", NULL);
+	if (!safeg_debugfs_dir)
+		goto error;
+
+	safeg_debugfs_activate =
+		debugfs_create_bool("activate_voluntary_return", 0644,
+				     safeg_debugfs_dir, &safeg_vret_active);
+	if (!safeg_debugfs_activate)
+		goto error;
+
+	kthread_run(the_task, NULL, "safeg");
+	return 0;
+
+error:
+	debugfs_remove(safeg_debugfs_dir);
+	debugfs_remove(safeg_debugfs_activate);
+	printk(KERN_INFO "ERROR in SAFEG initialization\n");
+	return -1;
+}
+
+static void __exit safeg_exit(void)
+{
+	debugfs_remove(safeg_debugfs_dir);
+	debugfs_remove(safeg_debugfs_activate);
+	printk(KERN_INFO "Goodbye SAFEG\n");
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg-fifo.c
@@ -0,0 +1,175 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+#include <asm/io.h>         /* for virt_to_phys, ioremap */
+#include <linux/sched.h>
+#include <linux/fs.h>       /* for alloc_chrdev_region */
+#include <linux/cdev.h>     /* for cdev_alloc */
+#include "../../safeg-fifo/safeg/nt_safeg_syscalls.h"
+#include <asm/uaccess.h>    /* for copy_to/from_user */
+
+#define DBG_INIT false
+
+#ifndef DEBUG
+#define DEBUG(enable,x,args...)  \
+    if(enable) printk(KERN_INFO "" x, ##args)
+#endif /* DEBUG */
+
+#include <linux/ioctl.h>
+
+// 'j' 00-3F   linux/joystick.h
+#define FIFO_IOCTL_CMD_WRITE    _IOWR('j', 0x43, int)
+#define FIFO_IOCTL_CMD_READ     _IOWR('j', 0x44, int)
+
+/*
+ * MODULE VARIABLES
+ */
+static int major;
+static struct cdev safeg_cdev;
+
+/*
+ * OPEN
+ */
+static int safeg_open(struct inode *inode, struct file *filp)
+{
+    DEBUG(DBG_INIT, "OPEN called\n");
+    return 0;
+}
+
+/*
+ * IOCTLs
+ */
+unsigned char buffer[2048];
+
+int ioctl_safeg_fifo_write(unsigned long arg)
+{
+    struct safeg_fifo_msg user_msg;
+    struct safeg_fifo_msg kernel_msg;
+
+    // first get the user message
+    if (copy_from_user((void *)&user_msg, (void *)arg, sizeof(user_msg)))
+        return -EFAULT;
+
+    // then prepare a kernel message for safeg
+    kernel_msg.id     = user_msg.id;
+    kernel_msg.bytes  = (user_msg.bytes > sizeof(buffer))? sizeof(buffer): user_msg.bytes;
+    kernel_msg.buffer = (unsigned char *)__pa(buffer);
+
+    if (copy_from_user((void *)buffer, (void *)user_msg.buffer, kernel_msg.bytes))
+        return -EFAULT;
+
+    // then send it to SafeG (note that all address sent are physical)
+    nt_safeg_fifo_write((struct safeg_fifo_msg *)__pa((void *)&kernel_msg));
+
+    // then write the number of bytes written to user
+    user_msg.rw_bytes = kernel_msg.rw_bytes;
+    if (copy_to_user((void *)arg, &user_msg, sizeof(user_msg)))
+        return -EFAULT;
+
+    return 0;
+}
+
+int ioctl_safeg_fifo_read(unsigned long arg)
+{
+    struct safeg_fifo_msg user_msg;
+    struct safeg_fifo_msg kernel_msg;
+
+    // first get the user message
+    if (copy_from_user((void *)&user_msg, (void *)arg, sizeof(user_msg)))
+        return -EFAULT;
+
+    // then prepare a kernel message for safeg
+    kernel_msg.id     = user_msg.id;
+    kernel_msg.bytes  = (user_msg.bytes > sizeof(buffer))? sizeof(buffer): user_msg.bytes;
+    kernel_msg.buffer = (unsigned char *)__pa(buffer);
+
+    // then send it to SafeG (note that all address sent are physical)
+    nt_safeg_fifo_read((struct safeg_fifo_msg *)__pa((void *)&kernel_msg));
+
+    // then copy the read data to the user buffer
+    if (copy_to_user((void *)user_msg.buffer, (void *)&buffer, kernel_msg.rw_bytes))
+        return -EFAULT;
+
+    // then write the number of bytes read to user
+    user_msg.rw_bytes = kernel_msg.rw_bytes;
+    if (copy_to_user((void *)arg, &user_msg, sizeof(user_msg)))
+        return -EFAULT;
+
+    return 0;
+}
+
+static int safeg_ioctl(struct inode *inode, struct file *filp,
+                       unsigned int cmd, unsigned long arg)
+{
+    DEBUG(DBG_INIT, "IOCTL called (cmd:%u, arg:%lu)\n", cmd, arg);
+
+    switch(cmd) {
+        case FIFO_IOCTL_CMD_WRITE:
+            DEBUG(DBG_INIT, "FIFO_IOCTL_CMD_WRITE(%u)\n", cmd);
+            return ioctl_safeg_fifo_write(arg);
+            break;
+        case FIFO_IOCTL_CMD_READ:
+            DEBUG(DBG_INIT, "FIFO_IOCTL_CMD_READ(%u)\n", cmd);
+            return ioctl_safeg_fifo_read(arg);
+            break;
+        default:
+            DEBUG(DBG_INIT, "IOCTL cmd (%u): not available\n", cmd);
+            return -ENOTTY;
+    }
+}
+
+static struct file_operations safeg_fops = {
+    .owner   = THIS_MODULE,
+    .open    = safeg_open,
+    .ioctl   = safeg_ioctl,
+};
+
+static int __init safeg_init(void)
+{
+    int err;
+    dev_t dev;
+
+    DEBUG(DBG_INIT, "Allocating SafeG major/minor\n");
+    err = alloc_chrdev_region(&dev, 0, 1,"safeg");
+    major = MAJOR(dev);
+
+    DEBUG(DBG_INIT, "mknod /dev/safeg c %d 0 (/proc/devices)\n", major);
+    DEBUG(DBG_INIT, "chmod 0664 /dev/safeg\n");
+
+    DEBUG(DBG_INIT, "Register SafeG char device\n");
+    cdev_init(&safeg_cdev, &safeg_fops);
+    safeg_cdev.owner = THIS_MODULE;
+    err = cdev_add (&safeg_cdev, dev, 1);
+    if (err) goto init_error;
+
+    return 0;
+
+init_error:
+    DEBUG(DBG_INIT, "Error %d at initialization", err);
+    return err;
+}
+
+static void __exit safeg_exit(void)
+{
+    DEBUG(DBG_INIT, "Goodbye SAFEG\n");
+    cdev_del(&safeg_cdev);
+    unregister_chrdev_region(MKDEV(major, 0), 1);
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG fifo driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg-mmap.c
@@ -0,0 +1,125 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+#include <asm/io.h>         /* for virt_to_phys, ioremap */
+#include <linux/fs.h>       /* for alloc_chrdev_region */
+#include <linux/cdev.h>     /* for cdev_alloc */
+#include <linux/dma-mapping.h> /* for dma_alloc_coherent */
+
+#define DBG_INIT true
+
+#ifndef DEBUG
+#define DEBUG(enable,x,args...)  \
+	if(enable) printk(KERN_INFO "" x, ##args)
+#endif /* DEBUG */
+
+#define SHM_PHYS_ADDRESS	0x4000000UL /* 64MB */
+#define SHM_SIZE		0x100000UL /* 1MB */
+
+static int major;
+static struct cdev safeg_cdev;
+static u32 pa;
+static void *va;
+
+static int safeg_open(struct inode *inode, struct file *filp)
+{
+	DEBUG(DBG_INIT, "OPEN called\n");
+	return 0;
+}
+
+static int safeg_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+// 	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+// 			    vma->vm_end - vma->vm_start,
+// 			    vma->vm_page_prot))
+	DEBUG(DBG_INIT, "MMAP called\n");
+	if (remap_pfn_range(vma,
+			    vma->vm_start,
+			    SHM_PHYS_ADDRESS >> PAGE_SHIFT,
+			    vma->vm_end - vma->vm_start, /* TODO: check < SHM_SIZE */
+			    vma->vm_page_prot))
+		return -EAGAIN;
+
+	/* TODO: check Remapping Specific I/O Regions section */
+// 	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
+// 	unsigned long physical = SHM_PHYS_ADDRESS + off;
+// 	unsigned long vsize = vma->vm_end - vma->vm_start;
+// 	unsigned long psize = simple_region_size - off;
+// 	if (vsize > psize)
+// 		return -EINVAL; /* spans too high */
+// 	remap_pfn_range(vma, vma_>vm_start, physical, vsize, vma->vm_page_prot);
+
+	return 0;
+}
+
+static struct file_operations safeg_fops = {
+	.owner   = THIS_MODULE,
+	.open    = safeg_open,
+	.mmap    = safeg_mmap,
+};
+
+static int __init safeg_init(void)
+{
+	int err;
+	dev_t dev;
+// 	dma_addr_t shm_handle;
+
+	DEBUG(DBG_INIT, "SafeG allocate shared memory\n");
+
+	va = ioremap_nocache(SHM_PHYS_ADDRESS, SHM_SIZE);
+	pa = (unsigned long)SHM_PHYS_ADDRESS;
+
+	memset(va, 0x69, 100);
+
+// 	va = dma_alloc_coherent(NULL, 4, &shm_handle, GFP_KERNEL);
+// 	if (!va) {
+// 		err = ENOMEM;
+// 		goto init_error;
+// 	}
+// 	pa  = (unsigned long)shm_handle;
+
+	DEBUG(DBG_INIT, "Allocating SafeG major/minor\n");
+	err = alloc_chrdev_region(&dev, 0, 1,"safeg");
+	major = MAJOR(dev);
+
+	DEBUG(DBG_INIT, "mknod /dev/safeg c %d 0 (/proc/devices)\n", major);
+	DEBUG(DBG_INIT, "chmod 0664 /dev/safeg\n");
+
+	DEBUG(DBG_INIT, "Register SafeG char device\n");
+
+	cdev_init(&safeg_cdev, &safeg_fops);
+	safeg_cdev.owner = THIS_MODULE;
+	err = cdev_add (&safeg_cdev, dev, 1);
+	if (err) goto init_error;
+
+	return 0;
+
+init_error:
+	DEBUG(DBG_INIT, "Error %d at initialization", err);
+	return err;
+}
+
+static void __exit safeg_exit(void)
+{
+	DEBUG(DBG_INIT, "Goodbye SAFEG\n");
+	cdev_del(&safeg_cdev);
+	unregister_chrdev_region(MKDEV(major, 0), 1);
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg-mqueue.c
@@ -0,0 +1,124 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+// execute this in the target:
+// mount -t debugfs nodev /sys/kernel/debug
+// echo 1 > /sys/kernel/debug/safeg/activate_voluntary_return
+// mount -t mqueue none /dev/mqueue
+// ./mq_send.exe -p 4 -b 42 -c 1 /safeg_mq_0
+// ./mq_receive.exe -c 1 /safeg_mq_1
+
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+#include <asm/io.h>         /* for virt_to_phys */
+#include <linux/kthread.h>  /* for kthreads */
+#include <linux/delay.h>    /* for msleep */
+#include <linux/sched.h>
+#include <linux/debugfs.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/mqueue.h>
+
+#define TASK_PRIORITY   12
+#define PERIOD_MS      1000
+
+static struct dentry *safeg_debugfs_dir, *safeg_debugfs_activate;
+static u32 safeg_vret_active = 0;
+
+extern int safeg_mq_create(char *name);
+
+extern int safeg_mq_receive(mqd_t mqdes,
+			    char *u_msg_ptr,
+			    size_t msg_len,
+			    unsigned int *msg_prio);
+
+extern int safeg_mq_send(mqd_t mqdes,
+			 const char *u_msg_ptr,
+			 size_t msg_len,
+			 unsigned int msg_prio);
+
+char buffer[10000];
+
+static int the_task(void *arg)
+{
+	struct sched_param schedpar;
+	int err;
+	mqd_t id0, id1;
+	unsigned int pri;
+
+	printk(KERN_INFO "Task starts\n");
+
+	schedpar.sched_priority = TASK_PRIORITY;
+	sched_setscheduler(current, SCHED_FIFO, &schedpar);
+
+	while (1) {
+		schedule_timeout_interruptible(msecs_to_jiffies(PERIOD_MS));
+		if (safeg_vret_active) goto recvloop;
+	}
+
+recvloop:
+	id0 = (mqd_t)safeg_mq_create("safeg_mq_0");
+	printk("created mqueue (id0:%d)\n", id0);
+
+	id1 = (mqd_t)safeg_mq_create("safeg_mq_1");
+	printk("created mqueue (id1:%d)\n", id1);
+
+	while(1) {
+		schedule_timeout_interruptible(msecs_to_jiffies(PERIOD_MS));
+		err = safeg_mq_receive(id0, buffer, sizeof(buffer),&pri);
+		printk("mq received %d bytes (pri:%u)\n", err, pri);
+
+		err = safeg_mq_send(id1, buffer, (size_t)err, pri);
+		printk("message forwarded\n");
+	}
+	return 0;
+}
+
+static int __init safeg_init(void)
+{
+	printk(KERN_INFO "SAFEG driver initialization\n");
+
+	safeg_debugfs_dir = debugfs_create_dir("safeg", NULL);
+	if (!safeg_debugfs_dir)
+		goto error;
+
+	safeg_debugfs_activate =
+		debugfs_create_bool("activate_voluntary_return", 0644,
+				     safeg_debugfs_dir, &safeg_vret_active);
+	if (!safeg_debugfs_activate)
+		goto error;
+
+	kthread_run(the_task, NULL, "safeg");
+	return 0;
+
+error:
+	debugfs_remove(safeg_debugfs_dir);
+	debugfs_remove(safeg_debugfs_activate);
+	printk(KERN_INFO "ERROR in SAFEG initialization\n");
+	return -1;
+}
+
+static void __exit safeg_exit(void)
+{
+	debugfs_remove(safeg_debugfs_dir);
+	debugfs_remove(safeg_debugfs_activate);
+
+	printk(KERN_INFO "Goodbye SAFEG\n");
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg-mqueue2.c
@@ -0,0 +1,132 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+#include <asm/io.h>         /* for virt_to_phys */
+#include <linux/interrupt.h>   /* for request_irq */
+#include <linux/kthread.h>  /* for kthreads */
+#include <linux/delay.h>    /* for msleep */
+#include <linux/debugfs.h>
+#include <linux/mqueue.h>
+#include "safeg_syscalls.h" /* for safeg_switch_to_t */
+
+// Kernel command line: root=/dev/nfs rw
+// nfsroot=192.168.0.34:/home/dsl/kernels/rootfs/nfs,nolock,proto=tcp init=/init
+// rootwait ip=192.168.0.33 mem=64M memmap=64M$64M console=ttyAMA
+// androidboot.console=ttyAMA0 noinitrd
+#define SHM_PHYS_ADDRESS	0x4000000UL /* 64MB */
+#define SHM_SIZE		0x100000UL /* 1MB */
+
+/*
+* Shared variables
+*/
+struct shared_vars_t {
+	int	value;
+};
+
+volatile struct shared_vars_t *shvars = NULL;
+EXPORT_SYMBOL(shvars);
+
+#define TASK_PRIORITY   12
+#define PERIOD_MS      1000
+
+static struct dentry *safeg_debugfs_dir, *safeg_debugfs_activate;
+static u32 safeg_active = 0;
+
+extern int safeg_mq_create(char *name);
+
+extern int safeg_mq_receive(mqd_t mqdes,
+			    char *u_msg_ptr,
+			    size_t msg_len,
+			    unsigned int *msg_prio);
+
+extern int safeg_mq_send(mqd_t mqdes,
+			 const char *u_msg_ptr,
+			 size_t msg_len,
+			 unsigned int msg_prio);
+
+static char buffer[10000];
+
+static irqreturn_t safeg_irq_handler(int irq, void *dev_id)
+{
+	printk(KERN_INFO "IRQ: %u\n", shvars->value);
+	return IRQ_HANDLED;
+}
+
+static int the_task(void *arg)
+{
+	int err;
+	unsigned int pri;
+	mqd_t id0;
+
+	while (1) {
+		schedule_timeout_interruptible(msecs_to_jiffies(PERIOD_MS));
+		if (safeg_active) goto recvloop;
+	}
+
+recvloop:
+	id0 = (mqd_t)safeg_mq_create("safeg_mq_0");
+	printk("created mqueue (id0:%d)\n", id0);
+
+	while(1) {
+		schedule_timeout_interruptible(msecs_to_jiffies(PERIOD_MS));
+		err = safeg_mq_receive(id0, buffer, sizeof(buffer),&pri);
+		printk("mq received %d bytes (pri:%u)\n", err, pri);
+	}
+	return 0;
+}
+
+static int __init safeg_init(void)
+{
+	static void *sh_mem;
+
+	printk(KERN_INFO "SAFEG driver initialization\n");
+
+	safeg_debugfs_dir = debugfs_create_dir("safeg", NULL);
+	if (!safeg_debugfs_dir)
+		goto error;
+
+	safeg_debugfs_activate =
+	debugfs_create_bool("activate_mq", 0644,
+						safeg_debugfs_dir, &safeg_active);
+	if (!safeg_debugfs_activate)
+		goto error;
+
+	sh_mem = ioremap_nocache(SHM_PHYS_ADDRESS, SHM_SIZE);
+	shvars = (struct shared_vars_t *)sh_mem;
+
+	if (request_irq(33, safeg_irq_handler, 0, "safeg", NULL) != 0)
+		return -1;
+
+	kthread_run(the_task, NULL, "safeg");
+// 	safeg_switch_to_t(T_SMC_SWITCH_RET, 0);
+	return 0;
+
+error:
+	debugfs_remove(safeg_debugfs_dir);
+	debugfs_remove(safeg_debugfs_activate);
+	printk(KERN_INFO "ERROR in SAFEG initialization\n");
+	return -1;
+}
+
+static void __exit safeg_exit(void)
+{
+	printk(KERN_INFO "Goodbye SAFEG\n");
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg-panic.c
@@ -0,0 +1,76 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+#include <asm/io.h>         /* for virt_to_phys, ioremap */
+#include <linux/fs.h>       /* for alloc_chrdev_region */
+#include <linux/cdev.h>     /* for cdev_alloc */
+#include <linux/dma-mapping.h> /* for dma_alloc_coherent */
+
+#define DBG_INIT true
+
+#ifndef DEBUG
+#define DEBUG(enable,x,args...)  \
+    if(enable) printk(KERN_INFO "" x, ##args)
+#endif /* DEBUG */
+
+static int major;
+static struct cdev safeg_cdev;
+
+static int safeg_open(struct inode *inode, struct file *filp)
+{
+    panic("CRASH!!");
+	return 0;
+}
+
+static struct file_operations safeg_fops = {
+	.owner   = THIS_MODULE,
+	.open    = safeg_open,
+};
+
+static int __init safeg_init(void)
+{
+	int err;
+	dev_t dev;
+
+	err = alloc_chrdev_region(&dev, 0, 1,"safeg");
+	major = MAJOR(dev);
+
+	DEBUG(DBG_INIT, "mknod /dev/safeg c %d 0 (/proc/devices)\n", major);
+	DEBUG(DBG_INIT, "chmod 0664 /dev/safeg\n");
+
+	cdev_init(&safeg_cdev, &safeg_fops);
+	safeg_cdev.owner = THIS_MODULE;
+	err = cdev_add (&safeg_cdev, dev, 1);
+	if (err) goto init_error;
+
+	return 0;
+
+init_error:
+	DEBUG(DBG_INIT, "Error %d at initialization", err);
+	return err;
+}
+
+static void __exit safeg_exit(void)
+{
+	DEBUG(DBG_INIT, "Goodbye SAFEG\n");
+	cdev_del(&safeg_cdev);
+	unregister_chrdev_region(MKDEV(major, 0), 1);
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG panic driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg-ring.c
@@ -0,0 +1,300 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+#include <linux/kthread.h>  /* for kthreads */
+#include <linux/delay.h>    /* for msleep */
+#include <linux/debugfs.h>  /* for debugfs functions */
+#include <linux/mqueue.h>   /* for safeg_mq_* usage */
+#include <linux/wait.h>     /* for wait_event_, wake_up_interruptible */
+#include <linux/dma-mapping.h> /* for ioremap_nocache */
+#include <linux/interrupt.h>   /* for request_irq */
+
+#define DBG_INIT true
+
+#define POLICY_POLLING false
+
+#ifndef DEBUG
+#define DEBUG(enable,x,args...)  \
+	if(enable) printk(KERN_INFO "" x, ##args)
+#endif /* DEBUG */
+
+// Kernel command line: root=/dev/nfs rw
+// nfsroot=192.168.0.34:/home/dsl/kernels/rootfs/nfs,nolock,proto=tcp init=/init
+// rootwait ip=192.168.0.33 mem=64M memmap=64M$64M console=ttyAMA
+// androidboot.console=ttyAMA0 noinitrd
+// NOTE:
+// memmap=nn$ss means Mark specific memory (from ss to ss+nn) as reserved.
+//
+// execute this in the target:
+// mount -t debugfs nodev /sys/kernel/debug
+// echo 1 > /sys/kernel/debug/safeg/activate_inter_os
+// mount -t mqueue none /dev/mqueue
+// ./mq_send.exe -p 4 -b 42 -c 1 /safeg_mq_0
+// ./mq_receive.exe -c 1 /safeg_mq_1
+
+#define SHM_PHYS_ADDRESS	0x4000000UL /* 64MB */
+#define SHM_SIZE		0x100000UL /* 1MB */
+
+#define MX_MSG_DATA_BYTES	16 /* in bytes */
+#define MX_NUM_MSG		16 /* in messages (must be power of 2) */
+
+#define MX_NUM_MQUEUES		5 /* 0..MX_NUM_MQUEUEs-1 */
+
+// debug fs activation variables
+static struct dentry *safeg_debugfs_dir, *safeg_debugfs_activate;
+static u32 safeg_interos_active = 0;
+
+// mq functions
+extern int safeg_mq_create(char *name);
+
+extern int safeg_mq_receive(mqd_t mqdes,
+			    char *u_msg_ptr,
+			    size_t msg_len,
+			    unsigned int *msg_prio);
+
+extern int safeg_mq_send(mqd_t mqdes,
+			 const char *u_msg_ptr,
+			 size_t msg_len,
+			 unsigned int msg_prio);
+
+static mqd_t mqdes_rcv_table[MX_NUM_MQUEUES]; // to map ID -> mqd_t mqdes
+static mqd_t mqdes_snd_table[MX_NUM_MQUEUES]; // to map ID -> mqd_t mqdes
+
+static mqd_t id_to_rcvmqd(uint32_t id)
+{
+	if(id > MX_NUM_MQUEUES) return (mqd_t)-1;
+	return mqdes_rcv_table[id];
+}
+
+static mqd_t id_to_sndmqd(uint32_t id)
+{
+	if(id > MX_NUM_MQUEUES) return (mqd_t)-1;
+	return mqdes_snd_table[id];
+}
+
+// Inter OS communications data structures
+struct safeg_msg_t {
+	uint32_t id;
+	uint32_t pri;
+	uint32_t size;
+	uint8_t  data[MX_MSG_DATA_BYTES];
+};
+
+struct safeg_ring_t {
+	uint32_t prod_idx;
+	uint32_t cons_idx;
+	struct safeg_msg_t msg_queue[MX_NUM_MSG];
+};
+
+struct safeg_inter_os_data_t {
+	volatile uint32_t nt_state;
+#define STA_CLOSED 0
+#define STA_LISTEN 1
+	struct safeg_ring_t t2nt_ring;
+	struct safeg_ring_t nt2t_ring;
+};
+
+struct safeg_inter_os_data_t *inter_os_data = NULL;
+
+// Operations on the Ring Buffers
+// No synchronization (one reader and one writer)
+// They are all non-blocking so the user must call get_count to make
+// sure there is space of messages waiting
+// MX_NUM_MSG is 2^n so we can use free running indexes and then truncate them
+#define TRUNC(x) ((x) & (MX_NUM_MSG - 1))
+
+static uint32_t safeg_ring_get_count(const struct safeg_ring_t *ring)
+{
+	return TRUNC(ring->prod_idx - ring->cons_idx);
+}
+
+static void safeg_ring_read_msg(struct safeg_ring_t *ring,
+				struct safeg_msg_t  *msg)
+{
+	memcpy(msg, &ring->msg_queue[TRUNC(ring->cons_idx)], sizeof(*msg));
+	smp_wmb(); // just in case, a memory barrier
+	ring->cons_idx++;
+}
+
+// static void safeg_ring_write_msg(struct safeg_ring_t *ring,
+// 				 const struct safeg_msg_t  *msg)
+// {
+// 	memcpy(&ring->msg_queue[TRUNC(ring->prod_idx)], msg, sizeof(*msg));
+// 	smp_wmb(); // just in case a memory barrier
+// 	ring->prod_idx++;
+// }
+
+static DECLARE_WAIT_QUEUE_HEAD(wq);
+static int flag = 0;
+
+// message reception task (forwards it to local queue)
+static int task_ring_rcv(void *arg)
+{
+	struct safeg_msg_t rcv_msg;
+	struct safeg_ring_t *rcv_ring = &inter_os_data->t2nt_ring;
+	int err;
+	char mq_name[50];  // TODO: adjust more safeg_mq_xxx\0 = 9 + xxx + 1
+	int i;
+
+	while (1) {
+		schedule_timeout_interruptible(msecs_to_jiffies(1000));
+		if (safeg_interos_active) break;
+	}
+
+	printk(KERN_INFO "Task Ring Recv starts\n");
+
+	// create message queues and save the IDs
+	for(i=0; i<MX_NUM_MQUEUES; i++) {
+		sprintf(mq_name, "safeg_rcvmq_%d", i);
+		mqdes_rcv_table[i] = safeg_mq_create(mq_name);
+	}
+
+	inter_os_data->nt_state = STA_LISTEN;
+
+	while (1) {
+		if(POLICY_POLLING) {
+			schedule_timeout_interruptible(msecs_to_jiffies(5000));
+		} else {
+			wait_event_interruptible(wq, flag != 0);
+			flag = 0;
+		}
+
+		// Poll the reception ring buffer: t2nt_ring
+		if (safeg_ring_get_count(rcv_ring) > 0) {
+			safeg_ring_read_msg(rcv_ring, &rcv_msg);
+
+			err = safeg_mq_send(id_to_rcvmqd(rcv_msg.id),
+					    rcv_msg.data, rcv_msg.size,
+					    rcv_msg.pri);
+		}
+	}
+
+	return 0;
+}
+
+// message sending task
+static int task_ring_snd(void *arg)
+{
+	struct safeg_msg_t snd_msg;
+	struct safeg_ring_t *snd_ring = &inter_os_data->nt2t_ring;
+	int err;
+	char mq_name[50];  // TODO: adjust more safeg_mq_xxx\0 = 9 + xxx + 1
+	int i;
+
+	while (1) {
+		schedule_timeout_interruptible(msecs_to_jiffies(1000));
+		if (safeg_interos_active) break;
+	}
+
+	printk(KERN_INFO "Task Ring Send starts\n");
+
+	// create message queues and save the IDs
+	for(i=0; i<MX_NUM_MQUEUES; i++) {
+		sprintf(mq_name, "safeg_sndmq_%d", i);
+		mqdes_snd_table[i] = safeg_mq_create(mq_name);
+	}
+
+	inter_os_data->nt_state = STA_LISTEN;
+
+	while (1) {
+		// wait for an user space message
+		err = safeg_mq_receive(id_to_mqd(rcv_msg.id), rcv_msg.data,
+				       rcv_msg.size, rcv_msg.pri);
+
+
+extern int safeg_mq_receive(mqd_t mqdes,
+			    char *u_msg_ptr,
+			    size_t msg_len,
+			    unsigned int *msg_prio);
+
+
+
+// 		schedule_timeout_interruptible(msecs_to_jiffies(5000));
+		wait_event_interruptible(wq, flag != 0);
+		flag = 0;
+
+		// Poll the reception ring buffer: t2nt_ring
+		if (safeg_ring_get_count(rcv_ring) > 0) {
+			safeg_ring_read_msg(rcv_ring, &rcv_msg);
+// 			printk(KERN_INFO "safeg rcv. id:%u pri:%u size:%u\n",
+// 			       rcv_msg.id, rcv_msg.pri, rcv_msg.size);
+			err = safeg_mq_send(id_to_mqd(rcv_msg.id), rcv_msg.data,
+					    rcv_msg.size, rcv_msg.pri);
+		}
+	}
+
+	return 0;
+}
+
+
+static irqreturn_t safeg_irq_handler(int irq, void *dev_id)
+{
+	if (!safeg_interos_active) return IRQ_HANDLED;
+
+	printk(KERN_INFO "SafeG IRQ handler\n");
+	flag = 1;
+	wake_up_interruptible(&wq);
+	return IRQ_HANDLED;
+}
+
+static int __init safeg_init(void)
+{
+	int id;
+
+	DEBUG(DBG_INIT, "SafeG initialization\n");
+
+	safeg_debugfs_dir = debugfs_create_dir("safeg", NULL);
+	if (!safeg_debugfs_dir)
+		goto error;
+
+	safeg_debugfs_activate =
+		debugfs_create_bool("activate_inter_os", 0644,
+				     safeg_debugfs_dir, &safeg_interos_active);
+	if (!safeg_debugfs_activate)
+		goto error;
+
+	// remap the inter-os data memory region
+	inter_os_data = (struct safeg_inter_os_data_t *)
+		ioremap_nocache(SHM_PHYS_ADDRESS, SHM_SIZE);
+
+	if (request_irq(33, safeg_irq_handler, 0, "safeg", NULL) != 0)
+		goto error;
+
+	for(id=0; id<MX_NUM_MQUEUES; id++) {
+		kthread_run(task_ring_rcv, (void *)id, "task-ring-rcv-%d", id);
+		kthread_run(task_ring_snd, (void *)id, "task-ring-snd-%d", id);
+	}
+
+	return 0;
+
+error:
+	printk(KERN_INFO "ERROR in SAFEG initialization\n");
+	debugfs_remove(safeg_debugfs_dir);
+	debugfs_remove(safeg_debugfs_activate);
+	return -1;
+}
+
+static void __exit safeg_exit(void)
+{
+	debugfs_remove(safeg_debugfs_dir);
+	debugfs_remove(safeg_debugfs_activate);
+	printk(KERN_INFO "Goodbye world\n");
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg-rtasks.c
@@ -0,0 +1,193 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+#include <asm/io.h>         /* for virt_to_phys */
+#include <linux/kthread.h>  /* for kthreads */
+#include <linux/delay.h>    /* for msleep */
+#include <linux/sched.h>
+#include "safeg_latency.h"
+
+#include <linux/time.h>
+#include <linux/posix-timers.h>
+#include <linux/ktime.h>
+#include <linux/hrtimer.h>
+
+#ifdef KTASK_ENABLE
+
+// Map kernel(0..98) => user(99..1)
+#define KPRIO_TO_USER(prio) (99 - (prio))
+
+#define TASK1_PRIORITY  KPRIO_TO_USER(LTASK0_NT_LW_PRIORITY) /* 5 => 94 */
+#define TASK2_PRIORITY  KPRIO_TO_USER(LTASK1_NT_LW_PRIORITY) /* 11 => 88 */
+#define TASK3_PRIORITY  KPRIO_TO_USER(LTASK1_NT_LW_PRIORITY+1) /* 12 => 87 */
+
+#define PERIOD_NS       2000000000UL /* 2s=2000000000U, 500ms=500000000U*/
+#define EXEC_NS		 200000000UL /* 200ms=200000000U, 5ms=5000000U */
+
+#define MAX_RT_TEST_THREADS	3
+
+struct test_thread_data {
+	int id;
+	u64 period_ns;
+	u64 exec_ns;
+	int prio;
+	struct task_struct *task;
+};
+
+static struct test_thread_data thread_data[MAX_RT_TEST_THREADS] = {
+	{.id        = 0,
+	 .period_ns = PERIOD_NS,
+	 .exec_ns   = EXEC_NS,
+	 .prio      = TASK1_PRIORITY,
+	 .task      = NULL},
+	{.id        = 1,
+	 .period_ns = PERIOD_NS*2,
+	 .exec_ns   = EXEC_NS*3,
+	 .prio      = TASK2_PRIORITY,
+	 .task      = NULL},
+	{.id        = 2,
+	 .period_ns = PERIOD_NS*3,
+	 .exec_ns   = EXEC_NS*5,
+	 .prio      = TASK3_PRIORITY,
+	 .task      = NULL}
+};
+
+#define THREAD_CLOCK   MAKE_THREAD_CPUCLOCK(0, CPUCLOCK_SCHED)
+
+// NOTE: this functions generates a lot of interrupts!!!!
+
+void eat(u64 ns)
+{
+	int ret;
+	struct timespec now, end;
+
+	ret = posix_cpu_clock_get (THREAD_CLOCK, &end);
+	if (ret != 0)
+		printk(KERN_INFO "ERROR %d\n", ret);
+
+	timespec_add_ns(&end, ns);
+
+	do {
+		ret = posix_cpu_clock_get(THREAD_CLOCK, &now);
+		if (ret != 0)
+			printk(KERN_INFO "ERROR %d\n", ret);
+	}
+	while ( timespec_compare(&now, &end) < 0);
+}
+
+// static void get_timestamp(unsigned long *s, unsigned long *us)
+// {
+// 	u64 ts = sched_clock();
+// 	*us = do_div(ts, NSEC_PER_SEC);
+// 	*us /= 1000;
+// 	*s = (unsigned long)ts;
+// }
+
+static int the_task(void *arg)
+{
+// 	int n = 0;
+// 	int i;
+	struct test_thread_data *data = &thread_data[(int)arg];
+	struct sched_param schedpar;
+// 	volatile uint32_t result = 0;
+// 	struct timespec begin, end, total;
+// 	unsigned long s, us;
+// 	struct timespec abs_time;
+	printk(KERN_INFO "ktask%d starts\n", data->id);
+
+	schedpar.sched_priority = data->prio;
+	sched_setscheduler(data->task, SCHED_FIFO, &schedpar);
+
+// 	ktime_get_ts(&abs_time);
+
+	while (1) {
+		schedule_timeout_interruptible
+			(nsecs_to_jiffies(data->period_ns));
+
+// 		timespec_add_ns(&abs_time, data->period_ns);
+// 		hrtimer_nanosleep(&abs_time, NULL, HRTIMER_MODE_ABS, CLOCK_MONOTONIC);
+
+// 		msleep(do_div(data->period_ns, 1000000L));
+
+
+// 		CP15_PM_CONTROL_WRITE(0);
+// 		CP15_PM_CYCLE_WRITE(0);
+// 		CP15_PM_CONTROL_WRITE(1);
+
+// 		ktime_get_ts(&begin);
+
+// 		get_timestamp(&s, &us);
+// 		printk(KERN_INFO "[%5lu.%06lu] ktask%d starts eating\n",
+// 		       s, us, data->id);
+
+		//printk(KERN_INFO "ktask%d starts eating\n", data->id);
+		trace_printk("ktask%d starts eating\n", data->id);
+		eat(data->exec_ns);
+		trace_printk("ktask%d finishes eating\n", data->id);
+		//printk(KERN_INFO "ktask%d finishes eating\n", data->id);
+
+// 		get_timestamp(&s, &us);
+// 		printk(KERN_INFO "[%5lu.%06lu] ktask%d finishes eating\n",
+// 		       s, us, data->id);
+
+// 		ktime_get_ts(&end);
+// 		total = timespec_sub(end, begin);
+
+// 		CP15_PM_CYCLE_READ(result);
+// 		result = result / 210;
+//
+// 		printk(KERN_INFO "thread_time:%llu ns, global_time:%u us",
+// 			data->exec_ns, result);
+
+// 		printk(KERN_INFO "thread_time:%llu ns, global_time:%ld ns",
+// 			data->exec_ns, total.tv_nsec);
+	}
+
+	return 0;
+}
+#endif /* KTASK_ENABLE */
+
+static int __init safeg_init(void)
+{
+#ifdef KTASK_ENABLE
+	int id;
+#endif
+
+	printk(KERN_INFO "SAFEG module loaded\n");
+
+#ifdef CONFIG_SAFEG_VOL_RETURN
+	if (latency_initialize() != 0) return -1;
+#endif /* CONFIG_SAFEG_VOL_RETURN */
+
+#ifdef KTASK_ENABLE
+	for (id = 0; id < 1; id++) {
+		thread_data[id].task =
+			kthread_run(the_task, (void *)id, "ktask-%d", id);
+		msleep(80);
+	}
+#endif
+	return 0;
+}
+
+static void __exit safeg_exit(void)
+{
+	printk(KERN_INFO "Goodbye world\n");
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg-rtasks2.c
@@ -0,0 +1,34 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+
+#include "safeg_latency.h"
+
+static int __init safeg_init(void)
+{
+	printk(KERN_INFO "SAFEG module loaded\n");
+	return latency_initialize();
+}
+
+static void __exit safeg_exit(void)
+{
+	printk(KERN_INFO "SafeG module exits\n");
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg-shvar.c
@@ -0,0 +1,210 @@
+/*
+ * SAFEG driver
+ *
+ * Copyright (C) Nagoya University
+ * Daniel Sangorrin <daniel.sangorrin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>   /* for MODULE_AUTHOR..*/
+#include <linux/init.h>     /* for module_init */
+#include <asm/io.h>         /* for virt_to_phys */
+#include <linux/kthread.h>  /* for kthreads */
+#include <linux/delay.h>    /* for msleep */
+#include "safeg_syscalls.h" /* for safeg_switch_to_t */
+#include <linux/dma-mapping.h>
+
+/* Shared variable method */
+// #define SHVAR_METHOD_DMA
+// #define SHVAR_METHOD_BOOTARGS
+#define SHVAR_METHOD_FLUSHCACHE
+
+#ifdef SHVAR_METHOD_BOOTARGS
+// Kernel command line: root=/dev/nfs rw
+// nfsroot=192.168.0.34:/home/dsl/kernels/rootfs/nfs,nolock,proto=tcp init=/init
+// rootwait ip=192.168.0.33 mem=64M memmap=64M$64M console=ttyAMA
+// androidboot.console=ttyAMA0 noinitrd
+#define SHM_PHYS_ADDRESS	0x4000000UL /* 64MB */
+#define SHM_SIZE		0x100000UL /* 1MB */
+#endif
+
+#ifdef SHVAR_METHOD_FLUSHCACHE
+volatile int ltask_id = 0;
+
+/* Whole cache operations */
+#define CP15_ICACHE_INVALIDATE_ALL() \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0)); \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0":: "r"(0))
+
+#define CP15_DCACHE_INVALIDATE_ALL() \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0":: "r"(0))
+
+#define CP15_CACHE_INVALIDATE_BOTH() \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c7, 0":: "r"(0))
+
+#define CP15_DCACHE_CLEAN() \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c10, 0":: "r"(0))
+
+#define CP15_DCACHE_INVALIDATE_CLEAN() \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c14, 0":: "r"(0))
+
+/* Cache line Set/Index operations */
+
+#define CP15_ICACHE_LINE_INDEX_INVALIDATE(x) \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c5, 2"::"r"(x))
+
+#define CP15_DCACHE_LINE_INDEX_INVALIDATE(x) \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c6, 2"::"r"(x))
+
+#define CP15_DCACHE_LINE_INDEX_CLEAN(x) \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c10, 2"::"r"(x))
+
+#define CP15_DCACHE_LINE_INDEX_INVALIDATE_CLEAN(x) \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c14, 2"::"r"(x))
+
+/* Data barrier to make sure all operations are finished */
+#define CP15_DATASYNC_BARRIER() \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c10, 4":: "r"(0))
+
+#else
+volatile int *ltask_id = 0;
+#endif
+
+static struct task_struct *the_task_struct;
+
+static int the_task(void *arg)
+{
+// 	unsigned int way, line, index;
+// 	void *virt_add;
+// 	unsigned long phy_add;
+//
+// 	virt_add = (void *)&ltask_id;
+// 	phy_add  = virt_to_phys(virt_add);
+
+	printk(KERN_INFO "NT Task starts\n");
+
+	while (1) {
+		schedule_timeout_interruptible(msecs_to_jiffies(1000));
+		safeg_switch_to_t(T_SMC_SWITCH_RET, 0);
+
+#ifdef SHVAR_METHOD_FLUSHCACHE
+		/* Solution 1: clean invalidate all D-Cache */
+// 		CP15_DCACHE_INVALIDATE_CLEAN();
+
+		/* Solution 1b: equivalent but line by line */
+// 		for (way=0; way<4; way++) {
+// 			for (line=0; line<256; line++) {
+// 				index = (line << 5) | (way << 30);
+// 				CP15_DCACHE_LINE_INDEX_INVALIDATE_CLEAN(index);
+// 			}
+// 		}
+
+		/* Solution 2: clean invalidate the adecuate entries */
+// 		for (way=0; way<4; way++) {
+// 			index = (phy_add & 0x1FE0) | (way << 30);
+// 			CP15_DCACHE_LINE_INDEX_CLEAN(index);
+// 			CP15_DATASYNC_BARRIER();
+// 			index = ((unsigned int)virt_add & 0x1FE0) | (way << 30);
+// 			CP15_DCACHE_LINE_INDEX_INVALIDATE(index);
+// 		}
+
+		/* Solution 3: set arch/arm/mmu.c to non-cachable (nothing) */
+		/* Solution 4: use the TCM (nothing necessary) */
+
+		printk(KERN_INFO "shvar *(%p) = %d\n", &ltask_id, ltask_id);
+		ltask_id = ltask_id + 1;
+		CP15_DCACHE_INVALIDATE_CLEAN();
+#else
+		printk(KERN_INFO "shvar *(%p) = %d\n", ltask_id, *ltask_id);
+		*ltask_id = *ltask_id + 1;
+#endif
+	}
+
+	return 0;
+}
+
+#define CP15_VA_TO_PA_READ(x) \
+    __asm__ volatile ("mrc p15, 0, %0, c7, c4, 0":"=r"(x))
+
+#define CP15_VA_TO_PA_WRITE(x, perm)  \
+    __asm__ volatile ("mcr p15, 0, %0, c7, c8, %1"::"r"(x),"I"(perm))
+
+static int __init safeg_init(void)
+{
+	u32 phy_add;
+	void *virt_add;
+
+#ifdef SHVAR_METHOD_FLUSHCACHE
+	ltask_id = 0;
+	virt_add = (void *)&ltask_id;
+
+	CP15_VA_TO_PA_WRITE(virt_add, 1);
+	CP15_VA_TO_PA_READ(phy_add);
+
+	phy_add = ((unsigned int)phy_add & 0xFFFFFC00);
+	phy_add = ((unsigned int)phy_add | ((unsigned int)virt_add & 0x3FF));
+
+	printk(KERN_INFO "By CP15, virt:%p phy:%p\n",
+		virt_add, (void *)phy_add);
+
+	virt_add = (void *)&ltask_id;
+	phy_add  = virt_to_phys(virt_add);
+
+	printk(KERN_INFO "By Linux, virt:%p phy:%p\n",
+		virt_add, (void *)phy_add);
+#endif
+
+#ifdef SHVAR_METHOD_DMA
+	dma_addr_t dma_handle;
+
+	virt_add = dma_alloc_coherent(NULL, 4, &dma_handle, GFP_KERNEL);
+	if (!virt_add) {
+		printk(KERN_INFO "SAFEG: unable to allocate memory\n");
+		return -ENOMEM;
+	}
+	memset(virt_add, 0, 4);
+
+	ltask_id = (int *)virt_add;
+	phy_add  = (unsigned long)dma_handle;
+
+	printk(KERN_INFO "DMA alloc virt:%p phy:%p\n", ltask_id, (void *)phy_add);
+#endif
+
+#ifdef SHVAR_METHOD_BOOTARGS
+	virt_add = ioremap_nocache(SHM_PHYS_ADDRESS, SHM_SIZE);
+	ltask_id = (int *)virt_add;
+	phy_add  = SHM_PHYS_ADDRESS;
+#endif
+
+	safeg_switch_to_t(T_SMC_SWITCH_SHVAR, (int)phy_add);
+
+	the_task_struct = kthread_run(the_task, NULL, "nt-task");
+
+	return 0;
+}
+
+static void __exit safeg_exit(void)
+{
+	printk(KERN_INFO "Goodbye world\n");
+}
+
+module_init(safeg_init);
+module_exit(safeg_exit);
+
+MODULE_AUTHOR("Daniel Sangorrin <daniel.sangorrin@gmail.com>");
+MODULE_DESCRIPTION("SAFEG driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/safeg/safeg_latency.c
@@ -0,0 +1,253 @@
+#include "safeg_latency.h"
+#include "safeg_syscalls.h"
+#include <linux/sched.h>
+#include <linux/debugfs.h>
+#include <linux/dma-mapping.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+
+/*
+ * Measurements
+ *
+ * TODO: move it to safeg_measures so it is global, meanwhile make sure
+ * the values match in both worlds.
+ *
+ * Context switch tracepoints:
+ * NT-ctx_sta --> T-handl_sta([0]) --> T-mng_end([1]) --> NT-ctx_end([2])
+ */
+
+// #define MEAS_HISTOGRAM /* accumulates measures to display a histogram */
+#define MEAS_SAMPLING  /* takes sequential measures at each tracepoint */
+
+#define NUM_MEAS_POINTS  4
+#define NUM_HIST_SAMPLES 100
+#define NUM_SAMPLES 1000
+
+/*
+ * ASP-LINUX shared variables
+ */
+
+struct shared_vars_t {
+	int nt_prio;             // current nt priority (-32..140)
+	unsigned int ltask_idx;  // current ltask (0..NUM_LTASKS)
+	unsigned int measuring_flag; // a measure is going on
+#ifdef MEASURE_CTX_SWITCH
+#ifdef MEAS_HISTOGRAM
+	unsigned int hist[NUM_MEAS_POINTS][NUM_HIST_SAMPLES]; // histogram
+#endif
+#ifdef MEAS_SAMPLING
+	unsigned int sample_idx;
+	unsigned int samples[NUM_MEAS_POINTS][NUM_SAMPLES];
+#endif
+#endif
+};
+
+struct shared_vars_t *shvars = NULL;
+
+EXPORT_SYMBOL(shvars);
+
+/*
+ * DebugFS
+ */
+
+static struct dentry *safeg_debugfs_dir, *safeg_debugfs_activate;
+static u32 safeg_vret_active = false;
+
+/*
+ * Voluntary Return Ranges (kernel priorities => low is higher priority)
+ * Example: |-32..LTASK0..5|6..LTASK1..11|12..BTASK..140|
+ */
+static int ltask_lowest_nt_prio[NUM_LTASKS] = {
+	LTASK0_NT_LW_PRIORITY, // e.g.: 5
+	LTASK1_NT_LW_PRIORITY, // e.g.: 11
+	BTASK_NT_LW_PRIORITY   // 140
+};
+
+static unsigned int prio_to_ltask(int prio)
+{
+	unsigned int idx;
+
+	for(idx = 0; idx < NUM_LTASKS; idx++) {
+		if (prio <= ltask_lowest_nt_prio[idx])
+			return idx;
+	};
+
+	printk(KERN_INFO "ERROR: prio_to_ltask, disable vol return\n");
+	safeg_vret_active = false; // disable voluntary return
+	return NUM_LTASKS-1; /* BTASK */
+};
+
+/*
+ * Voluntary return hook (called from sched.c)
+ */
+
+void switch_hook(int next_prio)
+{
+	unsigned int ltask_idx;
+#ifdef MEASURE_CTX_SWITCH
+	volatile uint32_t result = 0;
+#endif
+	// do nothing if vol return is inactive
+	if (!safeg_vret_active) return;
+
+#ifdef MEASURE_CTX_SWITCH
+	shvars->measuring_flag = 1;
+	// CP15_DCACHE_CLEAN_AND_INVALIDATE();
+	CP15_PM_CONTROL_WRITE(0);
+	CP15_PM_CYCLE_WRITE(0);
+	CP15_PM_CONTROL_WRITE(1);
+#endif
+	// update current nt prio
+	shvars->nt_prio = next_prio;
+
+	// map priority to LTASK
+	ltask_idx = prio_to_ltask(next_prio);
+
+	// voluntary return if current LTASK is different
+	if (ltask_idx != shvars->ltask_idx) {
+		DEBUG(DBG_VOL_RET, "vol return: %s%d => %s%d(p:%d)\n",
+			(shvars->ltask_idx == (NUM_LTASKS-1)) ? "BTASK" : "LTASK",
+			 shvars->ltask_idx,
+			(ltask_idx == (NUM_LTASKS-1)) ? "BTASK" : "LTASK",
+		         ltask_idx, next_prio);
+#ifndef EMULATE_VOL_RET
+		safeg_switch_to_t(T_SMC_SWITCH_HANDLER, 0);
+#else
+		/* emulate a return to Trust world */
+		shvars->ltask_idx = ltask_idx;
+#endif
+#ifdef MEASURE_CTX_SWITCH
+		CP15_PM_CYCLE_READ(result);
+		CP15_PM_CONTROL_WRITE(0); // stop the performance counter
+		shvars->measuring_flag = 0;
+#ifdef MEAS_HISTOGRAM
+		result = result/210;
+		if (result >= NUM_HIST_SAMPLES)
+			shvars->hist[NUM_MEAS_POINTS-1][NUM_HIST_SAMPLES-1]++;
+		else
+			shvars->hist[NUM_MEAS_POINTS-1][result]++;
+#endif
+#ifdef MEAS_SAMPLING
+		shvars->samples[NUM_MEAS_POINTS-1][shvars->sample_idx] = result;
+		shvars->sample_idx = (shvars->sample_idx + 1) % NUM_SAMPLES;
+#endif
+#endif
+	}
+}
+
+/*
+ * Virtual File (cat /proc/safeg_debug)
+ * NOTE: copied from kernel/sched_debug.c
+ */
+
+static int safeg_debug_show(struct seq_file *m, void *v)
+{
+#ifdef MEASURE_CTX_SWITCH
+	int i, j;
+#ifdef MEAS_HISTOGRAM
+	seq_printf(m, "HISTOGRAM\n");
+	seq_printf(m, "index handler manager switch\n");
+	for (i = 0; i < NUM_HIST_SAMPLES; i++) {
+		seq_printf(m, "%05d ", i);
+		for (j = 0; j < NUM_MEAS_POINTS; j++)
+			seq_printf(m, "%05u ", shvars->hist[j][i]);
+		seq_printf(m, "\n");
+	}
+#endif
+#ifdef MEAS_SAMPLING
+	seq_printf(m, "SAMPLES\n");
+	seq_printf(m, "index handler manager switch\n");
+	for (i = 0; i < NUM_SAMPLES; i++) {
+		seq_printf(m, "%05d ", i);
+		for (j = 0; j < NUM_MEAS_POINTS; j++)
+			seq_printf(m, "%05u ", shvars->samples[j][i]);
+		seq_printf(m, "\n");
+	}
+#endif
+#endif
+	return 0;
+}
+
+static int safeg_debug_open(struct inode *inode, struct file *filp)
+{
+	return single_open(filp, safeg_debug_show, NULL);
+}
+
+static const struct file_operations safeg_debug_fops = {
+	.open           = safeg_debug_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static int __init init_safeg_debug_procfs(void)
+{
+	struct proc_dir_entry *pe;
+
+	pe = proc_create("safeg_debug", 0444, NULL, &safeg_debug_fops);
+	if (!pe)
+		return -ENOMEM;
+	return 0;
+}
+
+__initcall(init_safeg_debug_procfs);
+
+/*
+ * Latency framework initialization
+ */
+
+int latency_initialize()
+{
+	void *va;
+	dma_addr_t pa;
+
+	// allocate cache coherent memory for the shared variables
+	va = dma_alloc_coherent(NULL, sizeof(struct shared_vars_t), &pa, GFP_KERNEL);
+	if (!va) {
+		printk(KERN_INFO "SAFEG: unable to allocate memory\n");
+		return -ENOMEM;
+	}
+	shvars = (struct shared_vars_t *)va;
+
+	// init shared variables
+	shvars->nt_prio		= BTASK_NT_LW_PRIORITY;
+	shvars->ltask_idx	= prio_to_ltask(shvars->nt_prio);
+	shvars->measuring_flag	= 0;
+#ifdef MEASURE_CTX_SWITCH
+#ifdef MEAS_HISTOGRAM
+	memset((void *)shvars->hist, 0, sizeof(shvars->hist));
+#endif
+#ifdef MEAS_SAMPLING
+	shvars->sample_idx	= 0;
+	memset((void *)shvars->samples, 0, sizeof(shvars->samples));
+#endif
+#endif
+
+	// send physical address of the shared variables to Trust world
+	if(DBG_LAT_INIT)
+		printk(KERN_INFO "shvars:0x%p (pa:0x%X) [prio:%d, ltask_idx:%d]",
+			   shvars, pa, shvars->nt_prio, shvars->ltask_idx);
+
+#ifndef EMULATE_VOL_RET
+	safeg_switch_to_t(T_SMC_SWITCH_SHVAR, (int)pa);
+#endif
+	// create debugfs directory with activate boolean
+	safeg_debugfs_dir = debugfs_create_dir("safeg", NULL);
+	if (!safeg_debugfs_dir)
+		goto error;
+
+	safeg_debugfs_activate =
+		debugfs_create_bool("activate_voluntary_return", 0644,
+				     safeg_debugfs_dir, &safeg_vret_active);
+	if (!safeg_debugfs_activate)
+		goto error;
+
+// 	safeg_vret_active = true;
+
+	return 0;
+error:
+	debugfs_remove(safeg_debugfs_dir);
+	debugfs_remove(safeg_debugfs_activate);
+	printk(KERN_INFO "ERROR in Latency module initialization\n");
+	return -1;
+}
--- /dev/null
+++ b/safeg/safeg_latency.h
@@ -0,0 +1,71 @@
+#ifndef __SAFEG_LATENCY_H__
+#define __SAFEG_LATENCY_H__
+
+#include <linux/sched.h>
+
+// LINUX PRIORITIES
+// ----------------
+//
+// ftrace.txt:
+//
+//    Kernel Space                     User Space
+//  ===============================================================
+//    0(high) to  98(low)     user RT priority 99(high) to 1(low)
+//                            with SCHED_RR or SCHED_FIFO
+//  ---------------------------------------------------------------
+//   99                       sched_priority is not used in scheduling
+//                            decisions(it must be specified as 0)
+//  ---------------------------------------------------------------
+//  100(high) to 139(low)     user nice -20(high) to 19(low)
+//  ---------------------------------------------------------------
+//  140                       idle task priority
+//  ---------------------------------------------------------------
+//
+// For RT threads (MAX_RT_PRIO = 100):
+//
+// Kernel priority: task->prio
+// User priority:   stored in task->rt_priority (set with sched_setscheduler)
+// Mapping:         prio = MAX_RT_PRIO - 1 - task->rt_priority; (99 - rtprio)
+//                  e.g.: user(1)  => kernel(98=99-1)
+//                  e.g.: user(99) => kernel(0=99-99)
+// Is a RT thread? rt_prio(): prio < MAX_RT_PRIO
+//
+// shared_vars->nt_prio values
+// ---------------------------
+// -32(high)..-1(low): Interrupt priorities
+// 0(high)..99(low): RT priorities
+// 100..140: BTASK by default
+//
+// Other info:
+// http://www.spinics.net/lists/linux-rt-users/msg04215.html
+// http://www.kernel.org/doc/man-pages/online/dir_section_2.html
+
+#define NUM_LTASKS	(CONFIG_SAFEG_TASK_GROUPS_NUMBER + 1) // 2 + 1(BTASK)
+#define LTASK0_NT_LW_PRIORITY	CONFIG_SAFEG_TASK_GROUP_1  // 5
+#define LTASK1_NT_LW_PRIORITY	CONFIG_SAFEG_TASK_GROUP_2  // 11
+#define BTASK_NT_LW_PRIORITY	MAX_PRIO // 140, see linux/sched.h
+
+#ifndef DEBUG
+#define DEBUG(enable,x,args...)  \
+if(enable) trace_printk("" x, ##args)
+// if(enable) printk(KERN_INFO "" x, ##args)
+// 	if(enable) printk(KERN_INFO "%s: " x, __func__ , ##args)
+#endif /* DEBUG */
+
+#define DBG_LAT_INIT false
+#define DBG_VOL_RET  false
+
+// #define EMULATE_VOL_RET
+// #define MEASURE_CTX_SWITCH
+// #define KTASK_ENABLE
+
+#define Asm	__asm__ volatile
+#define CP15_PM_CONTROL_WRITE(x) Asm("mcr p15, 0, %0, c15, c12, 0"::"r"(x))
+#define CP15_PM_CYCLE_READ(x) Asm("mrc p15, 0, %0, c15, c12, 1":"=r"(x))
+#define CP15_PM_CYCLE_WRITE(x) Asm("mcr p15, 0, %0, c15, c12, 1"::"r"(x))
+#define CP15_DCACHE_CLEAN_AND_INVALIDATE() \
+	__asm__ volatile ("mcr p15, 0, %0, c7, c14, 0":: "r"(0))
+
+extern int latency_initialize(void);
+
+#endif /* __SAFEG_LATENCY_H__ */
--- /dev/null
+++ b/safeg/safeg_latency2.c
@@ -0,0 +1,93 @@
+#include <linux/dma-mapping.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+
+#define Asm	__asm__ volatile
+
+#include "safeg_latency2.h"
+#include "../../safeg/safeg/nt_safeg_syscalls.h"
+
+/*
+ * Global variables
+ */
+static volatile u32 safeg_vret_active = false;
+
+/*
+ * Shared variables (check mmu.c settings)
+ */
+struct shared_vars_t {
+	int      nt_prio; // nt priority (-32..140)
+	uint32_t ltask;   // current ltask (0..NUM_LTASKS)
+};
+
+volatile struct shared_vars_t *shvars = NULL;
+EXPORT_SYMBOL(shvars);
+
+/*
+ * LTASK management data
+ */
+#define NUM_LTASKS          2
+#define NUM_PRI             12
+uint32_t ntprio_to_ltask[NUM_PRI] = {0,0,0,0,0,0,1,1,1,1,1,1};
+
+/*
+ * Voluntary return hook
+ */
+
+static dma_addr_t pa;
+static bool first_time = true;
+
+void switch_hook(int next_prio)
+{
+	uint32_t next_ltask;
+
+	if (!safeg_vret_active) return;
+
+	if (first_time) {
+		first_time = false;
+		safeg_switch_to_t(T_SMC_SWITCH_SHVAR, (int)pa);
+		return;
+	}
+
+	shvars->nt_prio = next_prio;
+
+	if (shvars->nt_prio >= NUM_PRI)
+		next_ltask = NUM_LTASKS;
+	else
+		next_ltask = ntprio_to_ltask[shvars->nt_prio];
+
+	if (shvars->ltask != next_ltask) {
+		safeg_raise_softfiq();
+	}
+}
+
+/*
+ * Initialization
+ */
+
+int latency_initialize()
+{
+	void *va;
+	struct dentry *dir, *act;
+
+	// allocate cache coherent memory for the shared variables
+	va = dma_alloc_coherent(NULL, sizeof(struct shared_vars_t), &pa, GFP_KERNEL);
+	if (!va) {
+		printk(KERN_INFO "SAFEG: unable to allocate memory\n");
+		return -ENOMEM;
+	}
+	shvars = (struct shared_vars_t *)va;
+
+    // init shared variables
+	shvars->nt_prio  = NUM_PRI;
+	shvars->ltask    = NUM_LTASKS;
+
+	// create debugfs directory with activate boolean
+	dir = debugfs_create_dir("safeg", NULL);
+	act = debugfs_create_bool("activate_voluntary_return", 0644,
+							  dir, (u32 *)&safeg_vret_active);
+
+	return 0;
+}
+
--- /dev/null
+++ b/safeg/safeg_latency2.h
@@ -0,0 +1,6 @@
+#ifndef __SAFEG_LATENCY_H__
+#define __SAFEG_LATENCY_H__
+
+extern int latency_initialize(void);
+
+#endif /* __SAFEG_LATENCY_H__ */
